#---	class AXIOMtoJSON.py

import uuid
import os
import re
import json
import re
import sys
#import logging
from case_builder import *
from datetime import datetime
from pytz import timezone

class AXIOMtoJSON:
	'''
	Represents all attributes and methods to represent Traces in CASE ontology, starting from data
	extracted from XML reports generated by UFED-PA forensic tool
	'''
	TAB = '\t'
# default value for string value not provided
#
	NP = ''				

# default value for integer value not provided
#
	INT = '0'	

# default value for date value not provided
#
	DATE = '1900-01-01T08:00:00'

# default value for Hash Method value not provided
#
	HASH_M = 'MD5'

# default value for Hash Method value not provided
#
	HASH_V = '2' * 76

# default value for the property referrerUrl of the URLHistoryFacet class
#
	REF_URL = 'http:www.empty.com/referrer_url'

# default value for the location where a forensic action was carried out
#
	LOCATION = 'Unknown location'

	def __init__(self, json_output=None, case_bundle=None, commaLine=True):
#---	logging
#		
		#logging.basicConfig(filename='_axiom_log.txt', level=logging.INFO,
		#	filemode='w', format='%(message)s')
		self.bundle = case_bundle
		self.FileOut = json_output
		self.commaLine = commaLine
		self.phoneNumberList = []
		self.phoneNameList = []
		self.phoneUuidList = []
		self.object_phone_owner = None
		
		self.appNameList = []
		self.appAccountUsernameList = []
		self.appAccountNameList = []
		self.appIDList = []

		self.CHATparticipantsNameList = []
		self.CHATparticipantsIdList = []
		self.CHATaccountIdList = []
		self.CHATthread = []

		self.observable_device = ''

		self.EMAILaddressUuid = {}
		self.EMAILregex = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
		self.phoneOwnerNumber = ''
		self.observable_phone_owner = None
		self.FILEuuid = {}
		self.FILEid = []

		self.EXTRA_INFOdictPath = {}
		self.EXTRA_INFOdictSize = {}
		self.EXTRA_INFOdictTableName = {}
		self.EXTRA_INFOdictOffset = {}
		self.EXTRA_INFOdictNodeInfoId = {}

		self.CHATids = []
		self.CHATsenders = []
		self.CHATreceivers = []
		self.CHATdateTimeSents = []
		self.CHATdateTimeReceiveds = []
		self.CHATmessages = []
		self.CHATmessageStatuses = []
		self.CHATsources = []
		self.CHATlocations = []
		self.CHATrecoveryMethods = []
		self.CHATapplications = []

		self.UrlList = {}

		self.LocationList = []
		self.LocationIDList = []

		self.LOCATION_lat_long_coordinate = {}
		self.CELL_TOWER_gsm ={}
		self.WIRELESS_NET_mac_address = {}
		self.SEARCHED_ITEMvalue_date = []


		
	# static methods do not receive class or instance arguments
	# and usually operate on data that is not instance or class-specific
	@staticmethod
	def __createUUID():
		'''	
		Traces in CASE have a unique identification number, based on Globally Unique Identifier.  
		Each time a Trace is generated this static method in invoked, it doen't depends on any object
		'''
		return str(uuid.uuid4())

	def __cleanJSONtext(self, originalText):
		new_text = originalText.strip()
		if new_text == '':
			return ''
		else:
			new_text = new_text.replace('"', "").replace('\n', '').replace('\r', '')
			new_text = new_text.replace('\t', " ").replace("\\'", "'").replace("\\", "")
			new_text = new_text.replace('�', '')
			return new_text

	
	def __convert_str_to_datetime(self, str_date):
		if str_date.strip() == "":
			str_date = "1900-01-01T00:00:00"
		if str_date.find('+') > -1:
			date_time = datetime.strptime(str_date, 
				'%Y-%m-%dT%H:%M:%S.%f%z')
		else:
			date_time = datetime.strptime(str_date, 
				'%Y-%m-%dT%H:%M:%S')
		
		return date_time
	
	def __checkAppName(self, name):
		if name in self.appNameList: 
			idx = self.appNameList.index(name)
			observable_app = self.appIDList[idx]
		else:
			observable_app = self.__generateTraceAppName(name)
			self.appNameList.append(name)
			self.appIDList.append(observable_app)
		
		return observable_app

	def __checkChatParticipant(self, chat_id, chat_name, chat_source, id_app):
		if chat_id.strip() in self.CHATparticipantsIdList: 
			idx = self.CHATparticipantsIdList.index(chat_id.strip())
			observable_chat_account = self.CHATaccountIdList[idx]
		else:
			self.CHATparticipantsNameList.append(chat_name.strip())
			observable_chat_account = self.__generateTraceApplicationAccount(chat_id.strip(), 
				chat_name.strip(), id_app)
			self.CHATparticipantsIdList.append(chat_id.strip())
			self.CHATaccountIdList.append(observable_chat_account)
		
		return observable_chat_account

	def __checkGeoCoordinates(self, latitude, longitude, elevation, category):
		latitude = latitude.strip()
		longitude = longitude.strip()
		
		observable_location = None
		if latitude != '' and longitude != '':
			id_geo_loc = latitude + '@' + longitude
			if id_geo_loc in self.LOCATION_lat_long_coordinate.keys():
				observable_location = self.LOCATION_lat_long_coordinate[id_geo_loc]
			else:
				observable_location = self.__generateTraceLocationCoordinate(latitude, 
					longitude, elevation, category)
				self.LOCATION_lat_long_coordinate[id_geo_loc] = observable_location

		return observable_location

	def __checkSearchedItems(self, value):
		
		itemFound = False
		if value not in self.SEARCHED_ITEMvalue_date:			
			self.SEARCHED_ITEMvalue_date.append(value)
			itemFound = True

		return itemFound


	def __generateTraceDeviceEvent(self, event_id, event_time_stamp, 
		event_type, event_text):

		event_time_stamp = self.__cleanDate(event_time_stamp)		
		event_text = self.__cleanJSONtext(event_text)
		
		observable = uco.observable.ObservableObject()
		event_time_stamp = self.__convert_str_to_datetime(event_time_stamp)

		facet_event = uco.observable.FacetEvent(event_type=event_type, 
			event_text=event_text, created_time=event_time_stamp)
		observable.append_facets(facet_event)

		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceAppUsage(self, event_id, event_start_time, 
		event_end_time, event_type, event_text):
	
		event_start_time = self.__cleanDate(event_start_time)		
		event_end_time = self.__cleanDate(event_end_time)		
		event_text = self.__cleanJSONtext(event_text)
		
		observable = uco.observable.ObservableObject()
		event_start_time = self.__convert_str_to_datetime(event_start_time)

		event_end_time = self.__convert_str_to_datetime(event_end_time)

#---	event_end_time is not included in the class FacetEvent 
#		
		facet_event = uco.observable.FacetEvent(event_type=event_type, 
			event_text=event_text, created_time=event_start_time)
		observable.append_facets(facet_event)

		self.bundle.append_to_uco_object(observable)
		return observable

	def __checkEmailAddress(self, address):
		if address in self.EMAILaddressUuid.keys():
			observable_email_address = self.EMAILaddressUuid.get(address)
		else:
			observable_email_address = self.__generateTraceEmailAccount(address)
			self.EMAILaddressUuid[address] = observable_email_address
		
		return  observable_email_address

	def fillArrayWithEmpty(self, aInput, max):
		if len(aInput) < max:
			for i in range(len(aInput), max):						
				aInput.append('')

	def fillChatThread(self, chatThread, CHATid, CHATsender, CHATreceiver,
		CHATdateTimeSent, CHATdateTimeReceived, CHATmessage, CHATmessageStatus,
		CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod, CALLphoneNumber):

		for i, chat_sender in enumerate(CHATsender):
			if chat_sender.lower().find('local user') > -1:
				chat_sender = CALLphoneNumber

			if CHATreceiver[i].lower().find('local user') > -1:
				CHATreceiver[i] = CALLphoneNumber
			
			chatFound = False
			idx = -1
			for j, chat_thread in enumerate(chatThread):
				if (chat_sender in chat_thread and
					  CHATreceiver[i] in chat_thread and 
					  CHATapplication[i] in chat_thread):
					idx = j
					chatFound = True
					break
			
			if chatFound:		
				self.CHATids[idx].append(CHATid[i])
				self.CHATsenders[idx].append(chat_sender)
				self.CHATreceivers[idx].append(CHATreceiver[i])
				self.CHATdateTimeSents[idx].append(CHATdateTimeSent[i])
				self.CHATdateTimeReceiveds[idx].append(CHATdateTimeReceived[i])
				self.CHATmessages[idx].append(CHATmessage[i])
				self.CHATmessageStatuses[idx].append(CHATmessageStatus[i])
				self.CHATsources[idx].append(CHATsource[i])
				self.CHATlocations[idx].append(CHATlocation[i])
				self.CHATrecoveryMethods[idx].append(CHATrecoveryMethod[i])
				self.CHATapplications[idx].append(CHATapplication[i])
			else:
				idx = len(chatThread) - 1
				self.CHATids.append([CHATid[i]])
				self.CHATsenders.append([chat_sender])
				self.CHATreceivers.append([CHATreceiver[i]])
				self.CHATdateTimeSents.append([CHATdateTimeSent[i]])
				self.CHATdateTimeReceiveds.append([CHATdateTimeReceived[i]])
				self.CHATmessages.append([CHATmessage[i]])
				self.CHATmessageStatuses.append([CHATmessageStatus[i]])
				self.CHATsources.append([CHATsource[i]])
				self.CHATlocations.append([CHATlocation[i]])
				self.CHATrecoveryMethods.append([CHATrecoveryMethod[i]])
				self.CHATapplications.append([CHATapplication[i]])
				chatThread.append(chat_sender + '#' + CHATreceiver[i] + '#' + CHATapplication[i])

	def __cleanDate(self, initialDate):
		aMonths = {
			'Jan': '01',
			'Feb': '02',
			'Mar': '03',
			'Apr': '04',
			'May': '05',
			'Jun': '06',
			'Jul': '07',
			'Aug': '08',
			'Sep': '09',
			'Oct': '10',
			'Nov': '11',
			'Dec': '12'
		}
		
		initialDate = initialDate.strip()

		if 	initialDate == '':
			return AXIOMtoJSON.DATE

#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx)
#		the character "/" is not allowed
#		
		initialDate = initialDate.replace("/", "-")
		initialDate = initialDate.replace(' ', 'T', 1)
		initialDate = initialDate.replace('UTC', '')						
		initialDate = initialDate.replace('AM', '')
		initialDate = initialDate.replace('PM', '')
		startTZ = initialDate.find("+")
		if startTZ > -1:
			initialDate = initialDate[:startTZ]		
		
		for k,v in aMonths.items():
			if initialDate.find(k) > -1:
				initialDate = initialDate.replace(k, v)
				break
		
		firstChars = initialDate[:10]
		firstChars = firstChars.replace(".", "-")
		initialDate = firstChars + initialDate[10:]

		yearPattern = '\-[0-9][0-9]T'	# year with two digits
		resPattern = re.search(yearPattern, initialDate)
		if resPattern:
			if re.search('^[0-9]{4}', initialDate):
				pass
			else:
				initialDate = re.sub('-([0-9][0-9])T', '-20\g<1>T', initialDate)
				initialDate = str(initialDate[6:10]) + initialDate[2:6] + initialDate[0:2] + \
					initialDate[10:] 

		yearPattern = '\-\d{4}T'	# year with 4 digits in Italian format
		resPattern = re.search(yearPattern, initialDate)
		if resPattern:
			initialDate = str(initialDate[6:10]) + initialDate[2:6] + initialDate[0:2] + \
				initialDate[10:] 		

		if re.search('(\d{2}:\d{2}:\d{2})$', initialDate):
			pass
		else:
			initialDate = re.sub('(\d{2}:\d{2})$', '\g<1>:00', initialDate)

		if re.search('T(\d):', initialDate):
			initialDate = re.sub('T(\d):', 'T0\g<1>:', initialDate)

		if re.search(':(\d):', initialDate):
			initialDate = re.sub(':(\d):', ':0\g<1>:', initialDate)

		if re.search(':(\d)$', initialDate):
			initialDate = re.sub(':(\d)$', ':0\g<1>', initialDate)

		if re.search('T\d{2}:\d{2}:\d{2}(.+)$', initialDate):
			initialDate = re.sub('(T\d{2}:\d{2}:\d{2})(.+)$', '\g<1>', initialDate)
			

		return initialDate.strip()


	def ___generateContextAxiom(self, ufedVersion, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerName, 
		deviceBluetoothAddress, deviceId, devicePhoneModel, 
		deviceOsType, deviceOsVersion, devicePhoneVendor, 
		deviceMacAddress, deviceIccid, deviceImsi, deviceImei, 
		imagePath, imageSize, imageMetadataHashSHA, imageMetadataHashMD5):

		# generate Trace/Tool for the Acquisition and Extraction Actions
		object_tool = self.__generateTraceTool('AXIOM Process', 'Acquisition', 
			'MAGNET', ufedVersion, []);
		
		# generate Trace/Identity for the Performer, D.F. Expert, of the Actions
		object_identity = self.__generateTraceIdentity(examinerName, '', '')
		
		# generate Trace/Role for the Performer, D.F. Expert, of the Actions
		object_role = self.__generateTraceRole('Digital Forensic Expert')
		
		# generate Trace/Relation between the above Role and the Identity traces
		self.__generateTraceRelation(object_identity, object_role, 'has_role', '', '', '', '');
		
		# generate Trace/Provenance_Record for the  device
		observable_device_list = []
		observable_device_list.append(self.observable_device)
		object_provenance_device = self.__generateTraceProvencance(observable_device_list, 
			'Mobile device', '', deviceAcquisitionStartTime) 
		
		# generate Trace/File for each file extracted by the Acuisition action
		# idFileList contains the uuid of these files and it is used for
		# creating the Provenance_Record of the Result/Output of the Acquisition 
		# action
		idFilesAcquisition = []
		for i, image_path in enumerate(imagePath):
			if imageMetadataHashSHA[i].strip() == '':
				object_file_acquisition = self.__generateTraceFile(image_path, 
				imageSize[i], 'MD5', imageMetadataHashMD5[i], '', 
				'', '', '', '', '', '', '', '', '', '', '', '')  				 				
			else:
				object_file_acquisition = self.__generateTraceFile(image_path, 
				imageSize[i], 'SHA256', imageMetadataHashSHA[i], '', 
				'', '', '', '', '', '', '', '', '', '', '', '') 				
			
			object_files_acquisition.append(object_file_acquisition)  	
		

		object_provenance_acquisition_files = \
			self.__generateTraceProvencance(object_files_acquisition, 
				'Acquisition files', '', deviceAcquisitionStartTime)

		idProvenanceAcquisitionFilesList = []
		idProvenanceAcquisitionFilesList.append(object_provenance_acquisition_files)

		idProvencanceAcquisitionAction = \
		self.__generateTraceInvestigativeAction('acquisition', 
			'Forensic mobile device acquisition', deviceAcquisitionStartTime, 
			deviceAcquisitionEndTime, idTool, '', 
			idIdentity, idProvenanceDevice, idProvenanceAcquisitionFilesList, ',');

		idFilesExtraction = []
		for uuidFile in self.FILEuuid.values(): 
			idFilesExtraction.append(uuidFile)

		idProvenanceExtractionFiles = \
		self.__generateTraceProvencance(idFilesExtraction, 'Extraction',
			'', deviceExtractionStartTime)

		idProvenanceExtractionFilesList = []
		idProvenanceExtractionFilesList.append(idProvenanceExtractionFiles)
		self.__generateTraceInvestigativeAction('extraction', 
			'Forensic mobile device extraction', deviceExtractionStartTime,
			'', idTool, '', idIdentity,
			idProvenanceAcquisitionFiles, idProvenanceExtractionFilesList, '');

	def __generateChainOfEvidence(self, source, location, uuidTrace):
		filePath = ''
		charSeparator = '/'
		separator = source.find(charSeparator)
		if separator > - 1:
			filePath = source[separator:]
		else:
			charSeparator = '\\'
			separator = source.find(charSeparator)
			if separator > - 1: 
				filePath = source[separator:]
			else:
				filePath = source
				fileName = source
				fileExt = ''			

		if separator > - 1:
			fileName = filePath.split(charSeparator)[-1]
			fileExt = fileName[fileName.rfind('.') + 1:]

		openPar = source.find('(')
		closePar = source.find(')')
		fileSysType = source[openPar + 1: closePar]
		
		filePath = filePath.replace('"', "").replace('\n', '').replace('\r', '')
		filePath = filePath.replace('\t', " ").replace("\\", "/")

		location = self.__cleanJSONtext(location)

		uuidFile = self.__generateTraceFileCoE(filePath, fileName, fileExt, fileSysType,
			location)

		self.FILEuuid[uuidFile.get_id()] = uuidTrace
		

		self.__generateTraceRelation(uuidTrace, uuidFile, 'Contained_Within', 
				location, '00001', '', '');
		return ''


	def __generateTraceApplicationAccount(self, name, identifier, id_app):
		
		name = self.__cleanJSONtext(name)
		identifier = self.__cleanJSONtext(identifier)

		observable = uco.observable.ObservableObject()

		facet_account = uco.observable.FacetAccount(identifier)
		facet_app_account = uco.observable.FacetApplicationAccount(application=id_app)		
		facet_digital_account = uco.observable.FacetDigitalAccount(display_name=name)    	
		
		observable.append_facets(facet_account, facet_app_account, facet_digital_account)
		
		self.bundle.append_to_uco_object(observable)		
		return observable
	
	def __generateTraceAppName(self, app_name):
		observable = uco.observable.ObservableObject()
		facet_application = uco.observable.FacetApplication(app_name=app_name)
		observable.append_facets(facet_application)
		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceAppIdentity(self, appName):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:IdentityFacet",
			"uco-core:hasFacet":[ 
				{
					"@type":"uco-observable:OrganizationFacet", 
					"uco-observable:orgName":appName
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid		

	def __generateTraceChat(self, body, id_app, time_stamp, phone_uuid_from,
		phone_uuid_to, status, outcome, direction, message_type, attachmentNames, 
		attachmentUrls):

		time_stamp = self.__convert_str_to_datetime(time_stamp)		
		body = self.__cleanJSONtext(body)

		observable_msg = uco.observable.ObservableObject()
		facet_message = uco.observable.FacetMessage(msg_to=phone_uuid_to, 
			msg_from=phone_uuid_from, message_text=body, sent_time=time_stamp,
	                 application=id_app, message_type=message_type)
		observable_msg.append_facets(facet_message)
		
		self.bundle.append_to_uco_object(observable_msg)
						
	
#---	each Message, within a specific Chat can have more than one attachment,
# 		both the Filenames and the Urls of the Attachment are separated by
# 		a triple hash tag # 
#		
		listFileNames = attachmentNames.split('###');
		listFileUrls = attachmentUrls.split('###');
		nName = len(listFileNames)
		nUrl = len(listFileUrls)
		if nName > nUrl:
			for i in range(nName - nUrl):
				listFileUrls.append('')
		if nName < nUrl:
			for i in range(nUrl - nName):
				listFileNames.append('')


		for i, list_file_name in enumerate(listFileNames):
			if (list_file_name.strip() != '') or \
			 	(listFileUrls[i].strip() != ''):
#---	listFileUrls[i] will be stored in the property path of the FILE trace
#			 	
				observable_file = self.__generateTraceFile(list_file_name, 
				'', '', '', '', '', '', '', listFileUrls[i],
				'', '', '', '', '', '', '', '')
				
				self.__generateTraceRelation(observable_file, observable_msg, 'Attached_To', 
				'', '', '', '')
		return observable_msg

	
	def __generateTraceDeviceDisk(self, size, partitions_ref):
		
		observable = uco.observable.ObservableObject()
		size=int(size)
		facet_disk = uco.observable.FacetDisk(disk_type="Fixed", size=size, 
			partition=partitions_ref)
		
		observable.append_facets(facet_disk)

		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceDiskPartition(self, serial_number, type, total_space, space_left, 
		space_used, offset):
		
		observable = uco.observable.ObservableObject()
		total_space=int(total_space)
		space_left=int(space_left)
		space_used=int(space_used)
		offset=int(offset)
		facet_disk_partition = uco.observable.FacetDiskPartition(serial_number=serial_number, 
			partition_type=type, total_space=total_space, space_left=space_left, space_used=space_used, 
			offset=offset)   

		observable.append_facets(facet_disk_partition)

		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceDeviceMobile(self, deviceId, deviceIMSI, deviceBluetoothAddress, 
		deviceBluetoothName, deviceIMEI, deviceSN, deviceName, 
		deviceModel, deviceICCID, deviceOSVersion):

		observable = uco.observable.ObservableObject()
		facet_device = uco.observable.FacetDevice(device_type="Mobile phone",
			model=deviceModel, serial=deviceSN)	
		facet_mobile = uco.observable.FacetMobileDevice(IMSI=deviceIMSI, ICCID=deviceICCID,
			IMEI=deviceIMEI)
		facet_operating_system = uco.observable.FacetOperatingSystem(
			os_version=deviceOSVersion)
		facet_bluetooth = uco.observable.BluetoothAddress(name=deviceBluetoothName,
			address=deviceBluetoothAddress)

		observable.append_facets(facet_device, facet_mobile, facet_operating_system, 
    		facet_bluetooth)
    	
		self.bundle.append_to_uco_object(observable)		
		
		return observable

	
	def __generateTraceEmail(self, EMAILid, EMAILstatus, EMAILsource, EMAILlocation,
		EMAILidentifierFROM, EMAILidentifiersTO, EMAILidentifiersCC, 
		EMAILidentifiersBCC, EMAILbody, EMAILsubject, EMAILtimeStamp, 
		EMAILattachmentsFilename):
		
		address_from = re.search(self.EMAILregex, EMAILidentifierFROM)
		if address_from:
			idFROM = self.__checkEmailAddress(address_from.group().strip())
		else:
			idFROM = self.__checkEmailAddress(EMAILidentifierFROM.strip())
		
		itemsTO = ''		
		EMAILtoList = re.findall(self.EMAILregex, EMAILidentifiersTO)
		email_distinct = set(EMAILtoList)
		itemsTO = []
		for item in email_distinct:			
			if item.strip() != '':				
				observable_to_address = self.__checkEmailAddress(item.strip().lower())				
				itemsTO.append(observable_to_address)
		
		itemsCC = []
		EMAILtoList = re.findall(self.EMAILregex, EMAILidentifiersCC)
		email_distinct = set(EMAILtoList)
		for item in email_distinct:
			if item.strip() != '':
				observable_cc_address = self.__checkEmailAddress(item.strip().lower())
				itemsCC.append(observable_cc_address)
		
		itemsBCC = []
		EMAILtoList = re.findall(self.EMAILregex, EMAILidentifiersBCC)
		email_distinct = set(EMAILtoList)
		for item in email_distinct:
			if item.strip() != '':
				observable_bcc_address = self.__checkEmailAddress(item.strip().lower())
				itemsBCC.append(observable_bcc_address)


		body = self.__cleanJSONtext(EMAILbody)
		subject = self.__cleanJSONtext(EMAILsubject)
#--- Replace all characters different from number, space or character with nothing
#		
		subject = re.sub('[^0-9A-Za-z ]','', subject)

#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx
#			the character "/" is not allowed
#		
		EMAILtimeStamp = self.__cleanDate(EMAILtimeStamp)
		EMAILtimeStamp = self.__convert_str_to_datetime(EMAILtimeStamp)
		
		observable_email = uco.observable.ObservableObject()		
		facet_email_message = uco.observable.FacetEmailMessage(msg_to=itemsTO, 
			msg_from=idFROM, cc=itemsCC, bcc=itemsBCC, subject=subject, body=body, 
            sent_time=EMAILtimeStamp, allocation_status=EMAILstatus)


		observable_email.append_facets(facet_email_message)
		self.bundle.append_to_uco_object(observable_email)

		self.__generateChainOfEvidence(EMAILsource, EMAILlocation, observable_email)		

		email_attachment_list = EMAILattachmentsFilename.split(',')
		for i, email_file in enumerate(email_attachment_list):
			if email_file.strip() != '':
				observable_file = self.__generateTraceFile(email_file, 
				'', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '')
				self.__generateTraceRelation(observable_file, observable_email, 
					'Attached_To', '', '', '', '')
		
		return observable_email

	def __generateTraceEmailAccount(self, address):

		observable_email_address = self.__generateTraceEmailAddress(address)
		observable_email_account = uco.observable.ObservableObject()
		facet_email_account = uco.observable.FacetEmailAccount(observable_email_address)
		facet_account = uco.observable.FacetAccount("")
		observable_email_account.append_facets(facet_account, facet_email_account)
		
		self.bundle.append_to_uco_object(observable_email_account)
		
		return observable_email_account


	def __generateTraceEmailAddress(self, address):
		
		address = self.__cleanJSONtext(address)
		observable = uco.observable.ObservableObject()
		facet_email_address = uco.observable.FacetEmailAddress(email_address_value=address)
		observable.append_facets(facet_email_address)
		
		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceFile(self, FILEpath, FILEsize, FILEhashType, 
		FILEHashValue, FILETag, FILEtimeC, FILEtimeM, FILEtimeA, FILElocalPath, 
		FILEextension, FILEexifMake, FILEexifModel, FILEexifLatitudeRef, FILEexifLatitude, 
		FILEexifLongitudeRef, FILEexifLongitude, FILEexifAltitude):
		
		observable_file = uco.observable.ObservableObject()
		head, tail = os.path.split(FILEpath)
		tail = self.__cleanJSONtext(tail)

		path = FILEpath.replace('\\', '/')
		path = path.replace('"', "'")

		dotPos = tail.find('.')
		sExt = ''
		if dotPos > -1:
			sExt = tail[dotPos:]
		

		if FILEhashType.upper() == '_NOT_PROVIDED_':
			FILEhashType = 'MD5'		

		if  FILEsize.strip != '0' and FILEHashValue.upper() != "N/A":	
			facet_content = uco.observable.FacetContentData(hash_method=FILEhashType, 
				hash_value=FILEHashValue)
			observable_file.append_facets(facet_content)

		if FILEsize.strip() == '':
			FILEsize = int(AXIOMtoJSON.INT)
		else:
			FILEsize = int(FILEsize)

		localPath = FILEpath.replace('"', "").replace('\n', '').replace('\r', '')
		localPath = localPath.replace("\\", "/")
		
		FILEtimeC = self.__cleanDate(FILEtimeC)
		FILEtimeC = self.__convert_str_to_datetime(FILEtimeC)
		FILEtimeM = self.__cleanDate(FILEtimeM)
		FILEtimeM = self.__convert_str_to_datetime(FILEtimeM)
		FILEtimeA = self.__cleanDate(FILEtimeA)
		FILEtimeA = self.__convert_str_to_datetime(FILEtimeA)
		
		
		if FILEexifLatitude.strip() != '':	
			FILEexifLatitude = FILEexifLatitude.strip('" ')			
			FILEexifLongitude = FILEexifLongitude.strip('" ')
			FILEexifLatitude = FILEexifLatitude.replace('°', ', ').replace("'", ', ')
			FILEexifLongitude = FILEexifLongitude.replace('°', ', ').replace("'", ', ')
			FILEexifAltitude = FILEexifAltitude.strip('" ')
			exif_data = {"Make":FILEexifMake, 
				"Model":FILEexifModel, "LatitudeRef":FILEexifLatitudeRef,
				"Latitude":FILEexifLatitude, "LongitudeRef":FILEexifLongitudeRef,
				"Longitude":FILEexifLongitude, "Altitude":FILEexifAltitude}		
			facet_exif = uco.observable.FacetEXIF(**exif_data)
			observable_file.append_facets(facet_exif)


		facet_file = uco.observable.FacetFile(tag=[FILETag], file_name=tail, 
			file_path=path, file_local_path=localPath, file_extension=sExt,
                 size_bytes=FILEsize, accessed_time=FILEtimeA, created_time=FILEtimeC, 
                 modified_time=FILEtimeM)
		observable_file.append_facets(facet_file) 

		self.bundle.append_to_uco_object(observable_file)

		return observable_file

#---	FileFacet for the Chain of Evidence
#		the data are FileName, FilePath, FileExt, FileSystemType
#		
	def __generateTraceFileCoE(self, FILEpath, FILEname, FILEext, FILEsysType, 
		FILElocation):
		
		FILEsysType = self.__cleanJSONtext(FILEsysType)

		observable_file = uco.observable.ObservableObject()

		facet_file = uco.observable.FacetFile(tag=["Binary"], file_name=FILEname, 
			file_path=FILEpath, file_extension=FILEext)
		observable_file.append_facets(facet_file) 

		self.bundle.append_to_uco_object(observable_file)

		return observable_file


	def __generateTraceIdentity(self, name, familyName, birthDate):
		
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		birthDate = self.__cleanDate(birthDate)

		object_dict = {
			"@id": uuid,
			"@type":"uco-identity:Identity", 
			"uco-core:hasFacet":[
				{
					"@type":"uco-identity:SimpleName",
					"uco-identity:givenName":name,
					"uco-identity:familyName":familyName
				},
				{
					"@type":"uco-identity:BirthInformation",
					"uco-identity:birthdate":{
						"@type":"xsd:dateTime",
						"@value":birthDate
					}
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceLocationDevice(self, loc_id, loc_longitude, loc_latitude, 
		loc_category):
		
		observable_location = self.__checkGeoCoordinates(loc_latitude, loc_longitude,
			'', loc_category)

		return observable_location

	def writePhoneAccountFromContacts(self, CONTACTname, CONTACTphoneNums):
		for i, contact_name in enumerate(CONTACTname):
			CONTACTphoneNums[i] = CONTACTphoneNums[i].replace(' ', '')
			if CONTACTphoneNums[i] not in self.phoneNumberList:					
				self.phoneNumberList.append(CONTACTphoneNums[i])
				self.phoneNameList.append(contact_name)
				mobileOperator = ""
				observable_phone = self.generateTracePhoneAccount(mobileOperator, contact_name, 
					CONTACTphoneNums[i])
				self.phoneUuidList.append(observable_phone)		

	def generateTracePhoneAccount(self, source, name, phone_num):

		name = self.__cleanJSONtext(name)
		
		observable = uco.observable.ObservableObject()
		facet_phone_account = uco.observable.FacetPhoneAccount(phone_number=phone_num, 
			account_name=name)
		facet_account = uco.observable.FacetAccount("", is_active=True, 
			issuer_id=source)
		observable.append_facets(facet_account, facet_phone_account)

		self.bundle.append_to_uco_object(observable)
		return observable
				

	def __generateTraceSearchedItem(self, search_id, search_value, search_timestamp, 
		search_app):

		search_value = self.__cleanJSONtext(search_value)
		if search_value.strip() == '':
			return ''
			
		search_timestamp = self.__cleanDate(search_timestamp)		

		if not self.__checkSearchedItems(search_value + search_timestamp):
			return None

		observable_app = self.__checkAppName(search_app)

		observable = uco.observable.ObservableObject()
		
		search_timestamp = self.__convert_str_to_datetime(search_timestamp)

		facet_searched_item = not_in_ontology.entities.FacetSearchedItem(
		search_value=search_value, application=observable_app, 
		search_launch_time=search_timestamp)
		observable.append_facets(facet_searched_item)
		
		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceInvestigativeAction(self, name, description, startTime, endTime, 
		idInstrument, location, idPerformer, idObject, listResult, endChar):
		
		n = len(listResult)
		lineResult = '['
		for i in range(n - 1):
			lineResult += '{"@id":"' + listResult[i] + '"},';

		if n > 0:
			lineResult += '{"@id":"' + listResult[n - 1]  + '"}'
			
		lineResult += ']';

		lineResult = json.loads(lineResult)

		idObject = '[' + \
					'{"@id":idObject}]'
		idObject = json.loads(idObject)
		
		startTime = self.__cleanDate(startTime)
		endTime = self.__cleanDate(endTime)
		
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-action:Action", 
			"uco-action:name":name,
			"uco-action:description":description,
			"uco-action:startTime":{
				"@type":"xsd:dateTime",
				"@value":startTime
			},
			"uco-action:endTime":{
				"@type":"xsd:dateTime",
				"@value":endTime
			},
			"uco-core:hasFacet":[
				{
					"@type":"uco-action:ActionReferences",
					"uco-action:instrument":{
						"@id":idInstrument
					},
					"uco-action:location":{
						"@id":location
					},
					"uco-action:performer":{
						"@id":idPerformer
					},
					"uco-action:object":idObject,
					"uco-action:result":lineResult			
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTracePhoneCall(self, direction, start_time, idFROM, idTO, 
								duration, status, outcome):
		nTime = 0
		if duration != '':
			aTime = duration.split(":")
			if len(aTime) == 3:
				nTime = aTime[0]*3600 + aTime[1]*60 + aTime[2] 
			if len(aTime) == 2:
				nTime = aTime[0]*60 + aTime[1] 
			if len(aTime) == 1:
				nTime = aTime[0] 
		duration = str(nTime)
		duration = duration.lstrip('0')
		if duration == "":
			duration = "0"

		duration = int(duration)
		start_time = self.__cleanDate(start_time)
		start_time = self.__convert_str_to_datetime(start_time)
		observable_app = self.__checkAppName("Native")
	
		observable = uco.observable.ObservableObject()
		
		facet_phone_call = uco.observable.FacetPhoneCall(call_type=direction,
			start_time=start_time, application=observable_app, call_from=idFROM, 
			call_to=idTO, call_duration=duration, allocation_status=status)		
		observable.append_facets(facet_phone_call)

		self.bundle.append_to_uco_object(observable)
		return observable
	
	def __generateTracePhoneOwner(self, source, name, phone_num):
		observable = uco.observable.ObservableObject()
		facet_account = uco.observable.FacetAccount("_")
		name += ' (Owner)'
		facet_phone_account = uco.observable.FacetPhoneAccount(phone_number=phone_num,
			account_name=name)

		observable.append_facets(facet_account, facet_phone_account)
		self.bundle.append_to_uco_object(observable)
		
		self.object_phone_owner = observable
		self.phoneNumberList.append(phone_num)
		self.phoneUuidList.append(self.object_phone_owner)		
		return observable

	def __generateTraceProvencance(self, idTracesList, description, 
		exhibitNumber, creationTime):
		n = len(idTracesList)
		lineTraces = '['		
		for idx in range(n - 1):
			lineTraces += '{"@id":"' + idTracesList[idx] + '"},'

		if n > 0:
			lineTraces += '{"@id":"' + idTracesList[n - 1] + '"}]'

		lineTraces = json.loads(lineTraces)
		creationTime = self.__cleanDate(creationTime)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"case-investigation:ProvenanceRecord", 
			"case-investigation:createdTime":{
				"@type":"xsd:dateTime",
				"@value":creationTime
			},
			"case-investigation:description":description,
			"case-investigation:exhibitNumber":exhibitNumber,			
			"case-investigation:object":lineTraces			
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')

		return uuid
	
	def __generateStringRelation(self, source, target, relation, table, offset,
		start_date, end_date):		
		
		start_date = self.__cleanDate(start_date)
		end_date = self.__cleanDate(end_date)
		lineTable = ''
		if not table == '':
			cleanOffset = offset.replace('@', '')
			lineTable = '{' + \
				'"@type":"uco-observable:DataRangeFacet",' + \
				'"uco-observable:rangeOffset": {' + \
					'"@type":"xsd:integer", ' + \
					'"@value":"' + cleanOffset + '"' + \
				'},' +\
				'"uco-observable:rangeSize": {' + \
					'"@type":"xsd:integer", ' + \
					'"@value":"0"' + \
				'}' + \
			'}'
						
		lineTable = json.loads(lineTable)
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableRelationship",
			"uco-observable:startTime":
				{
					"@type":"xsd:dateTime",
					"@value":start_date
				},
			"uco-observable:endTime":
				{
					"@type":"xsd:dateTime",
					"@value":end_date
				},
			"uco-core:source":
				{
					"@id":source
				},
			"uco-core:target":
				{
					"@id":target
				},
			"uco-core:kindOfRelationship":relation,
			"uco-core:isDirectional":True,
			"uco-core:facets": [
				lineTable
			]	
		}
		object_str = json.dumps(object_dict, indent = 4)
		return object_str + ',\n'

	def __generateTraceRelation(self, source, target, relation, table, offset,
		start_date, end_date):
		
		start_date = self.__cleanDate(start_date)
		end_date = self.__cleanDate(end_date)

		#lineTable = ''
		# if not table == '':
		# 	cleanOffset = offset.replace('@', '')
		# 	lineTable = '{' + \
		# 		'"@type":"uco-observable:DataRangeFacet",' + \
		# 		'"uco-observable:rangeOffset": {' + \
		# 			'"@type":"xsd:integer", ' +\
		# 			'"@value":"' + cleanOffset + '"' +\
		# 		'},' +\
		# 		'"uco-observable:rangeSize": {' + \
		# 			'"@type":"xsd:integer", ' + \
		# 			'"@value":"0"' + \
		# 		'}' + \
		# 	'}'
						
		start_date = self.__convert_str_to_datetime(start_date)
		end_date = self.__convert_str_to_datetime(end_date)
		observable_relationship = uco.observable.ObservableRelationship(source, target, 
			start_time=start_date, end_time=end_date, kind_of_relationship=relation, 
			directional=True)

		self.bundle.append_to_uco_object(observable_relationship)

		return observable_relationship

	def __generateTraceRole(self, role):
		observable = uco.observable.ObservableObject()

   
		facet_role = uco.role.Role(name=role)
		observable.append_facets(facet_role)

		self.bundle.append_to_uco_object(observable)
		return observable


	def __generateThreadMessages(self, chatTraceId, chatThread, chatIdAccountList):
		
		observable = uco.observable.ObservableObject()
		facet_message_thread = uco.observable.FacetMessagethread(messages=chatThread, 
			participants=chatIdAccountList)		
		observable.append_facets(facet_message_thread)
		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceTool(self, name, type, vendor, version, confList):
		
		line = '['
		if len(confList) > 0:  
			line += '{'
			line += '"@type":"uco-tool:ConfigurationSettingType",'
			line += '"configurationSetting":['
			n = len(confList) - 1
			for i in range(n):
				listItems = []
				listItems = confList[i].split('@');
				line += '{' 
				line += '"@type":"uco-tool:ConfigurationSettingType",'
				line += '"uco-tool:itemName":"' + listItems[0] + '",'
				line += '"uco-tool:itemValue":"' + listItems[1] + '"'
				line += '},' 
 
			listItems.clear()
			listItems += confList[n].split('@')
			line += '{'
			line += '"@type":"uco-observable:ConfigurationSettingFacet",'
			line += '"uco-observable:itemName":"' + listItems[0] + '",' 
			line += '"uco-observable:itemValue":"' + listItems[1] + '"'
			line += '}'
			line += ']'
			line += '}'
			line += ']'
			line += '}]';
		else:
			line += ']';

		line = json.loads(line)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-tool:Tool", 
			"uco-core:name":name,
			"uco-tool:toolType":type,
			"uco-tool:creator":vendor,
			"uco-tool:version":version
		}
		#"uco-core:hasFacet":line

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceURL (self, URL_Value):
		
		URL_Value = self.__cleanJSONtext(URL_Value)
		
		if  URL_Value in self.UrlList.keys(): 
			observable_url = self.UrlList.get(URL_Value)
		else:
			observable_url = uco.observable.ObservableObject()
			facet_url = uco.observable.FacetUrl(url_address=URL_Value)
		
			observable_url.append_facets(facet_url)
			self.bundle.append_to_uco_object(observable_url)
			
		return observable_url


	def __generateTraceWebPages(self, WEB_PAGEid, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGElastVisited,
				WEBsource, WEBlocation, WEBrecoveryMethod):

			if WEB_PAGEurl.strip() == '':				
				return ''

			WEB_PAGElastVisited = self.__cleanDate(WEB_PAGElastVisited)

			observable_app = self.__checkAppName(WEB_PAGEsource.strip())

			observable_url = self.__generateTraceURL(WEB_PAGEurl)			
			title = self.__cleanJSONtext(WEB_PAGEtitle)

			if WEB_PAGEvisitCount.strip() == '':
				visit_count = '0' 
			else:
				visit_count = WEB_PAGEvisitCount			

			visit_count = int(visit_count)

			observable = uco.observable.ObservableObject()
			WEB_PAGElastVisited = self.__convert_str_to_datetime(WEB_PAGElastVisited)
			facet_url_history_entry = uco.observable.UrlHistoryEntry(
				last_visit=WEB_PAGElastVisited, manually_entered_count=0, 
				url=observable_url, page_title=title, visit_count=visit_count, 
				allocation_status=WEBrecoveryMethod)			
			facet_url_history = uco.observable.FacetUrlHistory(observable_app)
			observable.append_facets(facet_url_history, facet_url_history_entry)
			
			self.bundle.append_to_uco_object(observable)
			
			self.__generateChainOfEvidence(WEBsource, WEBlocation, observable)

	def __generateTraceCellTower(self, cell_id, cell_mcc, cell_mnc, cell_lac, 
		cell_cid, cell_longitude, cell_latitude, cell_timeStamp):

		cell_timeStamp = self.__cleanDate(cell_timeStamp)

		observable_location = self.__checkGeoCoordinates(cell_latitude, cell_longitude,
			 '', 'Cell Tower')
		
		if observable_location is not None:
			cell_id = cell_mcc.strip() + '@' + cell_mnc.strip() +'@' + \
				cell_lac.strip() + '@' + cell_cid.strip()			
	#---	identifier of the Cell Tower cannot be empty
	#			
			if cell_id != '@@@':
				if cell_id in self.CELL_TOWER_gsm.keys():		
					return self.CELL_TOWER_gsm.get(cell_id)
				else:
					observable = uco.observable.ObservableObject()
					facet_cell_tower = not_in_ontology.entities.FacetCellTower(mcc=cell_mcc, 
					mnc=cell_mnc, lac=cell_lac, cid=cell_cid, location=observable_location)
					observable.append_facets(facet_cell_tower)
					self.bundle.append_to_uco_object(observable)
				
					self.CELL_TOWER_gsm[cell_id] = observable
					return observable		
		return None

	def __generateTraceCookie(self, cookie_item_id, cookie_source,
				cookie_name, cookie_value, cookie_domain, cookie_creation_time, 
				cookie_last_accessed_time, cookie_expiry):

		cookie_creation_time = self.__cleanDate(cookie_creation_time)
		cookie_last_accessed_time = self.__cleanDate(cookie_last_accessed_time)		
		cookie_expiry = self.__cleanDate(cookie_expiry)
		cookie_value = cookie_value.replace('"', '')
		cookie_name = self.__cleanJSONtext(cookie_name)

		observable = uco.observable.ObservableObject()
		
		observable_source = self.__checkAppName(cookie_source)
		observable_domain = self.__checkAppName(cookie_domain)
		
		cookie_creation_time = self.__convert_str_to_datetime(cookie_creation_time)
		cookie_last_accessed_time = self.__convert_str_to_datetime(cookie_last_accessed_time)
		cookie_expiry = self.__convert_str_to_datetime(cookie_expiry)
		
		facet_cookie = uco.observable.FacetBrowserCookie(source=observable_source, 
			name=cookie_name, domain=observable_domain, 
			created_time=cookie_creation_time, last_access_time=cookie_last_accessed_time, 
			expiration_time=cookie_expiry)

		observable.append_facets(facet_cookie)
		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceLocationCoordinate(self, latitude, longitude, altitude, type):
		observable = uco.observable.ObservableObject()
		id = latitude + '@' + longitude
		self.LOCATION_lat_long_coordinate[id] = observable

		latitude_decimal = float(latitude)
		longitude_decimal = float(longitude)
		
		if altitude != '':
			altitude_decimal = float(altitude)
		else:
			altitude_decimal = 0.00 

		facet_location = uco.location.FacetLocation(latitude=latitude_decimal, 
			longitude=longitude_decimal, altitude=altitude_decimal, location_type=type)
		observable.append_facets(facet_location)
		
		self.bundle.append_to_uco_object(observable)
		return observable

		
	def __generateTraceWinTimeline(self, timeline_id, timeline_app_name,
				timeline_type, timeline_time_stamp):

		timeline_time_stamp = self.__cleanDate(timeline_time_stamp)
		if timeline_type.strip() == '':
			return None
		
		timeline_time_stamp = self.__convert_str_to_datetime(timeline_time_stamp)
		timeline_app_name = self.__cleanJSONtext(timeline_app_name)			
		event_text = self.__cleanJSONtext(timeline_app_name)
		
		observable = uco.observable.ObservableObject()		
		facet_event = uco.observable.FacetEvent(event_type=timeline_type, 
			event_text=event_text, created_time=timeline_time_stamp)
		observable.append_facets(facet_event)

		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceWirelessNet(self, wifi_id, wifi_mac_address, wifi_channel,
		wifi_longitude, wifi_latitude, wifi_timeStamp, wifi_accuracy):
		
		wifi_timeStamp = self.__cleanDate(wifi_timeStamp)
		wifi_mac_address = wifi_mac_address.strip()

		observable_location = self.__checkGeoCoordinates(wifi_latitude, wifi_longitude,
			 '', 'Wireless Network')

		if observable_location is None:
			return None

		if wifi_mac_address.strip() == "":
			return None 

		if wifi_mac_address in self.WIRELESS_NET_mac_address.keys():
			observable = self.WIRELESS_NET_mac_address[wifi_mac_address]
		else:
			observable = uco.observable.ObservableObject()
			wifi_timeStamp = self.__convert_str_to_datetime(wifi_timeStamp)
			#wnet_last_connection = self.__convert_str_to_datetime(wnet_last_connection)				
			facet_wnet_connection = uco.observable.FacetWirelessNetworkConnection(
				ssid=wifi_mac_address, location=observable_location, 
				connection_time=wifi_timeStamp)
			observable.append_facets(facet_wnet_connection)
			self.bundle.append_to_uco_object(observable)
			self.WIRELESS_NET_mac_address[wifi_mac_address] = observable
			return observable

	def writeCall(self, CALLid, CALLappName, CALLtimeStamp, CALLdirection, 
				CALLduration, CALLpartner, CALLpartnerName, CALLsource, CALLlocation, 
				CALLrecoveryMethod):
		
		callOutcome = ''
		
		for i, call_id in enumerate(CALLid):
			if CALLdirection[i].lower() == 'incoming':
					phoneTO = self.phoneOwnerNumber
					phoneFROM = CALLpartner[i]
			else:
				phoneTO = CALLpartner[i]
				phoneFROM = self.phoneOwnerNumber

			phonePattern = '\+?[0-9]+'	# phone number pattern
			resPattern = re.match(phonePattern, CALLpartner[i])
			
			if (resPattern):
				if CALLpartner[i] in self.phoneNumberList:
					idx = self.phoneNumberList.index(CALLpartner[i])
					uuidPartner = self.phoneUuidList[idx]
				else:	
					mobileOperator = ""
					self.phoneNumberList.append(CALLpartner[i])
					self.phoneNameList.append(CALLpartnerName[i])
					uuidPartner = self.generateTracePhoneAccount(mobileOperator, 
						CALLpartnerName[i], CALLpartner[i])
					self.phoneUuidList.append(uuidPartner)			
			else:
				if CALLappName[i].strip() in self.appNameList: 
					idx = self.appNameList.index(CALLappName[i].strip())
					idAppName = self.appNameList[idx]
					idAppIdentity = self.appIDList[idx]
				else:
					idAppIdentity = self.__generateTraceAppName(CALLappName[i].strip())
					self.appNameList.append(CALLappName[i].strip())
					self.appIDList.append(idAppIdentity)

				if CALLpartner[i].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(CALLpartner[i].strip())
					uuidPartner = self.CHATaccountIdList[idx]
				else:
					self.CHATparticipantsNameList.append(CALLpartner[i].strip())
					uuidPartner = self.__generateTraceApplicationAccount(CALLpartner[i].strip(), 
						CALLpartner[i].strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(CALLpartner[i].strip())
					self.CHATaccountIdList.append(uuidPartner)						

			if CALLdirection[i].lower() == 'incoming':
				uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
					CALLtimeStamp[i], uuidPartner, self.observable_phone_owner, 
					CALLduration[i], CALLrecoveryMethod[i], callOutcome)
			else:
				uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
					CALLtimeStamp[i], self.observable_phone_owner, uuidPartner, 
					CALLduration[i], CALLrecoveryMethod[i], callOutcome)
			
			self.__generateChainOfEvidence(CALLsource[i], CALLlocation[i], uuid)		

	def ObservableRelationship(self, CONTACTname, CONTACTphoneNum,
				CONTACTsource, CONTACTlocation, CONTACTrecoveryMethod):
		
		for i, contact_name in enumerate(CONTACTname):
			if CONTACTphoneNum[i] == '':
				continue
			else:
				#phoneNum = CONTACTphoneNum[i].replace('+', '00')
				phoneNum = CONTACTphoneNum[i].replace(' ', '')
				if phoneNum not in self.phoneNumberList:					
					self.phoneNumberList.append(phoneNum)
					self.phoneNameList.append(contact_name)
					mobileOperator = ""
					uuid = self.generateTracePhoneAccount(mobileOperator, contact_name, phoneNum)
					self.phoneUuidList.append(uuid)

	def writeHeader(self):
		if self.bundle is None:			
			uuid = AXIOMtoJSON.__createUUID()
			uuid_identifier = 'bundle-' + uuid  
			self.bundle = uco.core.Bundle(description="Extraction from XML report generated by MAGNET AXIOM PROCESS",
				spec_version="CASE 0.4 - UCO 0.6", case_identifier=uuid_identifier)

	def writeLastLine(self):
#---	Save a reference to the original standard output			
		original_stdout = sys.stdout 
#--	Change the standard output to the file we created.    		
		sys.stdout = self.FileOut 
				
		print(self.bundle)

#--	Restore the standard output to its default value
		sys.stdout = original_stdout 

	def writePhoneOwner(self, phoneOwnerNumber, phoneOwnerName):
		self.phoneOwnerNumber = phoneOwnerNumber
		mobileOperator = ""
		self.observable_phone_owner = self.__generateTracePhoneOwner(mobileOperator, phoneOwnerName, 
				phoneOwnerNumber)


	def writeFiles(self, FILEid, FILEtag, FILEname, FILElocalPath, FILEimage,
					FILEsize, FILEcreated, FILEmodified, FILEaccessed, FILEmd5,
					FILEexifMake, FILEexifModel, FILEexifLatitudeRef, FILEexifLatitude, 
					FILEexifLongitudeRef, FILEexifLongitude, FILEexifAltitude,
					FILEsource, FILElocation, FILErecoveryMethod):
			
			for i, file_id in enumerate(FILEid):
				if FILEname[i] == '':
					FILEname[i] = FILEimage[i]
				
				if FILEname[i].find('Binary data') > -1:
					pass
				else:
					fileExt = FILEname[i][FILEname[i].rfind('.') + 1:]

					file_observable = self.__generateTraceFile(FILEname[i], FILEsize[i], 
						'MD5', FILEmd5[i],	FILEtag[i], FILEcreated[i], FILEmodified[i], 
						FILEaccessed[i], FILElocalPath[i], fileExt,
						FILEexifMake[i], FILEexifModel[i], FILEexifLatitudeRef[i], 
						FILEexifLatitude[i], FILEexifLongitudeRef[i], 
						FILEexifLongitude[i], FILEexifAltitude[i])

					self.FILEuuid[file_id] = file_observable

	def writeChat(self, CHATid, CHATsender, CHATreceiver, CHATdateTimeSent, 
							CHATdateTimeReceived, CHATmessage, CHATmessageStatus, 
							CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod):		
		
		CHATthreadParticipants = []
		self.fillChatThread(CHATthreadParticipants, CHATid, CHATsender, CHATreceiver,
				CHATdateTimeSent, CHATdateTimeReceived, CHATmessage, CHATmessageStatus,
				CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod, 
				self.phoneOwnerNumber)			

		for i, chat_id in enumerate(self.CHATids):
#---	CHATidAccountList contains the list of the Mesages uuid of CHATs
#		CHATthread contains the values for the generation of the ChatThreadFacet Observable	
#											
			self.CHATthread = []	
			self.chatIdAccountList = []			
			for j, chat_id_item in enumerate(chat_id):
				if self.CHATapplications[i][j].strip().lower() in self.appNameList: 
					idx = self.appNameList.index(self.CHATapplications[i][j].strip().lower())
					idAppName = self.appNameList[idx]
					idAppIdentity = self.appIDList[idx]
				else:
					idAppIdentity = self.__generateTraceAppName(self.CHATapplications[i][j].strip().lower())
					self.appNameList.append(self.CHATapplications[i][j].strip().lower())
					self.appIDList.append(idAppIdentity)
				
				if self.CHATsenders[i][j].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(self.CHATsenders[i][j].strip())
					CHATmsgFrom = self.CHATaccountIdList[idx]
				else:
					CHATname = ''
					self.CHATparticipantsNameList.append(CHATname)
					CHATmsgFrom = self.__generateTraceApplicationAccount(
						CHATname, self.CHATsenders[i][j].strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(self.CHATsenders[i][j].strip())
					self.CHATaccountIdList.append(CHATmsgFrom)

				if self.CHATreceivers[i][j].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(self.CHATreceivers[i][j].strip())
					CHATmsgTo = self.CHATaccountIdList[idx]
				else:
					CHATname = ''
					self.CHATparticipantsNameList.append(CHATname)
					CHATmsgTo = self.__generateTraceApplicationAccount(
						CHATname, self.CHATreceivers[i][j].strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(self.CHATreceivers[i][j].strip())
					self.CHATaccountIdList.append(CHATmsgTo)
				

#---	if Identifiers TO is empty, the array CHATpartyIdentifiers must
#		be iterated to find the right Party
#								
				if self.CHATmessageStatuses[i][j].lower().find('received') > - 1:
					CHATdirection = 'Incoming'
					CHATdate = self.__cleanDate(self.CHATdateTimeReceiveds[i][j])
				else:			
					CHATdirection = 'Outgoing'
					CHATdate = self.__cleanDate(self.CHATdateTimeSents[i][j])
								
				CHATattachmentFileNames = ''
				CHATattachmentUrls = ''
				CHATmsgToList = []
				CHATmsgToList.append(CHATmsgTo)
				observable_chat = self.__generateTraceChat(self.CHATmessages[i][j], idAppIdentity, 
					CHATdate, CHATmsgFrom, CHATmsgToList, self.CHATrecoveryMethods[i][j], 
					self.CHATmessageStatuses[i][j], CHATdirection, "CHAT Message",
					CHATattachmentFileNames, CHATattachmentUrls)
				self.CHATthread.append(observable_chat)

#---	if there are not messages for this Chat or no ChatAccount has been
# 		generated, the ThreadMessage is not generated. Moreover the Chain of
# 		evidence is built upon the ThreadUuid
#				
			if (len(self.CHATthread) != 0):
				observable_thread = self.__generateThreadMessages(self.CHATids[i][j], self.CHATthread, 
								[CHATmsgFrom, CHATmsgTo])
				self.__generateChainOfEvidence(CHATsource[i], CHATlocation[i], 
					observable_thread)

	def writeDeviceEvent(self, EVENT_LOCK_id, EVENT_LOCK_status, 
                EVENT_LOCK_dateTime, EVENT_LOCK_source, EVENT_LOCK_location, 
                EVENT_LOCK_recoveryMethod):
		for i, device_event_id in enumerate(EVENT_LOCK_id):
			observable_event = self.__generateTraceDeviceEvent(device_event_id, 
				EVENT_LOCK_dateTime[i], 'Device Lock Status', EVENT_LOCK_status[i])
			if observable_event is not None:
				self.__generateChainOfEvidence(EVENT_LOCK_source[i], 
					EVENT_LOCK_location[i], observable_event)

	def writeAppUsage(self, EVENT_APP_USE_id, EVENT_APP_USE_application, 
                EVENT_APP_USE_start_time, EVENT_APP_USE_end_time,
                EVENT_APP_USE_source, EVENT_APP_USE_location, 
                EVENT_APP_USE_recoveryMethod):

		for i, application in enumerate(EVENT_APP_USE_application):
			observable_app_usage= self.__generateTraceAppUsage(EVENT_APP_USE_id[i], 
				EVENT_APP_USE_start_time[i], EVENT_APP_USE_end_time[i],
				'Application Usage', application)
			if observable_app_usage is not None:
				self.__generateChainOfEvidence(EVENT_APP_USE_source[i], 
					EVENT_APP_USE_location[i], observable_app_usage)


	def writeEmail(self, EMAILid, EMAILapp, EMAILidentifierFROM, 
				EMAILidentifiersTO, EMAILidentifiersCC, EMAILidentifiersBCC, 
				EMAILbody, EMAILsubject, EMAILtimeStamp, EMAILattachmentsFilename,
				EMAILsource, EMAILlocation, EMAILrecoveryMethod):
				
		for i, email_id in enumerate(EMAILid):			
			self.__generateTraceEmail(email_id, EMAILrecoveryMethod[i], EMAILsource[i],
				EMAILlocation[i], EMAILidentifierFROM[i], EMAILidentifiersTO[i], 
				EMAILidentifiersCC[i], EMAILidentifiersBCC[i], EMAILbody[i], 
				EMAILsubject[i], EMAILtimeStamp[i], EMAILattachmentsFilename[i])

	def writeDeviceDisk(self,FILE_SYS_INFOvolumeSn, FILE_SYS_INFOfileSystem, 
		FILE_SYS_INFOcapacity, FILE_SYS_INFOunallocated, FILE_SYS_INFOallocated,
        FILE_SYS_INFOoffset):

		DEVICEcapacity = 0
		for i, capacity in enumerate(FILE_SYS_INFOcapacity):
			if capacity != '':
				DEVICEcapacity += int(capacity)

		partitions_ref = []
		for i, s_n in enumerate(FILE_SYS_INFOvolumeSn):
			if FILE_SYS_INFOcapacity[i] != '':
				object_partition =  self.__generateTraceDiskPartition(s_n, 
					FILE_SYS_INFOfileSystem[i], FILE_SYS_INFOcapacity[i],
					FILE_SYS_INFOunallocated[i], FILE_SYS_INFOallocated[i],
					FILE_SYS_INFOoffset[i])
				partitions_ref.append(object_partition)

		if partitions_ref:
			self.observable_device =  self.__generateTraceDeviceDisk(DEVICEcapacity, partitions_ref)

	def writeDeviceMobile(self, DEVICEid, DEVICEimsi, DEVICEbluetoothAddress, 
		DEVICEbluetoothName, DEVICEimei, DEVICEserialNumber, DEVICEname, 
		DEVICEmodel, DEVICEiccid, DEVICEosVersion):
	
		self.observable_device =  self.__generateTraceDeviceMobile(DEVICEid, DEVICEimsi, 
			DEVICEbluetoothAddress, DEVICEbluetoothName, DEVICEimei, DEVICEserialNumber, 
			DEVICEname, DEVICEmodel, DEVICEiccid, DEVICEosVersion)

	def writeWebPages(self, WEB_PAGEid, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited, 
				WEBsource, WEBlocation, WEBrecoveryMethod):

		str_coe = ''
		for i in range(len(WEB_PAGEid) - 1):
			self.__generateTraceWebPages(WEB_PAGEid[i], WEB_PAGEsource[i], WEB_PAGEurl[i], 
					WEB_PAGEtitle[i], WEB_PAGEvisitCount[i],  WEB_PAGlastVisited[i],
					WEBsource[i], WEBlocation[i], WEBrecoveryMethod[i])		
		
#--- last char is space not comma when i == len(WEB_PAGEid)
#			
		if len(WEB_PAGEid) > 0:
			self.__generateTraceWebPages(WEB_PAGEid[i], WEB_PAGEsource[i], WEB_PAGEurl[i], 
					WEB_PAGEtitle[i], WEB_PAGEvisitCount[i],  WEB_PAGlastVisited[i],
					WEBsource[i], WEBlocation[i], WEBrecoveryMethod[i])
			self.FileOut.write(str_coe[0:-2])
	
	def writeCell_Tower(self, CELL_TOWERid, CELL_TOWERmcc,
                CELL_TOWERmnc, CELL_TOWERlac, CELL_TOWERcid, 
                CELL_TOWERlongitude, CELL_TOWERlatitude,
                CELL_TOWERtimeStamp,  CELL_TOWERsource, 
                CELL_TOWERlocation, CELL_TOWERrecoveryMethod):

		for i, cell_tower_id in enumerate(CELL_TOWERid):			
			observable_cell_tower = self.__generateTraceCellTower(cell_tower_id, CELL_TOWERmcc[i],
				CELL_TOWERmnc[i], CELL_TOWERlac[i],CELL_TOWERcid[i], 
                CELL_TOWERlongitude[i], CELL_TOWERlatitude[i], CELL_TOWERtimeStamp[i])
			
			if observable_cell_tower is not None:
				self.__generateTraceRelation(self.observable_phone_owner, 
					observable_cell_tower, 'Located_At', '', '', CELL_TOWERtimeStamp[i], '')
				self.__generateChainOfEvidence(CELL_TOWERsource[i], 
					CELL_TOWERlocation[i], observable_cell_tower)		

	def writeCookie(self, COOKIEid, COOKIEappSource, COOKIEname, COOKIEpath, COOKIEdomain, 
				COOKIEcreatedDate, COOKIEaccessedDate, COOKIEexpirationDate, 
                COOKIEsource, COOKIElocation, COOKIErecoveryMethod):

		for i, cookie_item_id in enumerate(COOKIEid):			
			observable_cookie = self.__generateTraceCookie(cookie_item_id, COOKIEappSource[i],
				COOKIEname[i], COOKIEpath[i], COOKIEdomain[i], COOKIEcreatedDate[i], 
				COOKIEaccessedDate[i], COOKIEexpirationDate[i])
			
			if observable_cookie is not None:
				self.__generateChainOfEvidence(COOKIEsource[i], COOKIElocation[i], 
					observable_cookie)

	def writeWinTimeline(self, WIN_TIMELINEid, WIN_TIMELINEappName, WIN_TIMELINEactivityType, 
				WIN_TIMELINEtimeStamp, WIN_TIMELINEsource, WIN_TIMELINElocation, 
                WIN_TIMELINErecoveryMethod):

		for i, timeline_item_id in enumerate(WIN_TIMELINEid):			
			observable_win_timeline = self.__generateTraceWinTimeline(timeline_item_id, WIN_TIMELINEappName[i],
				WIN_TIMELINEactivityType[i], WIN_TIMELINEtimeStamp[i])
			
			if observable_win_timeline is not None:
				self.__generateChainOfEvidence(WIN_TIMELINEsource[i], 
					WIN_TIMELINElocation[i], observable_win_timeline)

	def writeLocationDevice(self, LOCATIONid, LOCATIONtype, LOCATIONlatitude,  
		LOCATIONlongitude, LOCATIONcreated, LOCATIONsource, LOCATIONlocation):

		str_coe = ''
		for i, location_id in enumerate(LOCATIONid):
			observable_location= self.__generateTraceLocationDevice(location_id, LOCATIONlongitude[i], 
				LOCATIONlatitude[i], 'Significant Location')
			
			if observable_location is not None:
				self.__generateTraceRelation(self.observable_device, observable_location, 
					'Mapped_By', '', '', LOCATIONcreated[i], '')
				self.__generateChainOfEvidence(LOCATIONsource[i], 
					LOCATIONlocation[i], observable_location)		

	def writeSearched_Item(self, SEARCHED_ITEMid, SEARCHED_ITEMvalue, SEARCHED_ITEMtimeStamp, 
				SEARCHED_ITEMappSource, SEARCHED_ITEMsource, SEARCHED_ITEMlocation, 
                SEARCHED_ITEMrecoveryMethod):

		for i, searched_item_id in enumerate(SEARCHED_ITEMid):			
			observable_searched = self.__generateTraceSearchedItem(searched_item_id, SEARCHED_ITEMvalue[i],
				SEARCHED_ITEMtimeStamp[i], SEARCHED_ITEMappSource[i])
			
			if observable_searched is not None:
				self.__generateChainOfEvidence(SEARCHED_ITEMsource[i], 
					SEARCHED_ITEMlocation[i], observable_searched)
		
	def writeSms(self, SMSid, SMSsender, SMSrecipient, SMSreceivedDateTime,
					SMSsentDateTime, SMSmessage, SMSdirection, SMSsource,
					SMSlocation, SMSrecoveryMethod):

		for i, sms_id in enumerate(SMSid):
			phoneUuidTo = ''
			phoneUuidFrom = ''
			SMSsenderClean = SMSsender[i].strip()
			if SMSsenderClean.lower() == 'local user':
				SMSsenderClean = self.phoneOwnerNumber

#---	get rid of hex chars byte not accepted in JSON values
#			
			if SMSsenderClean in self.phoneNumberList:						
				idx = self.phoneNumberList.index(SMSsenderClean)						
				userId = self.phoneNumberList[idx]
				phoneParticipantUuid = self.phoneUuidList[idx]
			else:
				senderName = ''
				self.phoneNumberList.append(SMSsenderClean)
				self.phoneNameList.append(senderName)
				mobileOperator = ""		
				SMSsenderClean = self.__cleanJSONtext(SMSsenderClean)
				phoneParticipantUuid = self.generateTracePhoneAccount(mobileOperator, 
					senderName, SMSsenderClean)	
				self.phoneUuidList.append(phoneParticipantUuid)

			SMSrecipientClean = SMSrecipient[i].strip()
			if SMSrecipientClean.lower() == 'local user':
				SMSrecipientClean = self.phoneOwnerNumber

			if SMSrecipientClean in self.phoneNumberList:						
				idx = self.phoneNumberList.index(SMSrecipientClean)						
				userId = self.phoneNumberList[idx]
				phoneRecipientUuid = self.phoneUuidList[idx]
			else:
				recipientName = ''
				self.phoneNumberList.append(SMSrecipientClean)
				self.phoneNameList.append(recipientName)
				mobileOperator = ""
				SMSrecipientClean = self.__cleanJSONtext(SMSrecipientClean)
				phoneRecipientUuid = self.generateTracePhoneAccount(mobileOperator, 
					recipientName, SMSrecipientClean)	
				self.phoneUuidList.append(phoneRecipientUuid)


			body = self.__cleanJSONtext(SMSmessage[i])

						
			if SMSreceivedDateTime[i] == '':
				phoneUuidFrom = phoneParticipantUuid
				phoneUuidTo = phoneRecipientUuid
				SMSdate = SMSsentDateTime[i]
				direction = "Outgoing"
			else:
				phoneUuidFrom = phoneRecipientUuid
				phoneUuidTo = phoneParticipantUuid
				SMSdate = SMSreceivedDateTime[i]
				direction = "Incoming"

			
			SMSdate = self.__cleanDate(SMSdate)
			observable_app = self.__checkAppName("Native")
			SMSphoneListTo = []
			SMSphoneListTo.append(phoneUuidTo)
			observable_message = self.__generateTraceChat(SMSmessage[i], observable_app, 
				SMSdate, phoneUuidFrom, SMSphoneListTo, SMSrecoveryMethod[i], 
				"outcome not available", direction, "SMS/Native Message", "", "")

			if observable_message is not None:
				self.__generateChainOfEvidence(SMSsource[i], SMSlocation[i], 
					observable_message)

	def writeWireless_Net(self, WIRELESS_NETid, WIRELESS_NETmacAddress,
                WIRELESS_NETchannel, WIRELESS_NETlongitude, WIRELESS_NETlatitude,
                WIRELESS_NETtimeStamp,  WIRELESS_NETaccuracy, WIRELESS_NETsource, 
                WIRELESS_NETlocation, WIRELESS_NETrecoveryMethod):

		for i, wifi_id in enumerate(WIRELESS_NETid):			
			observable_wi_net = self.__generateTraceWirelessNet(wifi_id, WIRELESS_NETmacAddress[i],
				WIRELESS_NETchannel[i], WIRELESS_NETlongitude[i], WIRELESS_NETlatitude[i], 
				WIRELESS_NETtimeStamp[i], WIRELESS_NETaccuracy[i])
			
			if observable_wi_net is not None:
				self.__generateTraceRelation(self.observable_phone_owner, observable_wi_net, 
					'Connected_To', '', '', WIRELESS_NETtimeStamp[i], '')
				self.__generateChainOfEvidence(WIRELESS_NETsource[i], 
					WIRELESS_NETlocation[i], observable_wi_net)

	def writeContextAxiom(self, axiomVersionText, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText,
		deviceBluetoothAddressText, deviceIdText, deviceModelText, 
		deviceOsTypeText, deviceOsVersionText, deviceVendorText, 
		deviceMacAddressText, deviceIccidText, deviceImsiText, 
		deviceImeiText, imagePath, imageSize, 
		imageMetadataHashSHA, imageMetadataHashMD5):

		self.___generateContextAxiom(ufedVersionText, deviceExtractionStartTime, 
			deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText, 
			deviceBluetoothAddressText, deviceIdText, devicePhoneModelText, 
			deviceOsTypeText, deviceOsVersionText, devicePhoneVendorText, 
			deviceMacAddressText, deviceIccidText, deviceImsiText, 
			deviceImeiText, imagePath, imageSize, 
			imageMetadataHashSHA, imageMetadataHashMD5)


