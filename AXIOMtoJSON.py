#---	class AXIOMtoJSON.py

import uuid
import os
import re

class AXIOMtoJSON:
	'''
	Represents all attributes and methods to represent Traces in CASE ontology, starting from data
	extracted from XML reports generated by UFED-PA forensic tool
	'''
	C_TAB = '\t'
# default value for string value not provided
#
	C_NP = ''				

# default value for integer value not provided
#
	C_INT = '0'	

# default value for date value not provided
#
	C_DATE = '1900-01-01T08:00:00'

# default value for Hash Method value not provided
#
	C_HASH_M = 'MD5'

# default value for Hash Method value not provided
#
	C_HASH_V = '1' * 76

# default value for the property referrerUrl of the URLHistoryFacet class
#
	C_REF_URL = 'http:www.empty.com/referrer_url'

# default value for the location where a forensic action was carried out
#
	C_LOCATION = 'Unknown location'

	def __init__(self, fileOut, commaLine):
	# to be defined
		self.FileOut = fileOut
		self.commaLine = commaLine
		self.phoneNumberList = []
		self.phoneNameList = []
		self.phoneUuidList = []
		
		self.appNameList = []
		self.appAccountUsernameList = []
		self.appAccountNameList = []
		self.appIDList = []

		self.CHATparticipantsNameList = []
		self.CHATparticipantsIdList = []
		self.CHATaccountIdList = []
		self.CHATthread = []

		self.EMAILaccountIdList = []
		self.EMAILaddressList = []
		self.phoneOwnerNumber = ''
		self.phoneOwnerUuid = ''
		self.FILEuuid = {}
		self.FILEid = []

		self.EXTRA_INFOdictPath = {}
		self.EXTRA_INFOdictSize = {}
		self.EXTRA_INFOdictTableName = {}
		self.EXTRA_INFOdictOffset = {}
		self.EXTRA_INFOdictNodeInfoId = {}

		self.CHATids = []
		self.CHATsenders = []
		self.CHATreceivers = []
		self.CHATdateTimeSents = []
		self.CHATdateTimeReceiveds = []
		self.CHATmessages = []
		self.CHATmessageStatuses = []
		self.CHATsources = []
		self.CHATlocations = []
		self.CHATrecoveryMethods = []
		self.CHATapplications = []

		self.UrlList = []
		self.UrlIDList = []

		self.LocationList = []
		self.LocationIDList = []


		
	# static methods do not receive class or instance arguments
	# and usually operate on data that is not instance or class-specific
	@staticmethod
	def __createUUID():
		'''	
		Traces in CASE have a unique identification number, based on Globally Unique Identifier.  
		Each time a Trace is generated this static method in invoked, it doen't depends on any object
		'''
		return str(uuid.uuid4())

	def __cleanString(self, str):
		newStr = str.replace('"', "'")

#--- �=REPLACEMENT CHARACTER, sequence Hex UTF-8 bytes:	EF BF BD
#		
		newStr = newStr.replace('�', '')
		newStr = newStr.replace(chr(10), ' ')
		newStr = newStr.replace(chr(9), ' ')
		newStr = newStr.replace('\\', "/")
		return newStr

	def fillArrayWithEmpty(self, aInput, max):
		if len(aInput) < max:
			for i in range(len(aInput), max):						
				aInput.append('')

	def fillChatThread(self, chatThread, CHATid, CHATsender, CHATreceiver,
		CHATdateTimeSent, CHATdateTimeReceived, CHATmessage, CHATmessageStatus,
		CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod, CALLphoneNumber):

		for i, chat_sender in enumerate(CHATsender):
			if chat_sender.lower().find('local user') > -1:
				chat_sender = CALLphoneNumber

			if CHATreceiver[i].lower().find('local user') > -1:
				CHATreceiver[i] = CALLphoneNumber
			
			chatFound = False
			idx = -1
			for j, chat_thread in enumerate(chatThread):
				if (chat_sender in chat_thread and
					  CHATreceiver[i] in chat_thread and 
					  CHATapplication[i] in chat_thread):
					idx = j
					chatFound = True
					break
			
			if chatFound:		
				self.CHATids[idx].append(CHATid[i])
				self.CHATsenders[idx].append(chat_sender)
				self.CHATreceivers[idx].append(CHATreceiver[i])
				self.CHATdateTimeSents[idx].append(CHATdateTimeSent[i])
				self.CHATdateTimeReceiveds[idx].append(CHATdateTimeReceived[i])
				self.CHATmessages[idx].append(CHATmessage[i])
				self.CHATmessageStatuses[idx].append(CHATmessageStatus[i])
				self.CHATsources[idx].append(CHATsource[i])
				self.CHATlocations[idx].append(CHATlocation[i])
				self.CHATrecoveryMethods[idx].append(CHATrecoveryMethod[i])
				self.CHATapplications[idx].append(CHATapplication[i])
			else:
				idx = len(chatThread) - 1
				self.CHATids.append([CHATid[i]])
				self.CHATsenders.append([chat_sender])
				self.CHATreceivers.append([CHATreceiver[i]])
				self.CHATdateTimeSents.append([CHATdateTimeSent[i]])
				self.CHATdateTimeReceiveds.append([CHATdateTimeReceived[i]])
				self.CHATmessages.append([CHATmessage[i]])
				self.CHATmessageStatuses.append([CHATmessageStatus[i]])
				self.CHATsources.append([CHATsource[i]])
				self.CHATlocations.append([CHATlocation[i]])
				self.CHATrecoveryMethods.append([CHATrecoveryMethod[i]])
				self.CHATapplications.append([CHATapplication[i]])
				chatThread.append(chat_sender + '#' + CHATreceiver[i] + '#' + CHATapplication[i])

	def __cleanDate(self, initialDate):
		aMonths = {
			'Jan': '01',
			'Feb': '02',
			'Mar': '03',
			'Apr': '04',
			'May': '05',
			'Jun': '06',
			'Jul': '07',
			'Aug': '08',
			'Sep': '09',
			'Oct': '10',
			'Nov': '11',
			'Dec': '12'
		}
		
		initialDate = initialDate.strip()

		if 	initialDate == '':
			return AXIOMtoJSON.C_DATE

#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx)
#		the character "/" is not allowed
#		
		#print(f'*DEBUG* before replacing, dateTime: {initialDate}')
		initialDate = initialDate.replace("/", "-")
		initialDate = initialDate.replace(' ', 'T', 1)
		initialDate = initialDate.replace('UTC', '')						
		initialDate = initialDate.replace('AM', '')
		initialDate = initialDate.replace('PM', '')
		startTZ = initialDate.find("+")
		if startTZ > -1:
			initialDate = initialDate[:startTZ]		
		
		for k,v in aMonths.items():
			if initialDate.find(k) > -1:
				initialDate = initialDate.replace(k, v)
				break
		
		firstChars = initialDate[:10]
		firstChars = firstChars.replace(".", "-")
		initialDate = firstChars + initialDate[10:]

		yearPattern = '\-[0-9][0-9]T'	# year with two digits
		resPattern = re.search(yearPattern, initialDate)
		if resPattern:
			if re.search('^[0-9]{4}', initialDate):
				pass
			else:
				initialDate = re.sub('-([0-9][0-9])T', '-20\g<1>T', initialDate)
				initialDate = str(initialDate[6:10]) + initialDate[2:6] + initialDate[0:2] + \
					initialDate[10:] 

		yearPattern = '\-\d{4}T'	# year with 4 digits in Italian format
		resPattern = re.search(yearPattern, initialDate)
		if resPattern:
			initialDate = str(initialDate[6:10]) + initialDate[2:6] + initialDate[0:2] + \
				initialDate[10:] 		

		if re.search('(\d{2}:\d{2}:\d{2})$', initialDate):
			pass
		else:
			initialDate = re.sub('(\d{2}:\d{2})$', '\g<1>:00', initialDate)

		if re.search('T(\d):', initialDate):
			initialDate = re.sub('T(\d):', 'T0\g<1>:', initialDate)

		if re.search(':(\d):', initialDate):
			initialDate = re.sub(':(\d):', ':0\g<1>:', initialDate)

		if re.search(':(\d)$', initialDate):
			initialDate = re.sub(':(\d)$', ':0\g<1>', initialDate)

		if re.search('T\d{2}:\d{2}:\d{2}(.+)$', initialDate):
			initialDate = re.sub('(T\d{2}:\d{2}:\d{2})(.+)$', '\g<1>', initialDate)
			

		#print(f'*DEBUG* after replacing, dateTime: {initialDate}')
		


		return initialDate.strip()


	def ___generateContextAxiom(self, ufedVersion, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerName, 
		deviceBluetoothAddress, deviceId, devicePhoneModel, 
		deviceOsType, deviceOsVersion, devicePhoneVendor, 
		deviceMacAddress, deviceIccid, deviceImsi, deviceImei, 
		imagePath, imageSize, imageMetadataHashSHA, imageMetadataHashMD5):

		# generate Trace/Tool for the Acquisition and Extraction Actions
		idTool = self.__generateTraceTool('AXIOM Process', 'Acquisition', 
			'MAGNET', ufedVersion, []);
		
		# generate Trace/Identity for the Performer, D.F. Expert, of the Actions
		idIdentity = self.__generateTraceIdentity(examinerName, '', '')
		
		# generate Trace/Role for the Performer, D.F. Expert, of the Actions
		idRole = self.__generateTraceRole('Digital Forensic Expert')
		
		# generate Trace/Relation between the above Role and the Identity traces
		self.__generateTraceRelation(idIdentity, idRole, 'has_role', '', '');

		# generate Trace/Device for the mobile phone
		idDevice = self.generateTraceDevice(deviceMacAddress, deviceId, devicePhoneModel,
			deviceOsType, deviceOsVersion, devicePhoneVendor, '',
			deviceIccid, deviceImsi, deviceImei, deviceBluetoothAddress)
		
		# generate Trace/Provenance_Record for the mobile device
		idDeviceList = []
		idDeviceList.append(idDevice)
		idProvenanceDevice = self.__generateTraceProvencance(idDeviceList, 'Mobile device', 
			'', deviceAcquisitionStartTime) 
		
		# generate Trace/File for each file extracted by the Acuisition action
		# idFileList contains the uuid of these files and it is used for
		# creating the Provenance_Record of the Result/Output of the Acquisition 
		# action
		idFilesAcquisition = []
		for i, image_path in enumerate(imagePath):
			if imageMetadataHashSHA[i].strip() == '':
				idFileAcquisition = self.__generateTraceFile(image_path, 
				imageSize[i], 'MD5', imageMetadataHashMD5[i], '', 
				'', '', '', '', '', '', '', '', '', '', '', '')  				 				
			else:
				idFileAcquisition = self.__generateTraceFile(image_path, 
				imageSize[i], 'SHA256', imageMetadataHashSHA[i], '', 
				'', '', '', '', '', '', '', '', '', '', '', '') 				
			
			idFilesAcquisition.append(idFileAcquisition)  	
		

		idProvenanceAcquisitionFiles = \
			self.__generateTraceProvencance(idFilesAcquisition, 
				'Acquisition files', '', deviceAcquisitionStartTime)

		idProvenanceAcquisitionFilesList = []
		idProvenanceAcquisitionFilesList.append(idProvenanceAcquisitionFiles)

		idProvencanceAcquisitionAction = \
		self.__generateTraceInvestigativeAction('acquisition', 
			'Forensic mobile device acquisition', deviceAcquisitionStartTime, 
			deviceAcquisitionEndTime, idTool, '', 
			idIdentity, idProvenanceDevice, idProvenanceAcquisitionFilesList, ',');

		idFilesExtraction = []
		for uuidFile in self.FILEuuid.values(): 
			idFilesExtraction.append(uuidFile)

		idProvenanceExtractionFiles = \
		self.__generateTraceProvencance(idFilesExtraction, 'Extraction',
			'', deviceExtractionStartTime)

		idProvenanceExtractionFilesList = []
		idProvenanceExtractionFilesList.append(idProvenanceExtractionFiles)
		self.__generateTraceInvestigativeAction('extraction', 
			'Forensic mobile device extraction', deviceExtractionStartTime,
			'', idTool, '', idIdentity,
			idProvenanceAcquisitionFiles, idProvenanceExtractionFilesList, '');

	def __generateChainOfEvidence(self, source, location, uuidTrace):
		filePath = ''

		charSeparator = '/'
		separator = source.find(charSeparator)
		if separator > - 1:
			filePath = source[separator:]
		else:
			charSeparator = '\\'
			separator = source.find(charSeparator)
			if separator > - 1: 
				filePath = source[separator:]
			else:
				filePath = source
				fileName = source
				fileExt = ''
			

		if separator > - 1:
			fileName = filePath.split(charSeparator)[-1]
			fileExt = fileName[fileName.rfind('.') + 1:]

		openPar = source.find('(')
		closePar = source.find(')')
		fileSysType = source[openPar + 1: closePar]
		
		filePath = self.__cleanString(filePath)
		location = self.__cleanString(location)

		uuidFile = self.__generateTraceFileCoE(filePath, fileName, fileExt, fileSysType,
			location)

		self.FILEuuid[uuidTrace] = uuidFile
		self.__generateTraceRelation(uuidTrace, uuidFile, 'Contained_Within', 
				location, '00001');

	def __generateLastLine(self):
		line = AXIOMtoJSON.C_TAB + '] \n }'
		self.FileOut.write(line)

	def __generateTraceAppAccount(self, source, name, identifier, idApp, idIdentity):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()


		name = self.__cleanString(name)
		identifier = self.__cleanString(identifier)

		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[ \n', \
			AXIOMtoJSON.C_TAB*2 + '{ \n', \
			AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:AccountFacet", \n', \
		# CASE 0.4 indicates a id reference to an Object that contains only the name of the App!
		#line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:accountIssuer":"' + idIdentity + '", \n'
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:accountIdentifier":"' + identifier + '", \n' , \
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:isActive":true \n', \
			AXIOMtoJSON.C_TAB*2 + '}, \n', \
			AXIOMtoJSON.C_TAB*2 + '{ \n', \
			AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:ApplicationAccountFacet", \n' , \
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:application":\n', \
			AXIOMtoJSON.C_TAB*4 + '{\n', \
			AXIOMtoJSON.C_TAB*5 + '"@id":"' + idApp + '"\n', \
			AXIOMtoJSON.C_TAB*4 + '}\n', \
			AXIOMtoJSON.C_TAB*2 + '},\n', \
			AXIOMtoJSON.C_TAB*2 + '{ \n', \
			AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:DigitalAccountFacet", \n', \
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:displayName":"' + name + '"\n', \
			AXIOMtoJSON.C_TAB*2 + '}\n', \
			AXIOMtoJSON.C_TAB + ']\n', \
			'}, \n'])
		self.FileOut.write(line);
		return uuid
	
	def __generateTraceAppName(self, appName):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
		# aligned wit CASE version 0.4
		#line += AXIOMtoJSON.C_TAB + '"uco-core:name":"' + appName + '",\n'
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[ \n', \
			AXIOMtoJSON.C_TAB*2 + '{ \n', \
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:ApplicationFacet", \n', \
#	CASE 0.2/UCO 0.4 compliant, no uco-observable:out property in Observable
#		
		#line += AXIOMtoJSON.C_TAB*2 + '"uco-core:proposed:appName": "' + appName + '"\n'
			AXIOMtoJSON.C_TAB*2 + '"uco-core:name": "' + appName + '"\n', \
			AXIOMtoJSON.C_TAB*2 + '}\n', \
			AXIOMtoJSON.C_TAB + ']\n', \
			'}'])
				
		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True
		
		self.FileOut.write(line);
		return uuid

	def __generateTraceAppIdentity(self, appName):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:IdentityFacet", \n', \
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[ \n', \
			AXIOMtoJSON.C_TAB*2 + '{ \n', \
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:OrganizationFacet", \n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:orgName":"' + appName + '" \n', \
			AXIOMtoJSON.C_TAB*2 + '}\n', \
			AXIOMtoJSON.C_TAB + ']\n', \
			'},\n'])
		self.FileOut.write(line);
		return uuid
		

	def __generateTraceChatAccount(self, issuer, partyId, partyName, idApp):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		
		partyId = self.__cleanString(partyId)
		partyName = self.__cleanString(partyName)

		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n', \
			AXIOMtoJSON.C_TAB*2 + '{\n', \
			AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:AccountFacet", \n', \
		# CASE 0.4 indicates a id reference to an Object that contains only the name of the App!
		#line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:accountIssuer": "' + issuer + '",\n'		
		# in CASE 0.4 applicationIdentifier --> accountIdentifier
		#line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:applicationIdentifier": "' + partyId + '",\n' 
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:accountIdentifier": "' + partyId + '",\n', \
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:isActive":true\n', \
			AXIOMtoJSON.C_TAB*2 + '},\n', \
			AXIOMtoJSON.C_TAB*2 + '{\n', \
			AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:ApplicationAccountFacet",\n', \
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:application":\n', \
			AXIOMtoJSON.C_TAB*4 + '{\n', \
			AXIOMtoJSON.C_TAB*5 + '"@id":"' + idApp + '"\n', \
			AXIOMtoJSON.C_TAB*4  + '}\n', \
			AXIOMtoJSON.C_TAB*2 + '},\n', \
			AXIOMtoJSON.C_TAB*2 + '{\n', \
			AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:DigitalAccountFacet",\n', \
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:displayName":"' + partyName + '"\n', \
			AXIOMtoJSON.C_TAB*2 + '}\n', \
			AXIOMtoJSON.C_TAB + '] \n', \
			'}'])
		
		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True

		self.FileOut.write(line)
		return uuid

	def __generateTraceChat(self, body, idApplication, timeStamp, idFrom,
		idToList, status, outcome, direction, attachmentNames, 
		attachmentUrls):
				
		TOlist = '{"@id":"' + idToList + '"}'
		
		body = self.__cleanString(body)
		TOlist = TOlist.replace('\t', ' ')

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n', \
			AXIOMtoJSON.C_TAB*2 + '{\n', \
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:MessageFacet", \n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:messageText":"' + body + '",\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:application":\n', \
			AXIOMtoJSON.C_TAB*3 + '{\n', \
			AXIOMtoJSON.C_TAB*3 + '"@id":"' + idApplication + '"\n', \
			AXIOMtoJSON.C_TAB*3 + '},\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:sentTime":\n', \
			AXIOMtoJSON.C_TAB*3 + '{\n', \
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n', \
			AXIOMtoJSON.C_TAB*3 + '"@value":"' + timeStamp + '"\n', \
			AXIOMtoJSON.C_TAB*3 + '},\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:from":{\n', \
			AXIOMtoJSON.C_TAB*3 + '"@id":"' + idFrom + '"\n', \
			AXIOMtoJSON.C_TAB*2 + '},\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:to":[\n', \
			AXIOMtoJSON.C_TAB*3 + TOlist + '],\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:allocationStatus":"' + status + '",\n', \
#	CASE 0.2/UCO 0.4 compliant, no uco-observable:out property in Observable
#
		#line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:drafting:outcome":"' + outcome + '",\n'
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:messageType":"' + direction + '"\n', \
			AXIOMtoJSON.C_TAB*2 + '}\n', \
			AXIOMtoJSON.C_TAB + ']\n', \
			'}\n'])

		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True

		self.FileOut.write(line)
		
		#each Message, within a specific Chat can have more than one attachment,
		# both the Filenames and the Urls of the Attachment are separated by
		# a triple hash tag # 
		listFileNames = attachmentNames.split('###');
		listFileUrls = attachmentUrls.split('###');
		nName = len(listFileNames)
		nUrl = len(listFileUrls)
		if nName > nUrl:
			for i in range(nName - nUrl):
				listFileUrls.append('')
		if nName < nUrl:
			for i in range(nUrl - nName):
				listFileNames.append('')


		for i, list_file_name in enumerate(listFileNames):
			if (list_file_name.strip() != '') or \
			 	(listFileUrls[i].strip() != ''):
#---	listFileUrls[i] will be stored in the property path of the FILE trace
#			 	
				fileUuid = self.__generateTraceFile(list_file_name, 
				'', '', '', '', '', '', '', listFileUrls[i],
				'', '', '', '', '', '', '', '')
				
				self.__generateTraceRelation(fileUuid, uuid, 'Connected_To', 
				'', '')
		return uuid


	def generateTraceDevice(self, deviceMAC, deviceSN, deviceModel,
		deviceOS, deviceOSVersion, deviceManufacturer, deviceWiFi, deviceICCID,
		deviceIMSI, deviceIMEI, deviceBluetoothAddress):

		deviceModel = self.__cleanString(deviceModel)
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject",\n', \
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n', \
			AXIOMtoJSON.C_TAB*2 + '{\n', \
			AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:DeviceFacet",\n', \
			#AXIOMtoJSON.C_TAB*3 + '"uco-observable:model":"' + deviceModel + '",\n', \
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:serialNumber":"' + deviceSN + '",\n', \
			AXIOMtoJSON.C_TAB*3 + '"uco-core:name":"' + deviceModel + '"\n', \
			AXIOMtoJSON.C_TAB*2 + '}\n', \
			
			#AXIOMtoJSON.C_TAB*2 + '{\n', \
			#AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:MobileDeviceFacet",\n', \
			#AXIOMtoJSON.C_TAB*3 + '"uco-observable:IMEI":"' + deviceIMEI + '"\n', \
		
#	if properties are not provided, the related line is not written
#
		#line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:bluetoothDeviceName":"NOT_PROVIDED",\n'
		#line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:mockLocationsAllowed":"NOT_PROVIDED",\n'		
		#	line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:phoneActivationTime":\n'
		#line += AXIOMtoJSON.C_TAB*3 + '{\n'
		#line += AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		#line += AXIOMtoJSON.C_TAB*3 + '"@value":"NOT_PROVIDED"\n'
		#line += AXIOMtoJSON.C_TAB*3 + '},\n'
		
		#line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:storageCapacityInBytes":{\n'
		#line += AXIOMtoJSON.C_TAB*3 + '"@type": "xsd:long",\n'
		#line += AXIOMtoJSON.C_TAB*3 + '"@value": "NOT_PROVIDED"\n'
		#line += AXIOMtoJSON.C_TAB*2 + '},\n'

		#line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:clockSetting":"NOT_PROVIDED"\n'
			#AXIOMtoJSON.C_TAB*2 + '},\n' , \
			#AXIOMtoJSON.C_TAB*2 + '{\n', \
			#AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:OperatingSystemFacet",\n', \
			#AXIOMtoJSON.C_TAB*2 + '"uco-observable:name": "' + deviceOS + '",\n', \
			#AXIOMtoJSON.C_TAB*2 + '"uco-observable:manufacturer":"' + deviceManufacturer + '",\n', \
			#AXIOMtoJSON.C_TAB*2 + '"uco-observable:version":"' + deviceOSVersion + '"\n', \
			#AXIOMtoJSON.C_TAB*2 + '},\n', \
#	CASE 0.2/UCO 0.4 compliant, nither observable:AndroidDevice nor observable:AppleDevice are
#	classes of the observable.ttl ontology
#
		#line += AXIOMtoJSON.C_TAB*2 + '{\n'		
		#if deviceOS.lower() == 'android':
		#	line += AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:AndroidDevice",\n'
		#	line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:androidID": "NOT_PROVIDED",\n'
		#	line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:androidSerialNumber": "' + deviceSN + '",\n'
		#else:
		#	line += AXIOMtoJSON.C_TAB*2 + '"@type":"AppleDevice",\n'
		#	line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:AppleDeviceID": "NOT_PROVIDED",\n'
		#	line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:AppleDevideSerialNumber": "' + deviceSN + '",\n'

		#line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:screenUnlockPattern":"NOT_PROVIDED"\n'
		#line += AXIOMtoJSON.C_TAB*2 + '},\n'
			#AXIOMtoJSON.C_TAB*2 + '{\n', \
			#AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:BluetoothAddressFacet",\n', \
			#AXIOMtoJSON.C_TAB*2 + '"uco-observable:addressValue":"' + deviceBluetoothAddress + '"\n', \
			#AXIOMtoJSON.C_TAB*2 + '},\n ', \
			#AXIOMtoJSON.C_TAB*2 + '{\n', \
			#AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:WifiAddressFacet",\n', \
			#AXIOMtoJSON.C_TAB*2 + '"uco-observable:addressValue":"' + deviceWiFi + '"}\n', \
		
		#line += AXIOMtoJSON.C_TAB*2 + '{\n'
		#line += AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:MobileAccount",\n '
		#line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:MSISDN":"NOT_PROVIDED"\n'
		#line += AXIOMtoJSON.C_TAB*2 + '}\n'
			AXIOMtoJSON.C_TAB + ']\n', \
			'}'])

		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True

		self.FileOut.write(line)
		return uuid
	
	def __generateTraceEmail(self, EMAILid, EMAILstatus, EMAILsource, EMAILlocation,
		EMAILidentifierFROM, EMAILidentifiersTO, EMAILidentifiersCC, 
		EMAILidentifiersBCC, EMAILbody, EMAILsubject, EMAILtimeStamp, 
		EMAILattachmentsFilename):
		
		if EMAILidentifierFROM.strip() in self.EMAILaddressList:
			idx = self.EMAILaddressList.index(EMAILidentifierFROM.strip())
			idFROM = self.EMAILaccountIdList[idx]
		else:
			self.EMAILaddressList.append(EMAILidentifierFROM.strip())
			uuidEmail = self.__generateTraceEmailAccount(EMAILidentifierFROM.strip())
			self.EMAILaccountIdList.append(uuidEmail)
			idFROM = uuidEmail
		
		itemsTO = ''

#---	addresses in the TO field, are separated with comma
#
		EMAILtoList = EMAILidentifiersTO.split(',')
		for i, email_to_list in enumerate(EMAILtoList):
			if email_to_list.strip() != '':
				if email_to_list.strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(email_to_list.strip())
					idTO = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(email_to_list.strip())
					uuidEmail = self.__generateTraceEmailAccount(email_to_list.strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idTO = '{"@id":"' + uuidEmail + '"}'
				itemsTO += itemsTO + idTO + ','
		
		# get rid of the last comma
		itemsTO = itemsTO[0:-1]

		itemsCC = ''
		EMAILtoList = EMAILidentifiersCC.split(',')
		for i, email_to_list in enumerate(EMAILtoList):
			if email_to_list.strip() != '':
				if email_to_list.strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(email_to_list.strip())
					idCC = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(email_to_list.strip())
					uuidEmail = self.__generateTraceEmailAccount(email_to_list.strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idCC = '{"@id":"' + uuidEmail + '"}'
				itemsCC += itemsCC + idCC + ','

		# get rid of the last comma
		itemsCC = itemsCC[0:-1]

#	CASE 0.2/UCO 0.4 compliant, the right property is bcc
#		
		
		itemsBCC = ''
		EMAILtoList = EMAILidentifiersBCC.split(',')
		for i, email_to_list in enumerate(EMAILtoList):
			if email_to_list.strip() != '':
				if email_to_list.strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(email_to_list.strip())
					idBCC = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(email_to_list.strip())
					uuidEmail = self.__generateTraceEmailAccount(email_to_list.strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idBCC = '{"@id":"' + uuidEmail + '"}'
				itemsBCC += itemsBCC + idBCC + ','

#--	get rid of the last comma
#				
		itemsBCC = itemsBCC[0:-1]

		body = self.__cleanString(EMAILbody)

		subject = self.__cleanString(EMAILsubject)
#--- Replace all characters different from number, space or character with nothing
#		
		subject = re.sub('[^0-9A-Za-z ]','', subject)


#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx
#			the character "/" is not allowed
#		
		EMAILtimeStamp = self.__cleanDate(EMAILtimeStamp)	

		uuid = "kb:" + AXIOMtoJSON.__createUUID()

		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject",\n', \
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n', \
			AXIOMtoJSON.C_TAB*2 + '{\n', \
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:EmailMessageFacet",\n', \
#	CASE 0.2/UCO 0.4 compliant, it would be necessary to create a idref to the application
#
		#line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:application":"' + EMAILsource + '",\n'
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:sentTime":\n', \
			AXIOMtoJSON.C_TAB*3 + '{\n', \
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n', \
			AXIOMtoJSON.C_TAB*3 + '"@value":"' + EMAILtimeStamp + '"\n', \
			AXIOMtoJSON.C_TAB*3 + '},\n', \

#	CASE 0.2/UCO 0.4 compliant, the right property is from
#			
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:isMimeEncoded":false,\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:isMultipart":false,\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:from":{\n', \
			AXIOMtoJSON.C_TAB*3 + '"@id":"' + idFROM + '"\n', \
			AXIOMtoJSON.C_TAB*2 + '},\n', \
#	CASE 0.2/UCO 0.4 compliant, the right property is to
#		
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:to":[', \
			itemsTO + '],\n', \
#	CASE 0.2/UCO 0.4 compliant, the right property is cc
#		
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:cc":[', \
			itemsCC + '],\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:bcc":[', \
			itemsBCC + '],\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:body":"' + body + '",\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:subject":"' + subject + '",\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:allocationStatus":"' + EMAILstatus + '"\n', \
			AXIOMtoJSON.C_TAB*2 + '} \n', \
			AXIOMtoJSON.C_TAB + '] \n', \
			'}'])
		
		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True

		self.FileOut.write(line);
		self.__generateChainOfEvidence(EMAILsource, EMAILlocation, uuid)		

		for i, email_attachment_file in enumerate(EMAILattachmentsFilename):
			if email_attachment_file.strip() != '':
				fileUuid = self.__generateTraceFile(email_attachment_file, 
				'', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '')
				self.__generateTraceRelation(fileUuid, uuid, 'Attached_To', 
				'', '')
		return uuid

	def __generateTraceEmailAccount(self, address):
		
		uuidAddress = self.__generateTraceEmailAddress(address)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[{\n', \
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:AccountFacet", \n', \

#	CASE 0.2/UCO 0.4 compliant, there is no property accountIssuer
#		
		#line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:accountIssuer": "' + \
		#	'' + '",\n'
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:isActive":true,\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:accountIdentifier":" "\n', \
			AXIOMtoJSON.C_TAB*2 + '},\n', \
			AXIOMtoJSON.C_TAB*2 + '{\n', \
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:EmailAccountFacet",\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:emailAddress":\n', \
			AXIOMtoJSON.C_TAB*3 + '{"@id":"' + uuidAddress + '"}\n', \
			AXIOMtoJSON.C_TAB*2 + '}\n', \
			AXIOMtoJSON.C_TAB + '] \n', \
			'}'])
		
		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True

		self.FileOut.write(line)
		return uuid

	def __generateTraceEmailAddress(self, address):
		
		address = self.__cleanString(address)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[{\n', \
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:EmailAddressFacet", \n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:addressValue":"' + address +'"\n', \
			AXIOMtoJSON.C_TAB + '}\n', \
			AXIOMtoJSON.C_TAB + '] \n', \
			'}'])
		
		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True

		self.FileOut.write(line)
		return uuid


	def __generateTraceFile(self, FILEpath, FILEsize, FILEhashType, 
		FILEHashValue, FILETag, FILEtimeC, FILEtimeM, FILEtimeA, FILElocalPath, 
		FILEextension, FILEexifMake, FILEexifModel, FILEexifLatitudeRef, FILEexifLatitude, 
		FILEexifLongitudeRef, FILEexifLongitude, FILEexifAltitude):
		
		

		head, tail = os.path.split(FILEpath)
		tail = tail.replace("\\", "/")
		tail = tail.replace('"', "'")
		path = FILEpath.replace('\\', '/')
		path = path.replace('"', "'")
		dotPos = tail.find('.')
		sExt = tail[dotPos:]
		
		if FILEHashValue.upper() == 'N/A':
			FILEHashValue = '0';

		if FILEhashType.upper() == '_NOT_PROVIDED_':
			FILEhashType = 'MD5';


		if FILEsize.strip() == '':
			FILEsize = '0'

		sizeFile = ''
		if FILEsize.strip() != '0':
			sizeFile = "".join([',' + AXIOMtoJSON.C_TAB + '{\n' ,\
				AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:ContentDataFacet",\n',\
				AXIOMtoJSON.C_TAB*2 + '"uco-observable:hash":[\n',\
				AXIOMtoJSON.C_TAB*3 + '{\n',\
				AXIOMtoJSON.C_TAB*3 + '"@type":"uco-types:Hash",\n',\
				AXIOMtoJSON.C_TAB*3 + '"uco-types:hashMethod":\n',\
				AXIOMtoJSON.C_TAB*4 + '{\n',\
				AXIOMtoJSON.C_TAB*4 + '"@type": "uco-vocabulary:HashNameVocab",\n',\
				AXIOMtoJSON.C_TAB*4 + '"@value": "' + FILEhashType + '"\n',\
				AXIOMtoJSON.C_TAB*4 + '},\n',\
				AXIOMtoJSON.C_TAB*3 + '"uco-types:hashValue":\n',\
				AXIOMtoJSON.C_TAB*4 + '{\n',\
				AXIOMtoJSON.C_TAB*4 + '"@type": "xsd:hexBinary",\n',\
				AXIOMtoJSON.C_TAB*4 + '"@value":"' + FILEHashValue  + '"\n',\
				AXIOMtoJSON.C_TAB*4 + '}\n',\
				AXIOMtoJSON.C_TAB*3 + '}\n',\
				AXIOMtoJSON.C_TAB*2 + '] \n',\
			#line += AXIOMtoJSON.C_TAB*2 +  '"uco-observable:SizeInBytes":"256"\n'
				AXIOMtoJSON.C_TAB + '}\n'])
			
		localPath = FILElocalPath.replace("\\", "/")
		
		FILEtimeC = self.__cleanDate(FILEtimeC)
		FILEtimeM = self.__cleanDate(FILEtimeM)
		FILEtimeA = self.__cleanDate(FILEtimeA)	
		line_exif = ''
		if FILEexifLatitude.strip() != '':
			FILEexifLatitude = FILEexifLatitude.strip('" ')
			FILEexifLongitude = FILEexifLongitude.strip('" ')
			FILEexifAltitude = FILEexifAltitude.strip('" ')
			line_exif = "".join([',' + AXIOMtoJSON.C_TAB + '{\n' ,\
				AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:EXIFFacet",\n',\
				AXIOMtoJSON.C_TAB*2 + '"uco-observable:exifData": {\n',\
				AXIOMtoJSON.C_TAB*3 + '"@type": "uco-types:ControlledDictionary",\n',\
				AXIOMtoJSON.C_TAB*3 + ' "uco-types:entry": [\n',\
				AXIOMtoJSON.C_TAB*4 + '{\n',\
				AXIOMtoJSON.C_TAB*5 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:key": "Make",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:value": "' + FILEexifMake + '"\n',\
				AXIOMtoJSON.C_TAB*4 + '},\n',\
				AXIOMtoJSON.C_TAB*4 + '{\n',\
				AXIOMtoJSON.C_TAB*5 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:key": "Model",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:value": "' + FILEexifModel + '"\n',\
				AXIOMtoJSON.C_TAB*4 + '},\n',\
				AXIOMtoJSON.C_TAB*4 + '{\n',\
				AXIOMtoJSON.C_TAB*5 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:key": "LatitudeRef",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:value": "' + FILEexifLatitudeRef + '"\n',\
				AXIOMtoJSON.C_TAB*4 + '},\n',\
				AXIOMtoJSON.C_TAB*4 + '{\n',\
				AXIOMtoJSON.C_TAB*5 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:key": "Latitude",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:value": "' + FILEexifLatitude + '"\n',\
				AXIOMtoJSON.C_TAB*4 + '},\n',\
				AXIOMtoJSON.C_TAB*4 + '{\n',\
				AXIOMtoJSON.C_TAB*5 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:key": "LongitudeRef",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:value": "' + FILEexifLongitudeRef + '"\n',\
				AXIOMtoJSON.C_TAB*4 + '},\n',\
				AXIOMtoJSON.C_TAB*4 + '{\n',\
				AXIOMtoJSON.C_TAB*5 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:key": "Longitude",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:value": "' + FILEexifLongitude + '"\n',\
				AXIOMtoJSON.C_TAB*4 + '},\n',\
				AXIOMtoJSON.C_TAB*4 + '{\n',\
				AXIOMtoJSON.C_TAB*5 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:key": "Altitude",\n',\
				AXIOMtoJSON.C_TAB*5 + '"uco-types:value": "' + FILEexifAltitude + '"\n',\
				AXIOMtoJSON.C_TAB*4 + '}\n',\
				AXIOMtoJSON.C_TAB*3 + ']\n',\
				AXIOMtoJSON.C_TAB*2 + '}\n',\
				AXIOMtoJSON.C_TAB + '}\n'])

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject",\n', \
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:tag":["' + FILETag + '"],\n'	, \
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n', \
			AXIOMtoJSON.C_TAB + '{\n', \
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:FileFacet",\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:fileName":"' + tail + '",\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:filePath":"' + path + '",\n', \

#--- 	the property fileLocalPath is not included in the UCO observable.TTL
#			ontology yet
#			
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:fileLocalPath":"' + localPath + '",\n', \
		
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:extension":"' + FILEextension + '",\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:fileSystemType":"userdata (ExtX)",\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:isDirectory":false,\n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:sizeInBytes": {\n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:integer", \n',\
			AXIOMtoJSON.C_TAB*3 + '"@value":"' + FILEsize + '"\n',\
			AXIOMtoJSON.C_TAB*2 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-core:objectCreatedTime":\n',\
			AXIOMtoJSON.C_TAB*2 + '{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			AXIOMtoJSON.C_TAB*3 + '"@value":"' + FILEtimeC + '"\n',\
			AXIOMtoJSON.C_TAB*2 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-core:objectModifiedTime":\n',\
			AXIOMtoJSON.C_TAB*2 + '{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			AXIOMtoJSON.C_TAB*3 + '"@value":"' + FILEtimeM + '"\n',\
			AXIOMtoJSON.C_TAB*2 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-core:objectAccessedTime":\n',\
			AXIOMtoJSON.C_TAB*2 + '{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			AXIOMtoJSON.C_TAB*3 + '"@value":"' + FILEtimeA + '"\n',\
			AXIOMtoJSON.C_TAB*2 + '}\n',\
			AXIOMtoJSON.C_TAB + '}\n',\
			sizeFile , \
			line_exif , \
			AXIOMtoJSON.C_TAB + ']\n',\
			'}'])
		
		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True 

		self.FileOut.write(line);
		return uuid

#---	FileFacet for the Chain of Evidence
#		the data are FileName, FilePath, FileExt, FileSystemType
#		In the additional property observable:comment contains the Location
#		extracted by the XML report related to the table the Trace comes from
#		
	def __generateTraceFileCoE(self, FILEpath, FILEname, FILEext, FILEsysType, 
		FILElocation):
		
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = '{ \n'
		line += AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n'
		line += AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject",\n'
		line += AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n'
		line += AXIOMtoJSON.C_TAB + '"uco-core:tag":["Binary"],\n'
		line += AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n'
		line += AXIOMtoJSON.C_TAB*2 + '{\n'
		line += AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:FileFacet",\n'
		line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:fileName":"' + FILEname + '",\n'
		line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:filePath":"' + FILEpath + '",\n'
		line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:extension":"' + FILEext + '",\n'
		line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:fileSystemType":"' 
		line += FILEsysType + '",\n'
		line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:isDirectory":false,\n'
		line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:comment":"' + FILElocation + '"\n'
		# AXIOMtoJSON.C_TAB*2 + '"uco-observable:sizeInBytes": {\n',\
		# AXIOMtoJSON.C_TAB*2 + '"@type":"xsd:integer", \n',\
		# AXIOMtoJSON.C_TAB*2 + '"@value":"' + FILEsize + '"\n',\
		# AXIOMtoJSON.C_TAB*2 + '},\n',\
		line += AXIOMtoJSON.C_TAB*2 + '}\n'
		line += AXIOMtoJSON.C_TAB + ']\n'
		line += '}'
		
		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True 

		self.FileOut.write(line);
		return uuid

	def __generateTraceIdentity(self, name, familyName, birthDate):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			AXIOMtoJSON.C_TAB + '"@type":"uco-identity:Identity",\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n',\
			AXIOMtoJSON.C_TAB*2 + '{\n',\
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-identity:SimpleName",\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-identity:givenName":"' + name + '",\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-identity:familyName":"' + familyName + '"\n',\
			AXIOMtoJSON.C_TAB*2 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '{\n',\
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-identity:BirthInformation",\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-identity:birthdate":{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			AXIOMtoJSON.C_TAB*3 + '"@value":"' + birthDate + '"\n',\
			AXIOMtoJSON.C_TAB*2 + '}\n',\
			AXIOMtoJSON.C_TAB + '}\n',\
			AXIOMtoJSON.C_TAB + ']\n',\
			'},\n'])
		self.FileOut.write(line);
		return uuid

	def writePhoneAccountFromContacts(self, CONTACTname, CONTACTphoneNums):
		for i, contact_name in enumerate(CONTACTname):
			CONTACTphoneNums[i] = CONTACTphoneNums[i].replace(' ', '')
			if CONTACTphoneNums[i] not in self.phoneNumberList:					
				self.phoneNumberList.append(CONTACTphoneNums[i])
				self.phoneNameList.append(contact_name)
				mobileOperator = ""
				uuid = self.generateTracePhoneAccount(mobileOperator, contact_name, 
					CONTACTphoneNums[i])
				self.phoneUuidList.append(uuid)

	def generateTracePhoneAccount(self, Source, Name, PhoneNum):
		
		if Source == "":
			sourceLine= ''
		else:
			sourceLine += AXIOMtoJSON.C_TAB*2 + '"uco-observable:accountIssuer":"' + Source + '", \n'

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[ \n',\
			AXIOMtoJSON.C_TAB*2 + '{ \n',\
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:AccountFacet", \n',\
			sourceLine,\
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:isActive":true,\n' ,\
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:accountIdentifier":" "\n' ,\
			AXIOMtoJSON.C_TAB*2 + '}, \n',\
			AXIOMtoJSON.C_TAB*2 + '{ \n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:PhoneAccountFacet", \n',\
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:phoneNumber":"' + PhoneNum + '", \n',\
			AXIOMtoJSON.C_TAB*3 + '"uco-core:name":"' + Name + '"\n' ,\
			AXIOMtoJSON.C_TAB*2 + '} \n',\
			AXIOMtoJSON.C_TAB + '] \n',\
			'}'])
		
		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True 
		
		self.FileOut.write(line);
		return uuid

	def __generateTraceInvestigativeAction(self, name, description, startTime, endTime, 
		idInstrument, location, idPerformer, idObject, listResult, endChar):
		
		n = len(listResult)
		lineResult = ''
		for i in range(n - 1):
			lineResult += AXIOMtoJSON.C_TAB*3 + '{"@id":"' + listResult[i] + '"},';

		if n > 0:
			lineResult += '{"@id":"' + listResult[n - 1]  + '"}\n'
			lineResult += AXIOMtoJSON.C_TAB*2 + ']\n'
			lineResult += AXIOMtoJSON.C_TAB*2 + '}';


		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			AXIOMtoJSON.C_TAB +  '"@type":"uco-action:Action",\n',\
			AXIOMtoJSON.C_TAB +  '"uco-action:name":"' + name + '",\n',\
			AXIOMtoJSON.C_TAB + '"uco-action:description":"' + description + '",\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-action:startTime":\n',\
			AXIOMtoJSON.C_TAB*3 + '{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			AXIOMtoJSON.C_TAB*3 + '"@value":"' + startTime + '"\n',\
			AXIOMtoJSON.C_TAB*3 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-action:endTime":\n',\
			AXIOMtoJSON.C_TAB*3 + '{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			AXIOMtoJSON.C_TAB*3 + '"@value":"' + endTime + '"\n',\
			AXIOMtoJSON.C_TAB*3 + '},\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n',\
			AXIOMtoJSON.C_TAB*2 + '{\n',\
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-action:ActionReferences",\n' ,\
			AXIOMtoJSON.C_TAB*2 + '"uco-action:instrument":{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@id":"' + idInstrument + '"\n',\
			AXIOMtoJSON.C_TAB*2 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-action:location":{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@id":"' + location + '"\n',\
			AXIOMtoJSON.C_TAB*2 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-action:performer":{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@id":"' + idPerformer + '"\n',\
			AXIOMtoJSON.C_TAB*2 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-action:object":[\n',\
			AXIOMtoJSON.C_TAB*3 + '{"@id":"' + idObject + '"}\n',\
			AXIOMtoJSON.C_TAB*2 + '],\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-action:result":[\n',\
			lineResult,\
			AXIOMtoJSON.C_TAB + ']\n',\
			'}' + endChar + '\n'])
		self.FileOut.write(line);
		return uuid

	def __generateTracePhoneCall(self, direction, startTime, idFROM, idTO, 
								duration, status, outcome):

		nTime = 0
		if duration != '':
			aTime = duration.split(":")
			if len(aTime) == 3:
				nTime = aTime[0]*3600 + aTime[1]*60 + aTime[2] 
			if len(aTime) == 2:
				nTime = aTime[0]*60 + aTime[1] 
			if len(aTime) == 1:
				nTime = aTime[0] 
		duration = str(nTime)
		duration = duration.lstrip('0')
		if duration == "":
			duration = "0"

		if "Native" in self.appNameList: 
			idx = self.appNameList.index("Native")
			idAppName = self.appNameList[idx]
			idAppIdentity = self.appIDList[idx]
		else:
			idAppIdentity = self.__generateTraceAppName("Native")
			self.appNameList.append("Native")
			self.appIDList.append(idAppIdentity)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[ \n',\
			AXIOMtoJSON.C_TAB*2 + '{ \n',\
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:PhoneCallFacet", \n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:callType":"' + direction + '",\n ',\
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:startTime":\n',\
			AXIOMtoJSON.C_TAB*3 + '{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			AXIOMtoJSON.C_TAB*3 + '"@value":"' + startTime + '"\n',\
			AXIOMtoJSON.C_TAB*3 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:application":{ \n', \
			AXIOMtoJSON.C_TAB*3 + '"@id":"' + idAppIdentity + '" \n', \
			AXIOMtoJSON.C_TAB*2 + '}, \n', \
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:from":{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@id":"' + idFROM + '"\n',\
			AXIOMtoJSON.C_TAB*2 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:to":{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@id":"' + idTO + '"\n',\
			AXIOMtoJSON.C_TAB*2 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:duration":{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:long",\n',\
			AXIOMtoJSON.C_TAB*3 + '"@value":' + duration + '\n',\
			AXIOMtoJSON.C_TAB*3 + '},\n',\
#	CASE 0.2/UCO 0.4 compliant no uco-observable:outcome property in Observable
#		
		#line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:drafting:outcome":"' + outcome + '", \n'
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:allocationStatus":"' + status + '" \n',\
			AXIOMtoJSON.C_TAB*2 + '}\n' ,\
			AXIOMtoJSON.C_TAB + '] \n',\
			'} \n'])
		
		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True

		self.FileOut.write(line);
		return uuid
	

	def __generateTracePhoneOwner(self, Source, Name, PhoneNum):
		
		if self.commaLine:
			self.FileOut.write(', \n');
		else:
#---	this indicates that the next line to be writte must be preceeded by the
#			line with comma
#			
			self.commaLine = True

		if Source == "":
			lineSource = ''
		else:
			lineSource = AXIOMtoJSON.C_TAB*2 + '"uco-observable:accountIssuer":"' + Source + '", \n'
		
		self.phoneOwnerUuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' + self.phoneOwnerUuid + '", \n',\
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[ \n',\
			AXIOMtoJSON.C_TAB*2 + '{ \n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:AccountFacet", \n',\
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:isActive":true,\n',\
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:accountIdentifier":" "\n' ,\
			AXIOMtoJSON.C_TAB*2 + '}, \n',\
			AXIOMtoJSON.C_TAB*2 + '{ \n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:PhoneAccountFacet", \n',\
			AXIOMtoJSON.C_TAB*3 + '"uco-observable:phoneNumber":"' + PhoneNum + '", \n',\
			AXIOMtoJSON.C_TAB*3 + '"uco-core:name":"' + Name + '"\n' ,\
			lineSource,\
			AXIOMtoJSON.C_TAB*2 + '} \n',\
			AXIOMtoJSON.C_TAB + ']\n',\
			'}'])
		self.FileOut.write(line);
		self.phoneNumberList.append(PhoneNum)
		self.phoneUuidList.append(self.phoneOwnerUuid)

	def __generateTraceProvencance(self, idTracesList, description, 
		exhibitNumber, creationTime):
		
		#idx = 0
		n = len(idTracesList)
		lineTraces = ''
		
		for idx in range(n - 1):
			lineTraces += AXIOMtoJSON.C_TAB*2  + '{"@id":"' + idTracesList[idx] + '"},\n'

		if n > 0:
			lineTraces += AXIOMtoJSON.C_TAB*2  + '{"@id":"' + idTracesList[n - 1] + '"}\n'

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			AXIOMtoJSON.C_TAB + '"@type":"case-investigation:ProvenanceRecord", \n',\
			AXIOMtoJSON.C_TAB*2 + '"case-investigation:createdTime":\n',\
			AXIOMtoJSON.C_TAB*3 + '{\n',\
			AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			AXIOMtoJSON.C_TAB*3 + '"@value":"' + creationTime + '"\n',\
			AXIOMtoJSON.C_TAB*3 + '},\n',\
			AXIOMtoJSON.C_TAB + '"case-investigation:description":"' + description + '",\n',\
			AXIOMtoJSON.C_TAB + '"case-investigation:exhibitNumber":"' + exhibitNumber + '",\n',\
			AXIOMtoJSON.C_TAB + '"case-investigation:object":[\n',\
			lineTraces,\
			AXIOMtoJSON.C_TAB + ']\n',\
			'},\n'])
		self.FileOut.write(line)
		return uuid


	def __generateTraceRelation(self, source, target, relation, table, offset):
		
		if not table == '':
			cleanOffset = offset.replace('@', '')
			lineTable = "".join([AXIOMtoJSON.C_TAB + '"uco-core:isDirectional":true,\n',\
				AXIOMtoJSON.C_TAB + '"uco-core:facets": [\n',\
				AXIOMtoJSON.C_TAB*2 + '{\n ',\
				AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:DataRangeFacet",\n',\
				AXIOMtoJSON.C_TAB*2 + '"uco-observable:rangeOffset": {\n',\
				AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:integer", \n',\
				AXIOMtoJSON.C_TAB*3 + '"@value":"' + cleanOffset + '"\n',\
				AXIOMtoJSON.C_TAB*2 + '},\n',\
				AXIOMtoJSON.C_TAB*2 + '"uco-observable:rangeSize": {\n',\
				AXIOMtoJSON.C_TAB*3 + '"@type":"xsd:integer", \n',\
				AXIOMtoJSON.C_TAB*3 + '"@value":"0"\n',\
				AXIOMtoJSON.C_TAB*2 + '}\n',\
				#AXIOMtoJSON.C_TAB*3 + '"uco-observable:rangeOffsetType":"',\
				#table + '"\n',\
				AXIOMtoJSON.C_TAB*2 + '}\n ',\
				AXIOMtoJSON.C_TAB + ']'])
		else:
			lineTable = AXIOMtoJSON.C_TAB + '"uco-core:isDirectional":true\n'

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableRelationship",\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:source":{\n',\
			AXIOMtoJSON.C_TAB*2 + '"@id":"' + source + '"\n',\
			AXIOMtoJSON.C_TAB + '},\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:target":{\n' ,\
			AXIOMtoJSON.C_TAB*2 + '"@id":"' + target + '"\n',\
			AXIOMtoJSON.C_TAB + '},\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:kindOfRelationship":"' + relation + '",\n',\
			lineTable,\
			'}'])
		
		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True

		self.FileOut.write(line)
		return uuid

	def __generateTraceRole(self, role):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			AXIOMtoJSON.C_TAB + '"@type":"uco-role:Role",\n',\
			AXIOMtoJSON.C_TAB + '"uco-role:name":"' + role + '"\n',\
			'},\n'])
		self.FileOut.write(line)
		return uuid


	def __generateThreadMessages(self, chatTraceId, chatThread, chatIdAccountList):
		
		nChatThread = len(chatThread)
		lineThread  = ''
		for i in range(nChatThread - 1):
			lineThread += AXIOMtoJSON.C_TAB*3 + '{\n'
			lineThread += AXIOMtoJSON.C_TAB*4 + '"olo:index":"' + str(i + 1) + '",\n'
			lineThread += AXIOMtoJSON.C_TAB*4 + '"olo:item": {\n'
			lineThread += AXIOMtoJSON.C_TAB*5 + '"@id":"' + chatThread[i] + '"\n'
			lineThread += AXIOMtoJSON.C_TAB*4 + '}\n'
			lineThread += AXIOMtoJSON.C_TAB*3 + '},\n'

		nChatAccounts = len(chatIdAccountList)
		lineChatAccounts = ''		
		for i in range(nChatAccounts - 1):
			lineChatAccounts += AXIOMtoJSON.C_TAB*3 + '{"@id":"' + chatIdAccountList[i] + '"},\n'

		if nChatAccounts > 0:
			lineChatAccounts += AXIOMtoJSON.C_TAB*3  + '{"@id":"' + chatIdAccountList[nChatAccounts - 1] + '"}]\n' 

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
			AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n',\
			AXIOMtoJSON.C_TAB*2 + '{\n',\
			AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:MessageThreadFacet",\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:displayName":"",\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:message":{\n',\
			AXIOMtoJSON.C_TAB*2 + '"olo:length":"' + str(len(chatThread)) + '",\n',\
			AXIOMtoJSON.C_TAB*2 + '"olo:slot":[\n',\
			lineThread,\
			AXIOMtoJSON.C_TAB*3 + '{\n',\
			AXIOMtoJSON.C_TAB*4 + '"olo:index":"' + str(nChatThread) + '",\n',\
			AXIOMtoJSON.C_TAB*4 + '"olo:item": {\n',\
			AXIOMtoJSON.C_TAB*5 + '"@id":"' + chatThread[nChatThread - 1] + '"\n',\
			AXIOMtoJSON.C_TAB*4 + '}\n',\
			AXIOMtoJSON.C_TAB*3 + '}\n',\
			AXIOMtoJSON.C_TAB*3 + ']\n',\
			AXIOMtoJSON.C_TAB*2 + '},\n',\
			AXIOMtoJSON.C_TAB*2 + '"uco-observable:participants":[\n',\
			lineChatAccounts,\
			AXIOMtoJSON.C_TAB*2 + '}\n',\
			AXIOMtoJSON.C_TAB + ']\n',\
			'}\n'])
		
		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True

		self.FileOut.write(line)
		#self.__generateChainOfEvidence(chatTraceId, uuid)
		return uuid

	def __generateTraceTool(self, name, type, vendor, version, confList):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
			AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			AXIOMtoJSON.C_TAB + '"@type":"uco-tool:Tool", \n',\
			AXIOMtoJSON.C_TAB + '"uco-core:name":"' + name + '",\n' ,\
			AXIOMtoJSON.C_TAB + '"uco-tool:toolType":"' + type + '",\n',\
			AXIOMtoJSON.C_TAB + '"uco-tool:creator":"' + vendor + '",\n',\
			AXIOMtoJSON.C_TAB + '"uco-tool:version":"' + version + '"\n'])

		if len(confList) > 0:  
			line += line + ',\n'
			line += AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n'
			line += AXIOMtoJSON.C_TAB*2 + '{\n'
			line += AXIOMtoJSON.C_TAB*2 + '"@type":"uco-tool:ConfigurationSettingType",\n'
			line += AXIOMtoJSON.C_TAB*2 + '"configurationSetting":[\n'
			n = len(confList) - 1
			for i in range(n):
				listItems = []
				listItems = confList[i].split('@');
				line += AXIOMtoJSON.C_TAB*3 + '{\n'
				line += AXIOMtoJSON.C_TAB*3 + '"@type":"uco-tool:ConfigurationSettingType",\n'
				line += AXIOMtoJSON.C_TAB*3 + '"uco-tool:itemName":"' + listItems[0] + '",\n'
				line += AXIOMtoJSON.C_TAB*3 + '"uco-tool:itemValue":"' + listItems[1] + '"\n'
				line += AXIOMtoJSON.C_TAB*3 + '},\n' 
 
			listItems.clear()
			listItems += confList[n].split('@')
			line += AXIOMtoJSON.C_TAB*2 + '{\n'
			line += AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:ConfigurationSettingFacet",\n'
			line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:itemName":"' + listItems[0] + '",\n' 
			line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:itemValue":"' + listItems[1] + '"\n'
			line += AXIOMtoJSON.C_TAB*2 + '}\n'
			line += AXIOMtoJSON.C_TAB*2 + ']\n'
			line += AXIOMtoJSON.C_TAB + '}\n'
			line += AXIOMtoJSON.C_TAB + ']\n'
			line += '}\n';
		else:
			line += '}\n';

		if self.commaLine:
			self.FileOut.write(', \n')
		else:
			self.commaLine = True

		self.FileOut.write(line);
		return uuid

	def __generateTraceURL (self, URL_Value):
		
		URL_Value = self.__cleanString(URL_Value)
		if URL_Value.strip() in self.UrlList: 
					idx = self.UrlList.index(URL_Value.strip())
					uuid = self.UrlIDList[idx]
		else:
			uuid = "kb:" + AXIOMtoJSON.__createUUID()							
			self.UrlList.append(URL_Value.strip())
			self.UrlIDList.append(uuid)
		
			line = "".join(['{ \n', \
				AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
				AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
				AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
				AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n',\
				AXIOMtoJSON.C_TAB*2 + '{\n',\
				AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:URLFacet", \n',\
				AXIOMtoJSON.C_TAB*2 + '"uco-observable:fullValue":"' + URL_Value + '"\n',\
				AXIOMtoJSON.C_TAB*2 + '}\n',\
				AXIOMtoJSON.C_TAB + ']\n',\
				'}'])
			if self.commaLine:
				self.FileOut.write(', \n')
			else:
				self.commaLine = True

			self.FileOut.write(line)
		
		return uuid

	def __generateTraceWebPages(self, WEB_PAGEid, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGElastVisited,
				WEBsource, WEBlocation, WEBrecoveryMethod):

			if WEB_PAGEurl.strip() == '':				
				return 
#	CASE 0.4/UCO 0.6 compliant, new URLHistoryFacet class
#
			uuid = "kb:" + AXIOMtoJSON.__createUUID()
			
			WEB_PAGElastVisited = self.__cleanDate(WEB_PAGElastVisited)
			
			line = '\n{ \n'
			line += AXIOMtoJSON.C_TAB + '"@id":"' +  uuid + '", \n'
			line += AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n'
			line += AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n'
			line += AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[\n'
			line += AXIOMtoJSON.C_TAB*2 + '{\n'
			line += AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:URLHistoryFacet", \n'
			line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:browserInformation":{\n' 

			if WEB_PAGEsource.strip() in self.appNameList: 
				idx = self.appNameList.index(WEB_PAGEsource.strip())
				idAppName = self.appNameList[idx]
				idAppIdentity = self.appIDList[idx]
			else:
				idAppIdentity = self.__generateTraceAppName(WEB_PAGEsource.strip())
				self.appNameList.append(WEB_PAGEsource.strip())
				self.appIDList.append(idAppIdentity)

			line += AXIOMtoJSON.C_TAB*3 + '"@id":"' + idAppIdentity + '"\n'
			line += AXIOMtoJSON.C_TAB*2 + '},\n'

			#line += WEB_PAGEsource[i] + '", \n'
			line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:urlHistoryEntry": [\n'
			line += AXIOMtoJSON.C_TAB*2 + '{\n'
			line += AXIOMtoJSON.C_TAB*3 + '"@type":"uco-observable:URLHistoryEntry",\n'
			line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:firstVisit":\n'
			line += AXIOMtoJSON.C_TAB*4 + '{\n'
			line += AXIOMtoJSON.C_TAB*4 + '"@type":"xsd:dateTime",\n'
			line += AXIOMtoJSON.C_TAB*4 + '"@value":"1900-01-01T08:00:00"\n'
			line += AXIOMtoJSON.C_TAB*4 + '},\n'
			line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:lastVisit":\n'
			line += AXIOMtoJSON.C_TAB*4 + '{\n'
			line += AXIOMtoJSON.C_TAB*4 + '"@type":"xsd:dateTime",\n'
			line += AXIOMtoJSON.C_TAB*4 + '"@value":"' + WEB_PAGElastVisited + '"\n'
			line += AXIOMtoJSON.C_TAB*4 + '},\n'
			line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:expirationTime":\n'
			line += AXIOMtoJSON.C_TAB*4 + '{\n'
			line += AXIOMtoJSON.C_TAB*4 + '"@type":"xsd:dateTime",\n'
			line += AXIOMtoJSON.C_TAB*4 + '"@value":"1900-01-01T08:00:00"\n'
			line += AXIOMtoJSON.C_TAB*4 + '},\n'
			line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:userProfile":"",\n'
			uuidUrl = self.__generateTraceURL(WEB_PAGEurl)
			line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:url":{\n' 
			line += AXIOMtoJSON.C_TAB*4 + '"@id":"' + uuidUrl + '"\n'
			line += AXIOMtoJSON.C_TAB*3 + '},\n'
			
#---	the AXIOM report doesn't contain this information, so it will be ignored
#			
			#uuidUrl = self.__generateTraceURL(AXIOMtoJSON.C_REF_URL)
			#line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:referrerUrl":{\n'			
			#line += AXIOMtoJSON.C_TAB*4 + '"@id":"' + uuidUrl + '"\n'
			#line += AXIOMtoJSON.C_TAB*3 + '},\n'
			line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:pageTitle":"' 
			title = WEB_PAGEtitle.replace('"', '')
			line += title + '",\n'
			line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:visitCount":' 
			if WEB_PAGEvisitCount.strip() == '':
				line += '0,\n' 
			else:
				line += WEB_PAGEvisitCount + ',\n' 
			line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:manuallyEnteredCount":{\n'
			line += AXIOMtoJSON.C_TAB*4 + '"@type":"xsd:nonNegativeInteger",\n'
			line += AXIOMtoJSON.C_TAB*4 + '"@value":"0"\n'
			line += AXIOMtoJSON.C_TAB*4 + '},\n'
			line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:keywordSearchTerm":"NULL"\n'
			#line += AXIOMtoJSON.C_TAB*3 + '"uco-observable:allocationStatus":"' 
			#line += WEB_PAGEstatus[i] + '"\n'			
			line += AXIOMtoJSON.C_TAB*3 + '}\n'
			line += AXIOMtoJSON.C_TAB*2 + ']\n'  						
			line += AXIOMtoJSON.C_TAB + '}\n'  					
			line += AXIOMtoJSON.C_TAB + ']\n'  						
			line += '}'						
			
			if self.commaLine:
				self.FileOut.write(', \n')
			else:
				self.commaLine = True

			self.FileOut.write(line);
			
			self.__generateChainOfEvidence(WEBsource, WEBlocation, uuid)


	#not used anymore, every time the field Source is extracted
	# an uco-observable:Application item is created
	def storeUserAccount(self, U_ACCOUNTsource, U_ACCOUNTname,
			U_ACCOUNTusername):
		for i, u_accont_source in enumerate(U_ACCOUNTsource):
			idAppName = self.__generateTraceAppName(u_accont_source)
			self.appNameList.append(u_accont_source)
			self.appIDList.append(idAppName)

	def writeCall(self, CALLid, CALLappName, CALLtimeStamp, CALLdirection, 
				CALLduration, CALLpartner, CALLpartnerName, CALLsource, CALLlocation, 
				CALLrecoveryMethod):
		
		callOutcome = ''
		
		for i, call_id in enumerate(CALLid):
			if CALLdirection[i].lower() == 'incoming':
					phoneTO = self.phoneOwnerNumber
					phoneFROM = CALLpartner[i]
			else:
				phoneTO = CALLpartner[i]
				phoneFROM = self.phoneOwnerNumber

			phonePattern = '\+?[0-9]+'	# phone number pattern
			resPattern = re.match(phonePattern, CALLpartner[i])
			
			if (resPattern):
				if CALLpartner[i] in self.phoneNumberList:
					idx = self.phoneNumberList.index(CALLpartner[i])
					uuidPartner = self.phoneUuidList[idx]
				else:	
					mobileOperator = ""
					self.phoneNumberList.append(CALLpartner[i])
					self.phoneNameList.append(CALLpartnerName[i])
					uuidPartner = self.generateTracePhoneAccount(mobileOperator, 
						CALLpartnerName[i], CALLpartner[i])
					self.phoneUuidList.append(uuidPartner)			
			else:
				if CALLappName[i].strip() in self.appNameList: 
					idx = self.appNameList.index(CALLappName[i].strip())
					idAppName = self.appNameList[idx]
					idAppIdentity = self.appIDList[idx]
				else:
					idAppIdentity = self.__generateTraceAppName(CALLappName[i].strip())
					self.appNameList.append(CALLappName[i].strip())
					self.appIDList.append(idAppIdentity)

				if CALLpartner[i].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(CALLpartner[i].strip())
					uuidPartner = self.CHATaccountIdList[idx]
				else:
					self.CHATparticipantsNameList.append(CALLpartner[i].strip())
					uuidPartner = self.__generateTraceChatAccount(CALLsource[i].strip(),
						CALLpartner[i].strip(), CALLpartner[i].strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(CALLpartner[i].strip())
					self.CHATaccountIdList.append(uuidPartner)						

			if CALLdirection[i].lower() == 'incoming':
				uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
					CALLtimeStamp[i], uuidPartner, self.phoneOwnerUuid, CALLduration[i],
					CALLrecoveryMethod[i], callOutcome)
			else:
				uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
					CALLtimeStamp[i], self.phoneOwnerUuid, uuidPartner, CALLduration[i],
					CALLrecoveryMethod[i], callOutcome)
			
			self.__generateChainOfEvidence(CALLsource[i], CALLlocation[i], uuid)

	def ObservableRelationship(self, CONTACTname, CONTACTphoneNum,
				CONTACTsource, CONTACTlocation, CONTACTrecoveryMethod):
		
		for i, contact_name in enumerate(CONTACTname):
			if CONTACTphoneNum[i] == '':
				continue
			else:
				#phoneNum = CONTACTphoneNum[i].replace('+', '00')
				phoneNum = CONTACTphoneNum[i].replace(' ', '')
				if phoneNum not in self.phoneNumberList:					
					self.phoneNumberList.append(phoneNum)
					self.phoneNameList.append(contact_name)
					mobileOperator = ""
					#print(f'in ObservableRelationship, phoneNum={phoneNum}')
					uuid = self.generateTracePhoneAccount(mobileOperator, contact_name, phoneNum)
					self.phoneUuidList.append(uuid)

	def writeHeader(self):
		uuid = AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
				AXIOMtoJSON.C_TAB + '"@context": { \n', \
				AXIOMtoJSON.C_TAB*2 + '"@vocab": "http://caseontology.org/core#", \n', \
				AXIOMtoJSON.C_TAB*2 + '"case-investigation": "https://caseontology.org/ontology/case/investigation#", \n', \
				AXIOMtoJSON.C_TAB*2 + '"rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#", \n', \
				AXIOMtoJSON.C_TAB*2 + '"rdfs":"http://www.w3.org/2000/01/rdf-schema#", \n', \
				AXIOMtoJSON.C_TAB*2 + '"uco-action": "https://unifiedcyberontology.org/ontology/uco/action#", \n', \
				AXIOMtoJSON.C_TAB*2 + '"uco-core": "https://unifiedcyberontology.org/ontology/uco/core#", \n', \
				AXIOMtoJSON.C_TAB*2 + '"uco-identity": "https://unifiedcyberontology.org/ontology/uco/identity#",\n', \
				AXIOMtoJSON.C_TAB*2 + '"uco-role": "https://unifiedcyberontology.org/ontology/uco/role#",\n', \
				AXIOMtoJSON.C_TAB*2 + '"uco-location": "https://unifiedcyberontology.org/ontology/uco/location#",\n', \
				AXIOMtoJSON.C_TAB*2 + '"uco-observable": "https://unifiedcyberontology.org/ontology/uco/observable#", \n', \
				AXIOMtoJSON.C_TAB*2 + '"uco-tool": "https://unifiedcyberontology.org/ontology/uco/tool#", \n', \
				AXIOMtoJSON.C_TAB*2 + '"uco-types": "https://unifiedcyberontology.org/ontology/uco/types#", \n', \
				AXIOMtoJSON.C_TAB*2 + '"uco-vocabulary": "https://unifiedcyberontology.org/ontology/uco/vocabulary#", \n', \
#---	OLO is a method for representing lists, CASE didn't really need to implement itself, 
#		implementing ordered lists in an OWL 2 DL compliant  syntax.				
#				
				AXIOMtoJSON.C_TAB*2 + '"olo": "http://purl.org/ontology/olo/core#", \n', \
				AXIOMtoJSON.C_TAB*2 + '"xsd":"http://www.w3.org/2001/XMLSchema#" \n', \
				AXIOMtoJSON.C_TAB*2 + '},\n', \
				'"@id": ":bundle-' + uuid + '", \n', \
				'"@type": "uco-core:Bundle",\n', \
				'"uco-core:specVersion": "CASE 0.4 - UCO 0.6",\n', \
				'"uco-core:description": "Extraction from XML report generated by MAGNET AXIOM PROCESS",\n', \
				'"uco-core:object": [\n'])
		self.FileOut.write(line)

	def writeLastLine(self):
		self.__generateLastLine()

	def writePhoneOwner(self, phoneOwnerNumber, phoneOwnerName):
		self.phoneOwnerNumber = phoneOwnerNumber
#	see previous comment of the use of the mobileOperator variable
#	the mobileOwnerName is not available in the XML report		
		mobileOperator = ""
		self.__generateTracePhoneOwner(mobileOperator, phoneOwnerName, 
				phoneOwnerNumber)


	def writeFiles(self, FILEid, FILEtag, FILEname, FILElocalPath, FILEimage,
					FILEsize, FILEcreated, FILEmodified, FILEaccessed, FILEmd5,
					FILEexifMake, FILEexifModel, FILEexifLatitudeRef, FILEexifLatitude, 
					FILEexifLongitudeRef, FILEexifLongitude, FILEexifAltitude,
					FILEsource, FILElocation, FILErecoveryMethod):
			
			for i, file_id in enumerate(FILEid):
				if FILEname[i] == '':
					FILEname[i] = FILEimage[i]
				
				if FILEname[i].find('Binary data') > -1:
					pass
				else:
					fileExt = FILEname[i][FILEname[i].rfind('.') + 1:]

					uuid = self.__generateTraceFile(FILEname[i], FILEsize[i], 
						'MD5', FILEmd5[i],	FILEtag[i], FILEcreated[i], FILEmodified[i], 
						FILEaccessed[i], FILElocalPath[i], fileExt,
						FILEexifMake[i], FILEexifModel[i], FILEexifLatitudeRef[i], 
						FILEexifLatitude[i], FILEexifLongitudeRef[i], 
						FILEexifLongitude[i], FILEexifAltitude[i])

					self.FILEuuid[file_id] = uuid

	def writeChat(self, CHATid, CHATsender, CHATreceiver, CHATdateTimeSent, 
							CHATdateTimeReceived, CHATmessage, CHATmessageStatus, 
							CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod):		

		# print("len(CHATapplication)=" + str(len(CHATapplication)) )
		# print(CHATapplication[len(CHATapplication) - 1])
		# print("len(CHATid)=" + str(len(CHATid)) )
		# print(CHATid[len(CHATid) - 1])
		CHATthreadParticipants = []
		self.fillChatThread(CHATthreadParticipants, CHATid, CHATsender, CHATreceiver,
				CHATdateTimeSent, CHATdateTimeReceived, CHATmessage, CHATmessageStatus,
				CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod, 
				self.phoneOwnerNumber)			

		for i, chat_id in enumerate(self.CHATids):
#---	CHATidAccountList contains the list of the Mesages uuid of CHATs
#			CHATthread contains the values for the generation of the 
#			ChatThreadFacet Observable	
#								
			self.CHATthread = []	
			self.chatIdAccountList = []			
			for j, chat_id_item in enumerate(chat_id):
				if self.CHATapplications[i][j].strip().lower() in self.appNameList: 
					idx = self.appNameList.index(self.CHATapplications[i][j].strip().lower())
					idAppName = self.appNameList[idx]
					idAppIdentity = self.appIDList[idx]
				else:
					idAppIdentity = self.__generateTraceAppName(self.CHATapplications[i][j].strip().lower())
					self.appNameList.append(self.CHATapplications[i][j].strip().lower())
					self.appIDList.append(idAppIdentity)
				
				if self.CHATsenders[i][j].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(self.CHATsenders[i][j].strip())
					CHATmsgFrom = self.CHATaccountIdList[idx]
				else:
					CHATname = ''
					self.CHATparticipantsNameList.append(CHATname)
					CHATmsgFrom = self.__generateTraceChatAccount(self.CHATapplications[i][j].strip(),
						self.CHATsenders[i][j].strip(), CHATname, idAppIdentity)
					self.CHATparticipantsIdList.append(self.CHATsenders[i][j].strip())
					self.CHATaccountIdList.append(CHATmsgFrom)

				if self.CHATreceivers[i][j].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(self.CHATreceivers[i][j].strip())
					CHATmsgTo = self.CHATaccountIdList[idx]
				else:
					CHATname = ''
					self.CHATparticipantsNameList.append(CHATname)
					CHATmsgTo = self.__generateTraceChatAccount(self.CHATapplications[i][j].strip(),
						self.CHATreceivers[i][j].strip(), CHATname, idAppIdentity)
					self.CHATparticipantsIdList.append(self.CHATreceivers[i][j].strip())
					self.CHATaccountIdList.append(CHATmsgTo)
				

#---	if Identifiers TO is empty, the array CHATpartyIdentifiers must
#		be iterated to find the right Party
#								
				if self.CHATmessageStatuses[i][j].lower().find('received') > - 1:
					CHATdirection = 'Incoming'
					CHATdate = self.CHATdateTimeReceiveds[i][j] 
				else:			
					CHATdirection = 'Outgoing'
					CHATdate = self.CHATdateTimeSents[i][j]
								
				CHATattachmentFileNames = ''
				CHATattachmentUrls = ''
				#print('before __generateTraceChat, FROM: ' + CHATmsgFrom +
				#	', TO: ' + CHATmsgTo)

				chatUuid = self.__generateTraceChat(self.CHATmessages[i][j], idAppIdentity, 
					CHATdate, CHATmsgFrom, CHATmsgTo, self.CHATrecoveryMethods[i][j], 
					self.CHATmessageStatuses[i][j], CHATdirection, CHATattachmentFileNames,
					CHATattachmentUrls)
				self.CHATthread.append(chatUuid)

#---	if there are not messages for this Chat or no ChatAccount has been
# 		generated, the ThreadMessage is not generated. Moreover the Chain of
# 		evidence is built upon the ThreadUuid
#				
			if (len(self.CHATthread) != 0):
				uuidThread = self.__generateThreadMessages(self.CHATids[i][j], self.CHATthread, 
								[CHATmsgFrom, CHATmsgTo])
				self.__generateChainOfEvidence(CHATsource[i], CHATlocation[i], chatUuid)

	def writeEmail(self, EMAILid, EMAILapp, EMAILidentifierFROM, 
				EMAILidentifiersTO, EMAILidentifiersCC, EMAILidentifiersBCC, 
				EMAILbody, EMAILsubject, EMAILtimeStamp, EMAILattachmentsFilename,
				EMAILsource, EMAILlocation, EMAILrecoveryMethod):
		
		for i, email_id in enumerate(EMAILid):
			self.__generateTraceEmail(email_id, EMAILrecoveryMethod[i], EMAILsource[i],
				EMAILlocation[i], EMAILidentifierFROM[i], EMAILidentifiersTO[i], 
				EMAILidentifiersCC[i], EMAILidentifiersBCC[i], EMAILbody[i], 
				EMAILsubject[i], EMAILtimeStamp[i], EMAILattachmentsFilename[i])


	def writeWebPages(self, WEB_PAGEid, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited, 
				WEBsource, WEBlocation, WEBrecoveryMethod):
		for i in range(len(WEB_PAGEid) - 1):
			self.__generateTraceWebPages(WEB_PAGEid[i], WEB_PAGEsource[i], WEB_PAGEurl[i], 
					WEB_PAGEtitle[i], WEB_PAGEvisitCount[i],  WEB_PAGlastVisited[i],
					WEBsource[i], WEBlocation[i], WEBrecoveryMethod[i])

#--- last char is space not comma when i == len(WEB_PAGEid)
#			
		if len(WEB_PAGEid) > 0:
			self.__generateTraceWebPages(WEB_PAGEid[i], WEB_PAGEsource[i], WEB_PAGEurl[i], 
					WEB_PAGEtitle[i], WEB_PAGEvisitCount[i],  WEB_PAGlastVisited[i],
					WEBsource[i], WEBlocation[i], WEBrecoveryMethod[i])

	
	def writeSms(self, SMSid, SMSsender, SMSrecipient, SMSreceivedDateTime,
					SMSsentDateTime, SMSmessage, SMSdirection, SMSsource,
					SMSlocation, SMSrecoveryMethod):

		for i, sms_id in enumerate(SMSid):
			phoneUuidTo = ''
			phoneUuidFrom = ''
			SMSsenderClean = SMSsender[i].strip()
			if SMSsenderClean.lower() == 'local user':
				SMSsenderClean = self.phoneOwnerNumber


#---	get rid of hex chars byte not accepted in JSON values
#			
			if SMSsenderClean in self.phoneNumberList:						
				idx = self.phoneNumberList.index(SMSsenderClean)						
				userId = self.phoneNumberList[idx]
				phoneParticipantUuid = self.phoneUuidList[idx]
			else:
				senderName = ''
				self.phoneNumberList.append(SMSsenderClean)
				self.phoneNameList.append(senderName)
				mobileOperator = ""		
				SMSsenderClean = self.__cleanString(SMSsenderClean)
				#print(f'in writeSMS, SMSsenderClean={SMSsenderClean}')
				phoneParticipantUuid = self.generateTracePhoneAccount(mobileOperator, 
					senderName, SMSsenderClean)	
				self.phoneUuidList.append(phoneParticipantUuid)

			SMSrecipientClean = SMSrecipient[i].strip()
			if SMSrecipientClean.lower() == 'local user':
				SMSrecipientClean = self.phoneOwnerNumber

			if SMSrecipientClean in self.phoneNumberList:						
				idx = self.phoneNumberList.index(SMSrecipientClean)						
				userId = self.phoneNumberList[idx]
				phoneRecipientUuid = self.phoneUuidList[idx]
			else:
				recipientName = ''
				self.phoneNumberList.append(SMSrecipientClean)
				self.phoneNameList.append(recipientName)
				mobileOperator = ""
				SMSrecipientClean = self.__cleanString(SMSrecipientClean)
				#print(f'in writeSMS, SMSrecipientClean={SMSrecipientClean}')
				phoneRecipientUuid = self.generateTracePhoneAccount(mobileOperator, 
					recipientName, SMSrecipientClean)	
				self.phoneUuidList.append(phoneRecipientUuid)


			body = SMSmessage[i].replace('\n', ' ')
			body = body.replace('"', "'")
			body = body.replace('\t', ' ')
			body = body.replace("\\'", "'")
			body = body.replace("\\", "")
			#body = '?'.join(hex(ord(x))[2:] for x in body)

			if SMSreceivedDateTime[i] == '':
				phoneUuidFrom = phoneParticipantUuid
				phoneUuidTo = '{"@id":"' + phoneRecipientUuid + '"}'	
				SMSdate = SMSsentDateTime[i]
			else:
				phoneUuidFrom = phoneRecipientUuid
				phoneUuidTo = '{"@id":"' + phoneParticipantUuid + '"}'	
				SMSdate = SMSreceivedDateTime[i]


			uuid = "kb:" + AXIOMtoJSON.__createUUID()
			line = "".join(['{ \n', \
				AXIOMtoJSON.C_TAB + '"@id":"' + uuid + '", \n',\
				AXIOMtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
				AXIOMtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
				AXIOMtoJSON.C_TAB + '"uco-core:hasFacet":[ \n',\
				AXIOMtoJSON.C_TAB*2 + '{ \n',\
				AXIOMtoJSON.C_TAB*2 + '"@type":"uco-observable:MessageFacet", \n' ,\

#---	CASE 0.2/UCO 0.4 compliant,  uco-observable:SMSMessage is a class, not clear its possible
#			values
#				line += AXIOMtoJSON.C_TAB*2 + '"uco-observable:SMSmessage":"true", \n'
#				
				AXIOMtoJSON.C_TAB*2 + '"uco-observable:messageText":"' + body + '", \n',\
				AXIOMtoJSON.C_TAB*2 + '"uco-observable:allocationStatus":"' + SMSrecoveryMethod[i] + '", \n',\
				AXIOMtoJSON.C_TAB*2 + '"uco-observable:from":{\n',\
				AXIOMtoJSON.C_TAB*3 + '"@id":"' + phoneUuidFrom + '"\n',\
				AXIOMtoJSON.C_TAB*2 + '},\n',\
				AXIOMtoJSON.C_TAB*2 + '"uco-observable:to":[' + phoneUuidTo + '], \n',\
				AXIOMtoJSON.C_TAB*2 + '"uco-observable:sentTime":{\n',\
				AXIOMtoJSON.C_TAB*3 + '"@type": "xsd:dateTime", \n' ,\
				AXIOMtoJSON.C_TAB*3 + ' "@value": "' + SMSdate + '"\n',\
				AXIOMtoJSON.C_TAB*3 + '} \n'	,\
				AXIOMtoJSON.C_TAB*2 + '} \n',\
				AXIOMtoJSON.C_TAB + '] \n',\
				'}'])
			
			if self.commaLine:
				self.FileOut.write(', \n')
			else:
				self.commaLine = True
			
			self.FileOut.write(line)
			self.__generateChainOfEvidence(SMSsource[i], SMSlocation[i], uuid)

	def writeContextAxiom(self, axiomVersionText, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText,
		deviceBluetoothAddressText, deviceIdText, deviceModelText, 
		deviceOsTypeText, deviceOsVersionText, deviceVendorText, 
		deviceMacAddressText, deviceIccidText, deviceImsiText, 
		deviceImeiText, imagePath, imageSize, 
		imageMetadataHashSHA, imageMetadataHashMD5):

		self.___generateContextAxiom(ufedVersionText, deviceExtractionStartTime, 
			deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText, 
			deviceBluetoothAddressText, deviceIdText, devicePhoneModelText, 
			deviceOsTypeText, deviceOsVersionText, devicePhoneVendorText, 
			deviceMacAddressText, deviceIccidText, deviceImsiText, 
			deviceImeiText, imagePath, imageSize, 
			imageMetadataHashSHA, imageMetadataHashMD5)


