#---	class AXIOMtoJSON.py

import uuid
import os
import re
import re
import sys
#import logging
#from inspectrutils.case_builder import *
from AXIOM_case_generator import *
from datetime import datetime

class AXIOMtoJSON:
	'''
	Represents all attributes and methods to represent Traces in CASE ontology, starting from data
	extracted from XML reports generated by UFED-PA forensic tool
	'''
	TAB = '\t'
# default value for string value not provided
#
	NP = ''				

# default value for integer value not provided
#
	INT = '0'	

# default value for date value not provided
#
	DATE = '1900-01-01T08:00:00'

# default value for Hash Method value not provided
#
	HASH_M = 'MD5'

# default value for Hash Method value not provided
	HASH_V = '2' * 76

# default value for the property referrerUrl of the URLHistoryFacet class
	REF_URL = 'http:www.empty.com/referrer_url'

# default value for the location where a forensic action was carried out
	LOCATION = 'Unknown location'

	def __init__(self, json_output=None, case_bundle=None, commaLine=True):
		#logging.basicConfig(filename='_axiom_log.txt', level=logging.INFO,
		#	filemode='w', format='%(message)s')
		self.bundle = case_bundle
		self.FileOut = json_output
		self.commaLine = commaLine
		self.phoneNumberList = []
		self.phoneNameList = []
		self.phoneUuidList = []
		self.object_phone_owner = None
		
		self.appNameList = []
		self.appAccountUsernameList = []
		self.appAccountNameList = []
		self.appIDList = []

		self.CHATparticipantsNameList = []
		self.CHATparticipantsIdList = []
		self.CHATaccountIdList = []
		self.CHATthread = []

		self.observable_device = ''

		self.EMAILaddressUuid = {}
		self.EMAILregex = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
		self.phoneOwnerNumber = ''
		self.observable_phone_owner = None
		self.FILEuuid = {}
		self.FILEid = []

		self.EXTRA_INFOdictPath = {}
		self.EXTRA_INFOdictSize = {}
		self.EXTRA_INFOdictTableName = {}
		self.EXTRA_INFOdictOffset = {}
		self.EXTRA_INFOdictNodeInfoId = {}

		self.CHATids = []
		self.CHATsenders = []
		self.CHATreceivers = []
		self.CHATdateTimeSents = []
		self.CHATdateTimeReceiveds = []
		self.CHATmessages = []
		self.CHATmessageStatuses = []
		self.CHATsources = []
		self.CHATlocations = []
		self.CHATrecoveryMethods = []
		self.CHATapplications = []

		self.UrlList = {}

		self.LocationList = []
		self.LocationIDList = []

		self.LOCATION_lat_long_coordinate = {}
		self.CELL_TOWER_gsm ={}
		self.WIRELESS_NET_mac_address = {}
		self.SEARCHED_ITEMvalue_date = []


		
	# static methods do not receive class or instance arguments
	# and usually operate on data that is not instance or class-specific
	@staticmethod
	def __createUUID():
		'''	
		Observables in CASE have a unique identification number, based on Globally Unique Identifier.  
		Each time an Observable or an item of the uco-core:hasFacet array is generated this static method in invoked.
		: return: The UUID based on uuid4 (string).
		'''
		return str(uuid.uuid4())

	def __cleanJSONtext(self, originalText):
		'''	
		Clean the text by replacing carriage return, line feed, weird chars in CASE have a unique identification number, based on Globally Unique Identifier.  
		Each time an Observable or an item of the uco-core:hasFacet array is generated this static method in invoked.
		: param originalText: The original text to be cleaned (string).
		: return: The cleaned text (string).
		'''		
		new_text = originalText.strip()
		if new_text == '':
			return ''
		else:
			new_text = new_text.replace('"', "").replace('\n', '').replace('\r', '')
			new_text = new_text.replace('\t', " ").replace("\\'", "'").replace("\\", "")
			new_text = new_text.replace('ï¿½', '')
			return new_text

	
	def __checkAppName(self, name):
		'''	
		Manage of the Application name lists (self.appNameList and self.appIDList), to avoid duplications of Observables.
		: param name: The name of the application (string).
		: return: The UUID of the application created or retrieved by the lists (string).
		'''			
		if name in self.appNameList: 
			idx = self.appNameList.index(name)
			observable_app = self.appIDList[idx]
		else:
			observable_app = self.__generateTraceAppName(name)
			self.appNameList.append(name)
			self.appIDList.append(observable_app)
		
		return observable_app

	def __checkChatParticipant(self, chat_id, chat_name, chat_source, id_app):
		'''	
		Manage of the Chat Account lists (self.CHATparticipantsNameLis and self.CHATaccountIdList), to avoid duplications of Observables.
		: param chat_id: The participant ID of the chat (string).
		: param chat_name: The participant Name of the chat (string).
		: param chat_source: The name of the chat application (string).
		: param id_app: The UUID of the name of the chat application (string).
		: return: The UUID of the Chat Account (string, UUID ref).
		'''		
		if chat_id.strip() in self.CHATparticipantsIdList: 
			idx = self.CHATparticipantsIdList.index(chat_id.strip())
			observable_chat_account = self.CHATaccountIdList[idx]
		else:
			self.CHATparticipantsNameList.append(chat_name.strip())
			observable_chat_account = self.__generateTraceApplicationAccount(chat_id.strip(), 
				chat_name.strip(), id_app)
			self.CHATparticipantsIdList.append(chat_id.strip())
			self.CHATaccountIdList.append(observable_chat_account)
		
		return observable_chat_account

	def __checkGeoCoordinates(self, latitude, longitude, elevation, category):
		'''	
		Manage of the geo coordinates (longitutide and latitude) list (self.LOCATION_lat_long_coordinate), to avoid duplications of Observables.
		: param latitude: The latitude to generate or retrieve (string).
		: param longitude: The longitude to generate or retrieve (string).
		: param elevation: The elevation to generate or retrieve (string).
		: param category: The category the geo coordinates refer to (string).
		: return: The UUID of the Location (string, UUID ref).
		'''			
		latitude = latitude.strip()
		longitude = longitude.strip()
		
		observable_location = None
		if latitude != '' and longitude != '':
			id_geo_loc = latitude + '@' + longitude
			if id_geo_loc in self.LOCATION_lat_long_coordinate.keys():
				observable_location = self.LOCATION_lat_long_coordinate[id_geo_loc]
			else:
				observable_location = self.__generateTraceLocationCoordinate(latitude, 
					longitude, elevation, category)
				self.LOCATION_lat_long_coordinate[id_geo_loc] = observable_location

		return observable_location

	def __checkSearchedItems(self, value):
		'''	
		Manage of the Searched Item (web search) date list (self.SEARCHED_ITEMvalue_date), to avoid duplications of Observables.
		: param value: The value of the searched item to generate or retrieve (string).
		: param category: The category the geo coordinates refer to (string).
		: return: False or the UUID of the date (string, UUID ref).
		'''		
		itemFound = False
		if value not in self.SEARCHED_ITEMvalue_date:			
			self.SEARCHED_ITEMvalue_date.append(value)
			itemFound = True

		return itemFound

	def __checkEmailAddress(self, address):
		'''	
		Manage of the Email address list (self.EMAILaddressUuid), to avoid duplications of Observables.
		: param address: The email address to generate or retrieve (string).
		: return: The Email address Observable (string, UUID ref).
		'''		
		if address in self.EMAILaddressUuid.keys():
			observable_email_address = self.EMAILaddressUuid.get(address)
		else:
			observable_email_address = self.__generateTraceEmailAccount(address)
			self.EMAILaddressUuid[address] = observable_email_address

		return  observable_email_address
	
	def __generateTraceDeviceEvent(self, event_id, event_timestamp, 
		event_type, event_text):
		'''	
		Generate the Device Event Observable.
		: param event_id: The ID of the event as it is extracted from the XML report (string).
		: param event_timestamp: The timestamp of the event (string).
		: param event_type: The type of the evnt (string).
		: param event_text: The description of the event (string).
		: return: The Event Observable (Observable).
		'''			
		event_timestamp = self.__cleanDate(event_timestamp)		
		event_text = self.__cleanJSONtext(event_text)
		
		observable = ObjectObservable()
		facet_event = Event(event_type=event_type, 
								event_text=event_text, created_time=event_timestamp)
		observable.append_facets(facet_event)
	
		self.bundle.append_to_uco_object(observable)
		return observable		
		
	def __generateTraceAppUsage(self, event_id, event_start_time, 
		event_end_time, event_type, event_text):
		'''	
		Generate the Application Usage Event Observable.
		: param event_id: The ID of the event as it is extracted from the XML report (string).
		: param event_start_time: The start time of the application usage (datetime).
		: param event_end_time: The end time of the application usage (datetime).
		: param event_type: The type of the evnt (string).
		: param event_text: The description of the event (string).
		: return: The Event Observable (Observable).
		'''			
		event_start_time = self.__cleanDate(event_start_time)		
		event_end_time = self.__cleanDate(event_end_time)		
		event_text = self.__cleanJSONtext(event_text)
		
		observable = ObjectObservable()

		#---	event_end_time is not included yet in the class FacetEvent
		facet_event = Event(event_type=event_type, 
								event_text=event_text, created_time=event_start_time)
		observable.append_facets(facet_event)
	
		self.bundle.append_to_uco_object(observable)
		return observable		

	def fillArrayWithEmpty(self, aInput, max):
		'''	
		Fill an array with empty values until the expcted len.
		: param aInput: The Array to check (list).
		: param max: The expoected Array length  (int).
		: return: The input Array with the expected length (list).
		'''			
		if len(aInput) < max:
			for i in range(len(aInput), max):						
				aInput.append('')

	def fillChatThread(self, chatThread, CHATid, CHATsender, CHATreceiver,
		CHATdateTimeSent, CHATdateTimeReceived, CHATmessage, CHATmessageStatus,
		CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod, CALLphoneNumber):
		'''	
		Manage Thread of Chats.
		: param ...: All Chat data ().
		: return: None.
		'''		
		for i, chat_sender in enumerate(CHATsender):
			if chat_sender.lower().find('local user') > -1:
				chat_sender = CALLphoneNumber

			if CHATreceiver[i].lower().find('local user') > -1:
				CHATreceiver[i] = CALLphoneNumber
			
			chatFound = False
			idx = -1
			for j, chat_thread in enumerate(chatThread):
				if (chat_sender in chat_thread and
					  CHATreceiver[i] in chat_thread and 
					  CHATapplication[i] in chat_thread):
					idx = j
					chatFound = True
					break
			
			if chatFound:		
				self.CHATids[idx].append(CHATid[i])
				self.CHATsenders[idx].append(chat_sender)
				self.CHATreceivers[idx].append(CHATreceiver[i])
				self.CHATdateTimeSents[idx].append(CHATdateTimeSent[i])
				self.CHATdateTimeReceiveds[idx].append(CHATdateTimeReceived[i])
				self.CHATmessages[idx].append(CHATmessage[i])
				self.CHATmessageStatuses[idx].append(CHATmessageStatus[i])
				self.CHATsources[idx].append(CHATsource[i])
				self.CHATlocations[idx].append(CHATlocation[i])
				self.CHATrecoveryMethods[idx].append(CHATrecoveryMethod[i])
				self.CHATapplications[idx].append(CHATapplication[i])
			else:
				idx = len(chatThread) - 1
				self.CHATids.append([CHATid[i]])
				self.CHATsenders.append([chat_sender])
				self.CHATreceivers.append([CHATreceiver[i]])
				self.CHATdateTimeSents.append([CHATdateTimeSent[i]])
				self.CHATdateTimeReceiveds.append([CHATdateTimeReceived[i]])
				self.CHATmessages.append([CHATmessage[i]])
				self.CHATmessageStatuses.append([CHATmessageStatus[i]])
				self.CHATsources.append([CHATsource[i]])
				self.CHATlocations.append([CHATlocation[i]])
				self.CHATrecoveryMethods.append([CHATrecoveryMethod[i]])
				self.CHATapplications.append([CHATapplication[i]])
				chatThread.append(chat_sender + '#' + CHATreceiver[i] + '#' + CHATapplication[i])

	def __cleanDate(self, initialDate):
		'''	
		Clean date format to be like yyyy-mm-ddThh:mm:ss+HH:MM (last value after + indicates the difference of time zone ).
		: param initialDate: The original date to clean (list).
		: return: The formatted date (string).
		'''		
		aMonths = {
			'Jan': '01',
			'Feb': '02',
			'Mar': '03',
			'Apr': '04',
			'May': '05',
			'Jun': '06',
			'Jul': '07',
			'Aug': '08',
			'Sep': '09',
			'Oct': '10',
			'Nov': '11',
			'Dec': '12'
		}
		
		initialDate = initialDate.strip()

		if 	initialDate == '':
			return None

#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx)
#		the character "/" is not allowed
		initialDate = initialDate.replace("/", "-")
		initialDate = initialDate.replace(' ', 'T', 1)
		initialDate = initialDate.replace('UTC', '')						
		initialDate = initialDate.replace('AM', '')
		initialDate = initialDate.replace('PM', '')
		startTZ = initialDate.find("+")
		if startTZ > -1:
			initialDate = initialDate[:startTZ]		
		
		for k,v in aMonths.items():
			if initialDate.find(k) > -1:
				initialDate = initialDate.replace(k, v)
				break
		
		firstChars = initialDate[:10]
		firstChars = firstChars.replace(".", "-")
		initialDate = firstChars + initialDate[10:]

		yearPattern = '\-[0-9][0-9]T'	# year with two digits
		resPattern = re.search(yearPattern, initialDate)
		if resPattern:
			if re.search('^[0-9]{4}', initialDate):
				pass
			else:
				initialDate = re.sub('-([0-9][0-9])T', '-20\g<1>T', initialDate)
				initialDate = str(initialDate[6:10]) + initialDate[2:6] + initialDate[0:2] + \
					initialDate[10:] 

		yearPattern = '\-\d{4}T'	# year with 4 digits in Italian format
		resPattern = re.search(yearPattern, initialDate)
		if resPattern:
			initialDate = str(initialDate[6:10]) + initialDate[2:6] + initialDate[0:2] + \
				initialDate[10:] 		

		if re.search('(\d{2}:\d{2}:\d{2})$', initialDate):
			pass
		else:
			initialDate = re.sub('(\d{2}:\d{2})$', '\g<1>:00', initialDate)

		if re.search('T(\d):', initialDate):
			initialDate = re.sub('T(\d):', 'T0\g<1>:', initialDate)

		if re.search(':(\d):', initialDate):
			initialDate = re.sub(':(\d):', ':0\g<1>:', initialDate)

		if re.search(':(\d)$', initialDate):
			initialDate = re.sub(':(\d)$', ':0\g<1>', initialDate)

		if re.search('T\d{2}:\d{2}:\d{2}(.+)$', initialDate):
			initialDate = re.sub('(T\d{2}:\d{2}:\d{2})(.+)$', '\g<1>', initialDate)
			
		if initialDate.find('+') > -1:
			# some dirty characters may be wrongly included in the date
			initialDate = initialDate[0:30]
			initialDate = datetime.strptime(initialDate, '%Y-%m-%dT%H:%M:%S.%f%z')
		else:
			# some dirty characters may be wrongly included in the date
			initialDate = initialDate[0:19]
			initialDate = datetime.strptime(initialDate, '%Y-%m-%dT%H:%M:%S')
			
		return initialDate

	def ___generateContextAxiom(self, axiomVersion, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerName, 
		deviceBluetoothAddress, deviceId, devicePhoneModel, 
		deviceOsType, deviceOsVersion, devicePhoneVendor, 
		deviceMacAddress, deviceIccid, deviceImsi, deviceImei, 
		imagePath, imageSize, imageMetadataHashSHA, imageMetadataHashMD5):

		# generate Trace/Tool for the Acquisition and Extraction Actions
		object_tool = self.__generateTraceTool('AXIOM Process', 'Acquisition', 
			'MAGNET', axiomVersion, []);
		
		# generate Trace/Identity for the Performer, D.F. Expert, of the Actions
		object_identity = self.__generateTraceIdentity(examinerName, '', '')
		
		# generate Trace/Role for the Performer, D.F. Expert, of the Actions
		object_role = self.__generateTraceRole('Digital Forensic Expert')
		
		# generate Trace/Relation between the above Role and the Identity traces
		self.__generateTraceRelation(object_identity, object_role, 
			'has_role', '', '', None, None);		
		
#---	The XML report contains the attribute DeviceInfoExtractionStartDateTime 
#		that is the Acquisition Start Date and similarly for the Acquisition
#		End Date, The CreationReportDate is the Start and the End of the Extraction 
#		Forensic Action.

#---	Generate Trace/Provenance_Record for the mobile device
#
		object_device_list = []
		object_device_list.append(self.observable_device)
		object_provenance_device = self.__generateTraceProvencance(object_device_list, '') 
		
#---	generate Trace/File for each file extracted by the Acuisition action
#		idFileList contains the uuid of these files and it is used for
#		creating the Provenance_Record of the Result/Output of the Acquisition action. 
		object_files_acquisition = []
		for i, img_path in enumerate(imagePath):
			if imageMetadataHashSHA[i].strip() == '':
				object_file_acquisition = self.__generateTraceFile(img_path, 
				imageSize[i], 'MD5', imageMetadataHashMD5[i], 'Uncategorized', '', '', '', '',
				'', '', '', '', '', '', '', '', '', '', '')  
				 
			else:
				object_file_acquisition = self.__generateTraceFile(img_path, 
				imageSize[i], 'SHA256', imageMetadataHashSHA[i], 'Uncategorized', 
				'', '', '', '', '', '', '', '', '', '', '', '', '', '', '') 				
			
			object_files_acquisition.append(object_file_acquisition)  	
		

		object_provenance_acquisition_files = \
			self.__generateTraceProvencance(object_files_acquisition, '')

		object_provenance_acquisition_files_list = []
		object_provenance_acquisition_files_list.append(object_provenance_acquisition_files)
		
		self.__generateTraceInvestigativeAction('acquisition', 
			'Forensic mobile device acquisition', deviceExtractionStartTime, 
			deviceAcquisitionEndTime, object_tool, '', object_identity, 
			object_provenance_device, object_provenance_acquisition_files_list);

		object_files_extraction = []
		for uuidFile in self.FILEuuid.values(): 
			object_files_extraction.append(uuidFile)

		object_provenance_extraction_files = \
		self.__generateTraceProvencance(object_files_extraction, 'Extraction',
			'', deviceAcquisitionEndTime);
        
		object_provenance_extraction_files_list = []
		object_provenance_extraction_files_list.append(object_provenance_extraction_files)

		self.__generateTraceInvestigativeAction('extraction', 
			'Forensic mobile device extraction', deviceAcquisitionEndTime,
			deviceAcquisitionEndTime, object_tool, '', object_identity,
			object_provenance_acquisition_files, object_provenance_extraction_files_list);
		
	def __generateChainOfEvidence(self, source, location, uuidTrace):
		filePath = ''
		charSeparator = '/'
		separator = source.find(charSeparator)
		if separator > - 1:
			filePath = source[separator:]
		else:
			charSeparator = '\\'
			separator = source.find(charSeparator)
			if separator > - 1: 
				filePath = source[separator:]
			else:
				filePath = source
				fileName = source
				fileExt = ''			

		if separator > - 1:
			fileName = filePath.split(charSeparator)[-1]
			fileExt = fileName[fileName.rfind('.') + 1:]

		openPar = source.find('(')
		closePar = source.find(')')
		fileSysType = source[openPar + 1: closePar]
		
		filePath = filePath.replace('"', "").replace('\n', '').replace('\r', '')
		filePath = filePath.replace('\t', " ").replace("\\", "/")

		location = self.__cleanJSONtext(location)

		uuidFile = self.__generateTraceFileCoE(filePath, fileName, fileExt, fileSysType,
			location)

		self.FILEuuid[uuidFile.get_id()] = uuidTrace		
		self.__generateTraceRelation(uuidTrace, uuidFile, 'Contained_Within', 
				location, '00001', '', '');
		return None


	def __generateTraceApplicationAccount(self, name, identifier, id_app):		
		'''
		Generate the Application Account Observable.
		: param name: Te name pf the Application Account (string).
		: param identifier: The identifier of the Application Account (string)
		: param id_app: The id of the Application Account
		'''
		name = self.__cleanJSONtext(name)
		identifier = self.__cleanJSONtext(identifier)

		observable = ObjectObservable()
		facet_account = Account(identifier)
		facet_app_account = ApplicationAccount(application=id_app)		
		facet_digital_account = DigitalAccount(display_name=name)    	
		
		observable.append_facets(facet_account, facet_app_account, facet_digital_account)
		
		self.bundle.append_to_uco_object(observable)		
		return observable		

	
	def __generateTraceAppName(self, app_name):
		'''
		Generate the uco-observable:ApplicationFacet.
		: parma name: The name of the Application.
		: return: The Observable containing the Application Facet.
		'''		
		observable = ObjectObservable()
		facet_application = Application(app_name=app_name)
		observable.append_facets(facet_application)
		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceChat(self, body, id_app, time_stamp, phone_uuid_from,
		phone_uuid_to, status, outcome, direction, message_type, attachmentNames, 
		attachmentUrls):
		'''	
		Generate the uco-observable:MessageFacet Observable.
		: param body: The body of the message (string).
		: param id_app: The identifier of the application used to generate the message (string).
		: param time_stamp: The timestamp of the message (datetime).
		: param status: The status of the message, Parsed or Carved (string).
		: param outcome: The oucome of the message (string).
		: param direction: The direction of the message, outgoing or incoming (string).
		: param message_type: The type of the message (string).
		: param attachmentNames: The name of the attachments (list).
		: param attachmentUrls: The URL of the attachments (list).
		: return: The Observable containing all the  (Observable).
		'''			

		# already in datetime format - time_stamp = self.__cleanDate(time_stamp)		
		body = self.__cleanJSONtext(body)
		
		observable_message = ObjectObservable(object_class="uco-observable:Message")
	
		facet_message = Message(msg_to=phone_uuid_to, 
									msg_from=phone_uuid_from, message_text=body, sent_time=time_stamp,
				application=id_app, message_type=message_type)
		observable_message.append_facets(facet_message)
	
		self.bundle.append_to_uco_object(observable_message)
						
	
#---	each Message, within a specific Chat can have more than one attachment,
# 		both the Filenames and the Urls of the Attachment are separated by
# 		a triple hash tag # 		
		listFileNames = attachmentNames.split('###');
		listFileUrls = attachmentUrls.split('###');
		nName = len(listFileNames)
		nUrl = len(listFileUrls)
		if nName > nUrl:
			for i in range(nName - nUrl):
				listFileUrls.append('')
		if nName < nUrl:
			for i in range(nUrl - nName):
				listFileNames.append('')

		for i, list_file_name in enumerate(listFileNames):
			if (list_file_name.strip() != '') or \
			 	(listFileUrls[i].strip() != ''):
#---	listFileUrls[i] will be stored in the property path of the FILE trace			 	
				observable_file = self.__generateTraceFile(list_file_name, 
				'', '', '', '', '', '', '', listFileUrls[i],
				'', '', '', '', '', '', '', '')
				
				self.__generateTraceRelation(observable_file, observable_message, 'Attached_To', 
				'', '', '', '')
		return observable_message

	
	def __generateTraceDeviceDisk(self, size, partitions_ref):
		'''
		Generate uco-observable:DiskFacet.
		: param size: The size of disk (string).
		: param partitions_ref: The UUID of each partition included in the Disk (list)
		: return: The Observable containing the Facet items.
		'''
		observable = ObjectObservable()
		size=int(size)
		facet_disk = Disk(disk_type="Fixed", size=size, 
			partition=partitions_ref)
		
		observable.append_facets(facet_disk)

		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceDiskPartition(self, serial_number, type, total_space, space_left, 
		space_used, offset):
		'''
		Generate uco-observable:DiskPartitionFacet.
		: param serial_number: The serial number of the partition (string).
		: param type: The type of the partition (string)
		: param total_space: The total space of the partition (string)
		: param space_left: The total space free left of the partition (string)
		: param space_used: The total space used of the partition (string)
		: param offset: The offset relted to the beginning of the disk (string)
		: return: The Observable containing the Facet items.
		'''				
		observable = ObjectObservable()
		total_space=int(total_space)
		space_left=int(space_left)
		space_used=int(space_used)
		offset=int(offset)
		facet_disk_partition = DiskPartition(serial_number=serial_number, 
			partition_type=type, total_space=total_space, space_left=space_left, space_used=space_used, 
			offset=offset)   

		observable.append_facets(facet_disk_partition)
		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceDeviceMobile(self, deviceId, deviceIMSI, deviceBluetoothAddress, 		
		deviceBluetoothName, deviceIMEI, deviceSN, deviceName, 
		deviceModel, deviceICCID, deviceOSVersion):
		'''
		Generate uco-observable:DeviceFacet and uco.observbale:MobileDeviceFacet.
		: param deviceId: The id of the device (string).
		: param deviceIMSI: The IMSI of the mobile device (string)
		: param deviceBluetoothAddress: The bluetooth address of the mobile device (string)
		: param deviceBluetoothName: The name of the bluetooth device (string)
		: param deviceIMEI: The IMEI of the mobile device (string)
		: param deviceSN: The serial number of the mobile device (string)
		: param deviceName: The name of the mobile device (string)
		: param deviceModel: The model of the mobile device (string)
		: param deviceICCID: The ICCID of the mobile device (string)
		: param deviceOSVersion: The operating system version of the mobile device (string)
		: return: The Observable containing the Facet items.
		'''			
		observable = ObjectObservable()
		facet_device = Device(device_type="Mobile phone", model=deviceModel, serial=deviceSN)	
		facet_mobile = MobileDevice(IMSI=deviceIMSI, ICCID=deviceICCID, IMEI=deviceIMEI)
		facet_operating_system = OperatingSystem(os_version=deviceOSVersion)
		facet_bluetooth = BluetoothAddress(name=deviceBluetoothName, address=deviceBluetoothAddress)
		observable.append_facets(facet_device, facet_mobile, facet_operating_system, facet_bluetooth)
    	
		self.bundle.append_to_uco_object(observable)				
		return observable

	def __generateTraceEmail(self, EMAILid, EMAILstatus, EMAILsource, EMAILlocation,
		EMAILidentifierFROM, EMAILidentifiersTO, EMAILidentifiersCC, 
		EMAILidentifiersBCC, EMAILbody, EMAILsubject, EMAILtimeStamp, 
		EMAILattachmentsFilename):
		'''
		Generate uco-observable:EmailMessageFacet and uco.observbale:EmailMessageFacet.
		: param EMAILid: The id of the email message (string).
		: param EMAILstatus: The status of the email message (string).
		: param EMAILsource: The application name of the email message (string).
		: param EMAILlocation: The location name of the email message (string).
		: param EMAILidentifierFROM: The FROM identifier of the email message (string).
		: param EMAILidentifiersTO: The TO identifiers of the email message (list).
		: param EMAILidentifiersCC: The CC identifiers of the email message (list).
		: param EMAILidentifiersBCC: The BCC identifiers of the email message (list).
		: param EMAILbody: The body of the email message (string).
		: param EMAILsubject: The subject of the email message (string).
		: param EMAILtimeStamp: The timestamp of the email message (string).
		: param EMAILattachmentsFilename: The attachments of the email message (list).
		: return: The Observable containing the Facet items.
		'''				
		address_from = re.search(self.EMAILregex, EMAILidentifierFROM)
		if address_from:
			idFROM = self.__checkEmailAddress(address_from.group().strip())
		else:
			idFROM = self.__checkEmailAddress(EMAILidentifierFROM.strip())
		
		itemsTO = ''		
		EMAILtoList = re.findall(self.EMAILregex, EMAILidentifiersTO)
		email_distinct = set(EMAILtoList)
		itemsTO = []
		for item in email_distinct:			
			if item.strip() != '':				
				observable_to_address = self.__checkEmailAddress(item.strip().lower())				
				itemsTO.append(observable_to_address)
		
		itemsCC = []
		EMAILtoList = re.findall(self.EMAILregex, EMAILidentifiersCC)
		email_distinct = set(EMAILtoList)
		for item in email_distinct:
			if item.strip() != '':
				observable_cc_address = self.__checkEmailAddress(item.strip().lower())
				itemsCC.append(observable_cc_address)
		
		itemsBCC = []
		EMAILtoList = re.findall(self.EMAILregex, EMAILidentifiersBCC)
		email_distinct = set(EMAILtoList)
		for item in email_distinct:
			if item.strip() != '':
				observable_bcc_address = self.__checkEmailAddress(item.strip().lower())
				itemsBCC.append(observable_bcc_address)


		body = self.__cleanJSONtext(EMAILbody)
		subject = self.__cleanJSONtext(EMAILsubject)
#--- Replace all characters different from number, space or character with nothing
		subject = re.sub('[^0-9A-Za-z ]','', subject)

#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx
#		the character "/" is not allowed
		EMAILtimeStamp = self.__cleanDate(EMAILtimeStamp)

		observable_email = ObjectObservable()		
		facet_email_message = EmailMessage(msg_to=itemsTO, 
			msg_from=idFROM, cc=itemsCC, bcc=itemsBCC, subject=subject, body=body, 
            sent_time=EMAILtimeStamp, allocation_status=EMAILstatus)


		observable_email.append_facets(facet_email_message)
		self.bundle.append_to_uco_object(observable_email)

		self.__generateChainOfEvidence(EMAILsource, EMAILlocation, observable_email)		

		email_attachment_list = EMAILattachmentsFilename.split(',')
		for i, email_file in enumerate(email_attachment_list):
			if email_file.strip() != '':
				observable_file = self.__generateTraceFile(email_file, 
				'', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '')
				self.__generateTraceRelation(observable_file, observable_email, 
					'Attached_To', '', '', '', '')
		
		return observable_email

	def __generateTraceEmailAccount(self, address):
		'''
		Generate uco-observable:EmailAccountFacet and uco.observbale:EmailMessageFacet.
		: param address: The email address (string).
		: return: The Observable containing the Facet items.
		'''			
		observable_email_address = self.__generateTraceEmailAddress(address)
		observable_email_account = ObjectObservable()
		facet_email_account = EmailAccount(observable_email_address)
		facet_account = Account("")
		observable_email_account.append_facets(facet_account, facet_email_account)
		
		self.bundle.append_to_uco_object(observable_email_account)		
		return observable_email_account


	def __generateTraceEmailAddress(self, address):
		'''
		Generate uco-observable:EmailAddressFacet and uco.observbale:EmailMessageFacet.
		: param address: The email address (string).
		: return: The Observable containing the Facet items.
		'''			
		address = self.__cleanJSONtext(address)
		observable = ObjectObservable()
		facet_email_address = EmailAddress(email_address_value=address)
		observable.append_facets(facet_email_address)
		
		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceFile(self, FILEpath, FILEsize, FILEhashType, 
		FILEHashValue, FILETag, FILEtimeC, FILEtimeM, FILEtimeA, FILElocalPath, 
		FILEextension, FILEexifMake, FILEexifModel, FILEexifLatitudeRef, FILEexifLatitude, 
		FILEexifLongitudeRef, FILEexifLongitude, FILEexifAltitude):
		'''
		Generate uco-observable:FileFacet, EXIFFacet and ContentDataFacet.
		: param address: The email address (string).
		: return: The Observable containing the Facet items.
		'''			
		observable_file = ObjectObservable()
		head, tail = os.path.split(FILEpath)
		tail = self.__cleanJSONtext(tail)

		path = FILEpath.replace('\\', '/')
		path = path.replace('"', "'")

		dotPos = tail.find('.')
		sExt = ''
		if dotPos > -1:
			sExt = tail[dotPos:]		

		if FILEhashType.upper() == '_NOT_PROVIDED_':
			FILEhashType = 'MD5'		

		if  FILEsize.strip() != '0' and FILEHashValue.upper() != "N/A":	
			facet_content = ContentData(hash_method=FILEhashType, hash_value=FILEHashValue)
			observable_file.append_facets(facet_content)

		if FILEsize.strip() == '':
			FILEsize = int(AXIOMtoJSON.INT)
		else:
			FILEsize = int(FILEsize)

		localPath = FILEpath.replace('"', "").replace('\n', '').replace('\r', '')
		localPath = localPath.replace("\\", "/")
		
		FILEtimeC = self.__cleanDate(FILEtimeC)
		#FILEtimeC = self.__convert_str_to_datetime(FILEtimeC)
		FILEtimeM = self.__cleanDate(FILEtimeM)
		#FILEtimeM = self.__convert_str_to_datetime(FILEtimeM)
		FILEtimeA = self.__cleanDate(FILEtimeA)
		#FILEtimeA = self.__convert_str_to_datetime(FILEtimeA)
		
		if FILEexifLatitude.strip() != '':	
			FILEexifLatitude = FILEexifLatitude.strip('" ')			
			FILEexifLongitude = FILEexifLongitude.strip('" ')
			FILEexifLatitude = FILEexifLatitude.replace('Â°', ', ').replace("'", ', ')
			FILEexifLongitude = FILEexifLongitude.replace('Â°', ', ').replace("'", ', ')
			FILEexifAltitude = FILEexifAltitude.strip('" ')
			exif_data = {"Make":FILEexifMake, 
				"Model":FILEexifModel, "LatitudeRef":FILEexifLatitudeRef,
				"Latitude":FILEexifLatitude, "LongitudeRef":FILEexifLongitudeRef,
				"Longitude":FILEexifLongitude, "Altitude":FILEexifAltitude}		
			facet_exif = EXIF(**exif_data)
			observable_file.append_facets(facet_exif)

		#facet_file = File(tag=[FILETag], file_name=tail,
		facet_file = File(tag=FILETag, file_name=tail, 
			file_path=path, file_local_path=localPath, file_extension=sExt,
                 size_bytes=FILEsize, accessed_time=FILEtimeA, created_time=FILEtimeC, 
                 modified_time=FILEtimeM)
		observable_file.append_facets(facet_file) 

		self.bundle.append_to_uco_object(observable_file)
		return observable_file

	def __generateTraceFileCoE(self, FILEpath, FILEname, FILEext, FILEsysType, 
		FILElocation):
		'''
		FileFacet for the Chain of Evidence, the data are FileName, FilePath, FileExt, FileSystemType
		'''		
		FILEsysType = self.__cleanJSONtext(FILEsysType)

		observable_file = ObjectObservable()

		#facet_file = File(tag=["Binary"], file_name=FILEname,
		facet_file = File(tag="Binary", file_name=FILEname, 
			file_path=FILEpath, file_extension=FILEext)
		observable_file.append_facets(facet_file) 

		self.bundle.append_to_uco_object(observable_file)
		return observable_file

	def __generateTraceIdentity(self, name, familyName, birthDate):
		'''
		Generate uco-observable:SimpleNameFacet.
		: param address: The email address (string).
		: return: The Observable containing the Facet item.
		'''			
		if birthDate:
			birthDate = self.__cleanDate(birthDate)
	
		observable = ObjectObservable(object_class="uco-identity:Person")
		facet_identity = SimpleName(given_name=name, 
										family_name=familyName)
		observable.append_facets(facet_identity)
		self.bundle.append_to_uco_object(observable)
		return observable		

	def __generateTraceLocationDevice(self, loc_id, loc_long, loc_lat, loc_category):
		'''
		Generate uco-location:LatLongCoordinatesFacet by calling the __checkGeoCoordinates to avoid duplications.
		: param loc_id: the id of the geo location (string)
		: param loc_long: the longitude of the geo location (string)
		: param loc_lat: the latitude of the geo location (string)
		: param loc_category: the category of the geo location (string)
		: return: The Observable containing the Facet items.
		'''
		observable_location = self.__checkGeoCoordinates(loc_lat, loc_long, '', loc_category)
		return observable_location

	def writePhoneAccountFromContacts(self, CONTACTname, CONTACTphoneNums):
		'''
		Generate uco-observable:phoneNumber by calling the generateTracePhoneAccount to avoid duplications.
		: param CONTACTname: The name of the phone contact (string)
		: param CONTACTphoneNums: The phone numbers associtated to the name contact (list)
		: return: None.
		'''		
		for i, contact_name in enumerate(CONTACTname):
			CONTACTphoneNums[i] = CONTACTphoneNums[i].replace(' ', '')
			if CONTACTphoneNums[i] not in self.phoneNumberList:					
				self.phoneNumberList.append(CONTACTphoneNums[i])
				self.phoneNameList.append(contact_name)
				mobileOperator = ""
				observable_phone = self.generateTracePhoneAccount(mobileOperator, contact_name, 
					CONTACTphoneNums[i])
				self.phoneUuidList.append(observable_phone)		

	def generateTracePhoneAccount(self, source, name, phone_num):
		'''
		Generate uco-observable:phoneNumber.
		: param name: The name of the phone contact (string)
		: param phone_num: The phone number associtated to the name contact (string)
		: return: The Observable containing the Facet items.
		'''			
		observable_identity = None
		if source != "":
			observable_identity = ObjectObservable(object_class="uco-identity:Organization")
			facet_identity = SimpleName(given_name="-" + source)
			observable_identity.append_facets(facet_identity)
			self.bundle.append_to_uco_object(observable_identity)
			
		name = self.__cleanJSONtext(name)
		
		observable = ObjectObservable()
		facet_phone_account = PhoneAccount(phone_number=phone_num, account_name=name)
		facet_account = Account("", is_active=True, issuer_id=observable_identity)
		observable.append_facets(facet_account, facet_phone_account)

		self.bundle.append_to_uco_object(observable)
		return observable
				
	def __generateTraceSearchedItem(self, search_id, search_value, search_timestamp, 
		search_app):
		'''
		Generate drafting:SearchedItemFacet.
		: param search_id: The id of the searched item (string)
		: param search_value: The value of the searched item (string)
		: param search_timestamp: The timestamp when the searched item was launched (datetime)
		: param search_app: The application, ususally a web browser, has been used to lanuch the search (datetime)
		: return: The Observable containing the Facet items.
		'''		
		search_value = self.__cleanJSONtext(search_value)
		if search_value.strip() == '':
			return None							

		if not self.__checkSearchedItems(search_value + search_timestamp):
			return None

		search_timestamp = self.__cleanDate(search_timestamp)
		observable_app = self.__checkAppName(search_app)

		observable = ObjectObservable()

		facet_searched_item = SearchedItem(search_value=search_value, application=observable_app, 
		search_launch_time=search_timestamp)
		observable.append_facets(facet_searched_item)
		
		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceInvestigativeAction(self, name, description, start_time, end_time, 
		object_instrument, str_location, object_performer, object_input, object_list_result):
		
		start_time = self.__cleanDate(start_time)
		end_time = self.__cleanDate(end_time)
	
		object_location = self.__generateTraceLocationCoordinate(str_location)
		investigation = InvestigativeAction(
				name=description, start_time=start_time, end_time=end_time,
				performer=object_performer, instrument=object_instrument, 
				location=object_location, objects=object_input, results=object_list_result)
	
		#investigation.append_facets(facet_action_ref)
		self.bundle.append_to_uco_object(investigation)		

	def __generateTraceCall(self, direction, start_time, idFROM, idTO, 
								duration, status, outcome):
		'''
		Generate uco-observable:CallFacet.
		: param direction: The direction of the call, incoming or outgoing (string)
		: param start_time: The start time of the call (string)
		: param idFROM: The caller of the call (Observable)
		: param idTO: The recipient of the call (Observable)
		: param duration: The duration of the call (string)
		: param outcome: The outocome of the call (string)
		: return: The Observable containing the Facet items.
		'''			
		nTime = 0
		if duration != '':
			aTime = duration.split(":")
			if len(aTime) == 3:
				nTime = aTime[0]*3600 + aTime[1]*60 + aTime[2] 
			if len(aTime) == 2:
				nTime = aTime[0]*60 + aTime[1] 
			if len(aTime) == 1:
				nTime = aTime[0] 
		duration = str(nTime)
		duration = duration.lstrip('0')
		if duration == "":
			duration = "0"

		duration = int(duration)
		start_time = self.__cleanDate(start_time)
		#start_time = self.__convert_str_to_datetime(start_time)
		observable_app = self.__checkAppName("Native")
	
		observable = ObjectObservable()
		
		facet_phone_call = Call(call_type=direction,
			start_time=start_time, application=observable_app, call_from=idFROM, 
			call_to=idTO, call_duration=duration, allocation_status=status)		
		observable.append_facets(facet_phone_call)

		self.bundle.append_to_uco_object(observable)
		return observable
	
	def __generateTracePhoneOwner(self, source, name, phone_num):
		'''
		Generate uco-observable:PhoneAccountFacet and the PhoneAccountFacet.
		: param source: The application used to do the call (Observable)
		: param name: The name of the phone account (string)
		: param phone_num: The number of the phone (string)
		: return: The Observable containing the Facet items.
		'''		
		observable = ObjectObservable()
		facet_account = Account("_")
		name += ' (Owner)'
		facet_phone_account = PhoneAccount(phone_number=phone_num, account_name=name)

		observable.append_facets(facet_account, facet_phone_account)
		self.bundle.append_to_uco_object(observable)
		
		self.object_phone_owner = observable
		self.phoneNumberList.append(phone_num)
		self.phoneUuidList.append(self.object_phone_owner)		
		return observable

	def __generateTraceProvencance(self, uco_core_objects, exhibitNumber):
		'''
		Generate case-investigation:ProvenanceRecord.
		: param source: The application used to do the call (Observable)
		: param name: The name of the phone account (string)
		: param phone_num: The number of the phone (string)
		: return: The Observable containing the Facet items.
		'''
		case_provenance = ProvenanceRecord(exhibit_number=exhibitNumber, 
											   uco_core_objects=uco_core_objects)
	
		self.bundle.append_to_uco_object(case_provenance)
		return case_provenance		
	
	def __generateStringRelation(self, source, target, relation, table, offset,
		start_date, end_date):		
		
		if isinstance(start_date, str):
			start_date = self.__cleanDate(start_date)
			
		if isinstance(end_date, str):
			end_date = self.__cleanDate(end_date)
	
		observable_relationship = Relationship(source=source, target=target, 
			start_time=start_date, end_time=end_date, kind_of_relationship=relation, directional=True)
		self.bundle.append_to_uco_object(observable_relationship)
	
		return observable_relationship

	def __generateTraceRelation(self, source, target, relation, table, offset,
		start_date, end_date):
		
		if isinstance(start_date, str):
			start_date = self.__cleanDate(start_date)

		if isinstance(end_date, str):
			end_date = self.__cleanDate(end_date)

		observable_relationship = Relationship(source=source, target=target, 
											   start_time=start_date, end_time=end_date, kind_of_relationship=relation, directional=True)
		self.bundle.append_to_uco_object(observable_relationship)

		return observable_relationship

	def __generateTraceRole(self, role):
		'''
		Generate uco-role:Role.
		: param role: The role (string)
		: return: The Observable Role.
		'''		
		object_role = Role(name=role)

		self.bundle.append_to_uco_object(object_role)
		return object_role

	def __generateThreadMessages(self, chatTraceId, chat_messages, chat_participants):
		observable = ObjectObservable()		
		facet_message_thread = Messagethread(messages=chat_messages, 
			participants=chat_participants, display_name=str(chatTraceId))		
		observable.append_facets(facet_message_thread)
		self.bundle.append_to_uco_object(observable)
		return observable
	
	def __generateTraceTool(self, name, type, vendor, version, confList):
		observable_identity = ObjectObservable(object_class="uco-identity:Person")
		facet_identity = SimpleName(family_name=name)
		observable_identity.append_facets(facet_identity)
		self.bundle.append_to_uco_object(observable_identity)		
		
		object_tool = Tool(name, version, tool_type=type, tool_creator=observable_identity)
		
		self.bundle.append_to_uco_object(object_tool)
		return object_tool

	def __generateTraceURL (self, URL_Value):
		'''
		Generate uco-observable:URLFacet.
		: param URL_Value: The URL address (string)
		: return: The Observable URLFacet.
		'''			
		URL_Value = self.__cleanJSONtext(URL_Value)
		
		if  URL_Value in self.UrlList.keys(): 
			observable_url = self.UrlList.get(URL_Value)
		else:			
			observable_url = ObjectObservable()
			facet_url = Url(url_address=URL_Value)			
			observable_url.append_facets(facet_url)
			self.bundle.append_to_uco_object(observable_url)
			self.UrlList[URL_Value] = observable_url
					
		return observable_url


	def __generateTraceWebPages(self, WEB_PAGEid, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGElastVisited,
				WEBsource, WEBlocation, WEBrecoveryMethod):

		WEB_PAGElastVisited = self.__cleanDate(WEB_PAGElastVisited)
		
		observable_app = self.__checkAppName(WEB_PAGEsource.strip())
		observable_url = self.__generateTraceURL(WEB_PAGEurl)

		if WEB_PAGEvisitCount.strip() == '':
			WEB_PAGEvisitCount = 0
		
		observable = ObjectObservable()
		facet_url_history_entry = UrlHistoryEntry(
			last_visit=WEB_PAGElastVisited, url=observable_url, page_title=WEB_PAGEtitle, 
			visit_count=WEB_PAGEvisitCount, browser=observable_app)			
		observable.append_facets(facet_url_history_entry)
	
		self.bundle.append_to_uco_object(observable)		

		self.__generateChainOfEvidence(WEBsource, WEBlocation, observable)

	def __generateTraceCellTower(self, cell_id, cell_mcc, cell_mnc, cell_lac, 
		cell_cid, cell_longitude, cell_latitude, cell_timeStamp):
		'''
		Generate uco-observable:CellSiteFacet.
		: param cell_id: The identifier of the Cellsite (Celltower) provided within the XML report (string)
		: param cell_mcc: The Mobile Country Code of the Cellsite (string)
		: param cell_mnc: TheMobile Network Code of the Cellsite (string)
		: param cell_lac: The Location Area Code of the Cellsite (string)
		: param cell_cid: The Cell ID, used to identify each Base transceiver station (string)
		: param cell_longitude: The Longitude of the the Cellsite (string)
		: param cell_latitude: The Latitude of the the Cellsite (string)
		: param cell_timeStamp: The timestamp of the connection between the mobile device and the Cellsite (string)
		: return: The Observable containing the Facet items.
		'''		
		cell_timeStamp = self.__cleanDate(cell_timeStamp)

		observable_location = self.__checkGeoCoordinates(cell_latitude, cell_longitude,
			 '', 'Cell Tower')
		
		if observable_location is not None:
			cell_id = cell_mcc.strip() + '@' + cell_mnc.strip() +'@' + \
				cell_lac.strip() + '@' + cell_cid.strip()			
	#---	identifier of the Cell Tower cannot be empty
			if cell_id != '@@@':
				if cell_id in self.CELL_TOWER_gsm.keys():		
					return self.CELL_TOWER_gsm.get(cell_id)
				else:
					observable_cell_site = ObjectObservable()
					facet_cell_site = CellSite(country_code=cell_mcc, 
						network_code=cell_mnc, area_code=cell_lac, site_id=cell_cid)
					observable_cell_site.append_facets(facet_cell_site)
					self.bundle.append_to_uco_object(observable_cell_site)
				
					self.CELL_TOWER_gsm[cell_id] = observable_cell_site
				
					observable_relationship = Relationship(observable_cell_site, observable_location, 
						start_time=cell_timeStamp, kind_of_relationship="Located_At", directional=True)
					self.bundle.append_to_uco_object(observable_relationship)		
					return observable_cell_site					
			else:
				return None

	def __generateTraceCookie(self, cookie_item_id, cookie_source,
				cookie_name, cookie_value, cookie_domain, cookie_creation_time, 
				cookie_last_accessed_time, cookie_expiry):
		'''
		Generate uco-observable:BrowserCookieFacet.
		: param cookie_item_id: The identifier of the Cookie provided within the XML report (string)
		: param cookie_source: The application generating the cookie (string)
		: param cookie_name: The name of the cookie (string)
		: param cookie_value: The value of the cookie (string)
		: param cookie_domain: The domain of the cookie (string)
		: param cookie_creation_time: The creration time of the cookie (string)
		: param cookie_last_accessed_time: The lastt accessed timestamp of the cookie (string)
		: param cookie_expiry: The expiration timestamp of the cookie (string)
		: return: The Observable containing the Facet items.
		'''			
		cookie_creation_time = self.__cleanDate(cookie_creation_time)
		cookie_last_accessed_time = self.__cleanDate(cookie_last_accessed_time)		
		cookie_expiry = self.__cleanDate(cookie_expiry)
		cookie_value = cookie_value.replace('"', '')
		cookie_name = self.__cleanJSONtext(cookie_name)

		observable = ObjectObservable()
		
		observable_source = self.__checkAppName(cookie_source)
		observable_domain = self.__checkAppName(cookie_domain)
		
		facet_cookie = BrowserCookie(source=observable_source, 
			name=cookie_name, domain=observable_domain, 
			created_time=cookie_creation_time, last_access_time=cookie_last_accessed_time, 
			expiration_time=cookie_expiry)

		observable.append_facets(facet_cookie)
		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceLocationCoordinate(self, latitude, longitude, altitude, type):
		'''
		Generate uco-location:LatLongCoordinatesFacet.
		: param latitude: The latitude of the geo location (string)
		: param longitude: The longitude of the geo location (string)
		: param altitude: The altitude of the geo location (string)
		: param type: The type of the geo location (string)
		: return: The Observable containing the Facet items.
		'''		
		observable = ObjectObservable()
		id = latitude + '@' + longitude
		self.LOCATION_lat_long_coordinate[id] = observable

		latitude_decimal = float(latitude)
		longitude_decimal = float(longitude)
		
		if altitude != '':
			altitude_decimal = float(altitude)
		else:
			altitude_decimal = 0.00 

		facet_location = Location(latitude=latitude_decimal, 
			longitude=longitude_decimal, altitude=altitude_decimal)
		    #longitude=longitude_decimal, altitude=altitude_decimal, location_type=type)
		observable.append_facets(facet_location)
		
		self.bundle.append_to_uco_object(observable)
		return observable

		
	def __generateTraceWinTimeline(self, timeline_id, timeline_app_name,
				timeline_type, timeline_time_stamp):
		'''
		Generate uco-uco-observable:EventRecordFacet.
		: param timeline_id: The identifier of the Event provided within the XML report (string)
		: param timeline_app_name: The application generating rhe Event (string)
		: param timeline_type: The type of the Event (string)
		: param timeline_time_stamp: The timestamp of the Event (string)
		: return: The Observable containing the Facet items.
		'''		
		timeline_time_stamp = self.__cleanDate(timeline_time_stamp)
		if timeline_type.strip() == '':
			return None
		
		timeline_app_name = self.__cleanJSONtext(timeline_app_name)			
		event_text = self.__cleanJSONtext(timeline_app_name)
		
		observable = ObjectObservable()		
		facet_event = Event(event_type=timeline_type, 
			event_text=event_text, created_time=timeline_time_stamp)
		observable.append_facets(facet_event)

		self.bundle.append_to_uco_object(observable)
		return observable

	def __generateTraceWirelessNet(self, wifi_id, wifi_mac_address, wifi_channel,
		wifi_longitude, wifi_latitude, wifi_timeStamp, wifi_accuracy):
		'''
		Generate WirelessNetworkConnectionFacet.
		: param  wifi_id: The identifier of the WiFi provided within the XML report (string)
		: param wifi_mac_address: The MAC address of the WiFi (string)
		: param wifi_channel: The channel of the WiFi (string)
		: param wifi_longitude: The latitude of the WiFi (string)
		: param wifi_latitude: The longitude of the WiFi (string)
		: param wifi_timeStamp: The timestamp of the connection to the WiFi (string)
		: param wifi_accuracy: The accuracy of the WiFi data (string)
		: return: The Observable containing the Facet items.
		'''			
		wifi_timeStamp = self.__cleanDate(wifi_timeStamp)
		wifi_mac_address = wifi_mac_address.strip()

		observable_location = self.__checkGeoCoordinates(wifi_latitude, wifi_longitude,
			 '', 'Wireless Network')		

		if wifi_mac_address.strip() == "":
			return None 

		if wifi_mac_address in self.WIRELESS_NET_mac_address.keys():
			observable = self.WIRELESS_NET_mac_address[wifi_mac_address]
		else:
			observable = ObjectObservable()			
			#facet_wnet_connection = WirelessNetworkConnection(ssid=wifi_mac_address, location=observable_location, 
				#connection_time=wifi_timeStamp)
			facet_wnet_connection = WirelessNetworkConnection(ssid=wifi_mac_address)			
			observable.append_facets(facet_wnet_connection)
			self.bundle.append_to_uco_object(observable)
			self.WIRELESS_NET_mac_address[wifi_mac_address] = observable
			return observable

	def writeCall(self, CALLid, CALLappName, CALLtimeStamp, CALLdirection, 
				CALLduration, CALLpartner, CALLpartnerName, CALLsource, CALLlocation, 
				CALLrecoveryMethod):
		'''
		Generate uco-observable:CallFacet.
		: param  CALLid: The identifier of the Call provided within the XML report (string)
		: param CALLappName: The application used for the Call (string)
		: param CALLtimeStamp: The timestamp of the Call (string)
		: param CALLdirection: The direction of the Call (string)
		: param CALLpartner: The partner of the Call (string)
		: param CALLsource: The file containing the trace Call, for the Chain of Evidence (string)
		: param CALLsource: The file location containing the trace Call, for the Chain of Evidence (string)
		: param CALLrecoveryMethod: The recover mode of the Call, for the Chain of Evidence (string)
		: return: The Observable containing the Facet items.
		'''			
		callOutcome = ''
		
		for i, call_id in enumerate(CALLid):
			#if CALLdirection[i].lower() == 'incoming':
					#phoneTO = self.phoneOwnerNumber
					#phoneFROM = CALLpartner[i]
			#else:
				#phoneTO = CALLpartner[i]
				#phoneFROM = self.phoneOwnerNumber

			phonePattern = '\+?[0-9]+'	# phone number pattern
			resPattern = re.match(phonePattern, CALLpartner[i])
			
			if (resPattern):
				if CALLpartner[i] in self.phoneNumberList:
					idx = self.phoneNumberList.index(CALLpartner[i])
					uuidPartner = self.phoneUuidList[idx]
				else:	
					mobileOperator = ""
					self.phoneNumberList.append(CALLpartner[i])
					self.phoneNameList.append(CALLpartnerName[i])
					uuidPartner = self.generateTracePhoneAccount(mobileOperator, 
						CALLpartnerName[i], CALLpartner[i])
					self.phoneUuidList.append(uuidPartner)			
			else:
				if CALLappName[i].strip() in self.appNameList: 
					idx = self.appNameList.index(CALLappName[i].strip())
					#idAppName = self.appNameList[idx]
					idAppIdentity = self.appIDList[idx]
				else:
					idAppIdentity = self.__generateTraceAppName(CALLappName[i].strip())
					self.appNameList.append(CALLappName[i].strip())
					self.appIDList.append(idAppIdentity)

				if CALLpartner[i].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(CALLpartner[i].strip())
					uuidPartner = self.CHATaccountIdList[idx]
				else:
					self.CHATparticipantsNameList.append(CALLpartner[i].strip())
					uuidPartner = self.__generateTraceApplicationAccount(CALLpartner[i].strip(), 
						CALLpartner[i].strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(CALLpartner[i].strip())
					self.CHATaccountIdList.append(uuidPartner)						

			if CALLdirection[i].lower() == 'incoming':
				uuid = self.__generateTraceCall(CALLdirection[i].lower(), 
					CALLtimeStamp[i], uuidPartner, self.observable_phone_owner, 
					CALLduration[i], CALLrecoveryMethod[i], callOutcome)
			else:
				uuid = self.__generateTraceCall(CALLdirection[i].lower(), 
					CALLtimeStamp[i], self.observable_phone_owner, uuidPartner, 
					CALLduration[i], CALLrecoveryMethod[i], callOutcome)
			
			self.__generateChainOfEvidence(CALLsource[i], CALLlocation[i], uuid)		

	def writeHeader(self):
		'''
		It generates te first lines of the JSON-LD file based on the ObejctInfo() class.
		'''
		if self.bundle is None:
			self.bundle = Bundle()
			observable_info=ObjectInfo(name="D.F. Expert", version="CASE 1.0.0", description="Extraction from XML report by MAGNET AXIOM PROCESS")
			self.bundle.append_to_uco_object(observable_info)
			
	def writeLastLine(self):
		'''
		Write the JSON-LD file by using all the Observables stored in memory.
		'''
#---	Save a reference to the original standard output			
		original_stdout = sys.stdout 
#--	Change the standard output to the file we created.    		
		sys.stdout = self.FileOut 
				
		print(self.bundle)

#--	Restore the standard output to its default value
		sys.stdout = original_stdout 

	def writePhoneOwner(self, phoneOwnerNumber, phoneOwnerName):
		'''
		Wtrite the owner's phone data
		'''
		self.phoneOwnerNumber = phoneOwnerNumber
		mobileOperator = ""
		self.observable_phone_owner = self.__generateTracePhoneOwner(mobileOperator, phoneOwnerName, 
				phoneOwnerNumber)


	def writeFiles(self, FILEid, FILEtag, FILEname, FILElocalPath, FILEimage,
					FILEsize, FILEcreated, FILEmodified, FILEaccessed, FILEmd5,
					FILEexifMake, FILEexifModel, FILEexifLatitudeRef, FILEexifLatitude, 
					FILEexifLongitudeRef, FILEexifLongitude, FILEexifAltitude,
					FILEsource, FILElocation, FILErecoveryMethod):
		'''
		Generate uco-observable:FileFacet.
		: param FILEid: The identifier of the File provided within the XML report (string)
		: param FILEtag: The tag (category) of the File (string)
		: param FILEname: The name of the File (string)
		: param FILElocalPath: The local path where the physical file have been ezxtracetd (string)
		: param FILEimage: The name of the File in case of an image (string)
		: param FILEsize: The size of the File (string)
		: param FILEcreated: The created time of the File (string)
		: param FILEmodified: The modifed time of the File (string)
		: param FILEaccessed: The accessed time of the File (string)
		: param FILEmd5: The MD5 of the File (string)
		: param FILEexifMake: The EXIF make of the File (string)
		: param FILEexifModel: The EXIF model of the File (string)
		: param FILEexifLatitudeRef: The EXIF latitude reference of the File (string)
		: param FILEexifLatitude: The EXIF latitude of the File (string)
		: param FILEexifLongitudeRef: The EXIF longitude reference of the File (string)
		: param FILEexifLongitude: The EXIF longitude of the File (string)
		: param FILEexifAltitude: The EXIF altitude of the File (string)
		: param FILEsource: The file containing the trace File, for the Chain of Evidence (string)
		: param FILElocation: The file location containing the trace File, for the Chain of Evidence (string)
		: param FILErecoveryMethod: The recover mode of the File, for the Chain of Evidence (string)
		'''						
		for i, file_id in enumerate(FILEid):
			if FILEname[i] == '':
				FILEname[i] = FILEimage[i]
			
			if FILEname[i].find('Binary data') > -1:
				pass
			else:
				fileExt = FILEname[i][FILEname[i].rfind('.') + 1:]

				file_observable = self.__generateTraceFile(FILEname[i], FILEsize[i], 
					'MD5', FILEmd5[i],	FILEtag[i], FILEcreated[i], FILEmodified[i], 
					FILEaccessed[i], FILElocalPath[i], fileExt,
					FILEexifMake[i], FILEexifModel[i], FILEexifLatitudeRef[i], 
					FILEexifLatitude[i], FILEexifLongitudeRef[i], 
					FILEexifLongitude[i], FILEexifAltitude[i])

				self.FILEuuid[file_id] = file_observable

	def writeChat(self, CHATid, CHATsender, CHATreceiver, CHATdateTimeSent, 
							CHATdateTimeReceived, CHATmessage, CHATmessageStatus, 
							CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod):		
		'''
		Prapare the generation of the MessageFacet of the Chat
		: param CHAT...: The various CHAT Message data (string)
		: return: None.
		'''
		CHATthreadParticipants = []
		self.fillChatThread(CHATthreadParticipants, CHATid, CHATsender, CHATreceiver,
				CHATdateTimeSent, CHATdateTimeReceived, CHATmessage, CHATmessageStatus,
				CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod, 
				self.phoneOwnerNumber)			

		for i, chat_id in enumerate(self.CHATids):
#---	CHATidAccountList contains the list of the Mesages uuid of CHATs
#		CHATthread contains the values for the generation of the ChatThreadFacet Observable	
#											
			self.CHATthread = []	
			self.chatIdAccountList = []			
			for j, chat_id_item in enumerate(chat_id):
				if self.CHATapplications[i][j].strip().lower() in self.appNameList: 
					idx = self.appNameList.index(self.CHATapplications[i][j].strip().lower())
					#idAppName = self.appNameList[idx]
					idAppIdentity = self.appIDList[idx]
				else:
					idAppIdentity = self.__generateTraceAppName(self.CHATapplications[i][j].strip().lower())
					self.appNameList.append(self.CHATapplications[i][j].strip().lower())
					self.appIDList.append(idAppIdentity)
				
				if self.CHATsenders[i][j].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(self.CHATsenders[i][j].strip())
					CHATmsgFrom = self.CHATaccountIdList[idx]
				else:
					CHATname = ''
					self.CHATparticipantsNameList.append(CHATname)
					CHATmsgFrom = self.__generateTraceApplicationAccount(
						CHATname, self.CHATsenders[i][j].strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(self.CHATsenders[i][j].strip())
					self.CHATaccountIdList.append(CHATmsgFrom)

				if self.CHATreceivers[i][j].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(self.CHATreceivers[i][j].strip())
					CHATmsgTo = self.CHATaccountIdList[idx]
				else:
					CHATname = ''
					self.CHATparticipantsNameList.append(CHATname)
					CHATmsgTo = self.__generateTraceApplicationAccount(
						CHATname, self.CHATreceivers[i][j].strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(self.CHATreceivers[i][j].strip())
					self.CHATaccountIdList.append(CHATmsgTo)
				

#---	if Identifiers TO is empty, the array CHATpartyIdentifiers must
#		be iterated to find the right Party	
				if self.CHATmessageStatuses[i][j].lower().find('received') > - 1:
					CHATdirection = 'Incoming'
					CHATdate = self.__cleanDate(self.CHATdateTimeReceiveds[i][j])
				else:			
					CHATdirection = 'Outgoing'
					CHATdate = self.__cleanDate(self.CHATdateTimeSents[i][j])
								
				CHATattachmentFileNames = ''
				CHATattachmentUrls = ''
				CHATmsgToList = []
				CHATmsgToList.append(CHATmsgTo)
				observable_chat = self.__generateTraceChat(self.CHATmessages[i][j], idAppIdentity, 
					CHATdate, CHATmsgFrom, CHATmsgToList, self.CHATrecoveryMethods[i][j], 
					self.CHATmessageStatuses[i][j], CHATdirection, "CHAT Message",
					CHATattachmentFileNames, CHATattachmentUrls)
				self.CHATthread.append(observable_chat)

#---	if there are not messages for this Chat or no ChatAccount has been
# 		generated, the ThreadMessage is not generated. Moreover the Chain of
# 		evidence is built upon the ThreadUuid
			if (len(self.CHATthread) != 0):
				observable_thread = self.__generateThreadMessages(self.CHATids[i][j], self.CHATthread, 
								[CHATmsgFrom, CHATmsgTo])
				self.__generateChainOfEvidence(CHATsource[i], CHATlocation[i], 
					observable_thread)

	def writeDeviceEvent(self, EVENT_LOCK_id, EVENT_LOCK_status, 
                EVENT_LOCK_dateTime, EVENT_LOCK_source, EVENT_LOCK_location, 
                EVENT_LOCK_recoveryMethod):
		'''
		Prapare the generation of the uco-observable:EventRecordFacet
		: param EVENT...: The various Event Device data (string)
		: return: None.
		'''		
		for i, device_event_id in enumerate(EVENT_LOCK_id):
			observable_event = self.__generateTraceDeviceEvent(device_event_id, 
				EVENT_LOCK_dateTime[i], 'Device Lock Status', EVENT_LOCK_status[i])
			if observable_event is not None:
				self.__generateChainOfEvidence(EVENT_LOCK_source[i], 
					EVENT_LOCK_location[i], observable_event)

	def writeAppUsage(self, EVENT_APP_USE_id, EVENT_APP_USE_application, 
                EVENT_APP_USE_start_time, EVENT_APP_USE_end_time,
                EVENT_APP_USE_source, EVENT_APP_USE_location, 
                EVENT_APP_USE_recoveryMethod):
		'''
		Prapare the generation of the uco-observable:EventRecordFacet for the application use
		: param EVENT...: The various Event Device data (string)
		: return: None.
		'''			
		for i, application in enumerate(EVENT_APP_USE_application):
			observable_app_usage= self.__generateTraceAppUsage(EVENT_APP_USE_id[i], 
				EVENT_APP_USE_start_time[i], EVENT_APP_USE_end_time[i],
				'Application Usage', application)
			if observable_app_usage is not None:
				self.__generateChainOfEvidence(EVENT_APP_USE_source[i], 
					EVENT_APP_USE_location[i], observable_app_usage)


	def writeEmail(self, EMAILid, EMAILapp, EMAILidentifierFROM, 
				EMAILidentifiersTO, EMAILidentifiersCC, EMAILidentifiersBCC, 
				EMAILbody, EMAILsubject, EMAILtimeStamp, EMAILattachmentsFilename,
				EMAILsource, EMAILlocation, EMAILrecoveryMethod):
		'''
		Prapare the generation of the EmailMessageFacet and uco.observbale:EmailMessageFacet
		: param EMAIL...: The various Email data (string)
		: return: None.
		'''				
		for i, email_id in enumerate(EMAILid):			
			self.__generateTraceEmail(email_id, EMAILrecoveryMethod[i], EMAILsource[i],
				EMAILlocation[i], EMAILidentifierFROM[i], EMAILidentifiersTO[i], 
				EMAILidentifiersCC[i], EMAILidentifiersBCC[i], EMAILbody[i], 
				EMAILsubject[i], EMAILtimeStamp[i], EMAILattachmentsFilename[i])

	def writeDeviceDisk(self,FILE_SYS_INFOvolumeSn, FILE_SYS_INFOfileSystem, 
		FILE_SYS_INFOcapacity, FILE_SYS_INFOunallocated, FILE_SYS_INFOallocated,
        FILE_SYS_INFOoffset):
		'''
		Prapare the generation of the uco-observable:DiskPartitionFacet.
		: param FILE_SYS_INFO...: The various File System Info data (string)
		: return: None.
		'''			
		DEVICEcapacity = 0
		for i, capacity in enumerate(FILE_SYS_INFOcapacity):
			if capacity != '':
				DEVICEcapacity += int(capacity)

		partitions_ref = []
		for i, s_n in enumerate(FILE_SYS_INFOvolumeSn):
			if FILE_SYS_INFOcapacity[i] != '':
				object_partition =  self.__generateTraceDiskPartition(s_n, 
					FILE_SYS_INFOfileSystem[i], FILE_SYS_INFOcapacity[i],
					FILE_SYS_INFOunallocated[i], FILE_SYS_INFOallocated[i],
					FILE_SYS_INFOoffset[i])
				#partitions_ref.append(object_partition.get_id())
				partitions_ref.append(object_partition)

		if partitions_ref:
			self.observable_device =  self.__generateTraceDeviceDisk(DEVICEcapacity, partitions_ref)

	def writeDeviceMobile(self, DEVICEid, DEVICEimsi, DEVICEbluetoothAddress, 
		DEVICEbluetoothName, DEVICEimei, DEVICEserialNumber, DEVICEname, 
		DEVICEmodel, DEVICEiccid, DEVICEosVersion):
		'''
		Prapare the generation of the uco-observable:MobileDeviceFacet.
		: param DEVICE...: The various Device data (string)
		: return: None.
		'''			
		self.observable_device =  self.__generateTraceDeviceMobile(DEVICEid, DEVICEimsi, 
			DEVICEbluetoothAddress, DEVICEbluetoothName, DEVICEimei, DEVICEserialNumber, 
			DEVICEname, DEVICEmodel, DEVICEiccid, DEVICEosVersion)

	def writeWebPages(self, WEB_PAGEid, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited, 
				WEBsource, WEBlocation, WEBrecoveryMethod):
		'''
		Prapare the generation of the uco-observable:UrlHistory.
		: param WEB...: The various Web History data (string)
		: return: None.
		'''		
		str_coe = ''
		for i in range(len(WEB_PAGEid) - 1):
			self.__generateTraceWebPages(WEB_PAGEid[i], WEB_PAGEsource[i], WEB_PAGEurl[i], 
					WEB_PAGEtitle[i], WEB_PAGEvisitCount[i],  WEB_PAGlastVisited[i],
					WEBsource[i], WEBlocation[i], WEBrecoveryMethod[i])		
		
#--- last char is space not comma when i == len(WEB_PAGEid)
#			
		if len(WEB_PAGEid) > 0:
			self.__generateTraceWebPages(WEB_PAGEid[i], WEB_PAGEsource[i], WEB_PAGEurl[i], 
					WEB_PAGEtitle[i], WEB_PAGEvisitCount[i],  WEB_PAGlastVisited[i],
					WEBsource[i], WEBlocation[i], WEBrecoveryMethod[i])
			self.FileOut.write(str_coe[0:-2])
	
	def writeCell_Tower(self, CELL_TOWERid, CELL_TOWERmcc,
                CELL_TOWERmnc, CELL_TOWERlac, CELL_TOWERcid, 
                CELL_TOWERlongitude, CELL_TOWERlatitude,
                CELL_TOWERtimeStamp,  CELL_TOWERsource, 
                CELL_TOWERlocation, CELL_TOWERrecoveryMethod):
		'''
		Prapare the generation of the uco-observable:Cellsite.
		: param CELL_TOWER...: The various Cellsite data (string)
		: return: None.
		'''			
		for i, cell_tower_id in enumerate(CELL_TOWERid):			
			observable_cell_tower = self.__generateTraceCellTower(cell_tower_id, CELL_TOWERmcc[i],
				CELL_TOWERmnc[i], CELL_TOWERlac[i],CELL_TOWERcid[i], 
                CELL_TOWERlongitude[i], CELL_TOWERlatitude[i], CELL_TOWERtimeStamp[i])
			
			if observable_cell_tower is not None:
				self.__generateTraceRelation(self.observable_phone_owner, 
					observable_cell_tower, 'Located_At', '', '', CELL_TOWERtimeStamp[i], '')
				self.__generateChainOfEvidence(CELL_TOWERsource[i], 
					CELL_TOWERlocation[i], observable_cell_tower)		

	def writeCookie(self, COOKIEid, COOKIEappSource, COOKIEname, COOKIEpath, COOKIEdomain, 
				COOKIEcreatedDate, COOKIEaccessedDate, COOKIEexpirationDate, 
                COOKIEsource, COOKIElocation, COOKIErecoveryMethod):
		'''
		Prapare the generation of the uco-observable:BrowserCookie.
		: param COOKIE...: The various Cookie data (string)
		: return: None.
		'''		
		for i, cookie_item_id in enumerate(COOKIEid):			
			observable_cookie = self.__generateTraceCookie(cookie_item_id, COOKIEappSource[i],
				COOKIEname[i], COOKIEpath[i], COOKIEdomain[i], COOKIEcreatedDate[i], 
				COOKIEaccessedDate[i], COOKIEexpirationDate[i])
			
			if observable_cookie is not None:
				self.__generateChainOfEvidence(COOKIEsource[i], COOKIElocation[i], 
					observable_cookie)

	def writeWinTimeline(self, WIN_TIMELINEid, WIN_TIMELINEappName, WIN_TIMELINEactivityType, 
				WIN_TIMELINEtimeStamp, WIN_TIMELINEsource, WIN_TIMELINElocation, 
                WIN_TIMELINErecoveryMethod):
		'''
		Prapare the generation of the uco-observable:EventRecord for the timeline.
		: param WIN_TIMELINE...: The various Timeline data (string)
		: return: None.
		'''			
		for i, timeline_item_id in enumerate(WIN_TIMELINEid):			
			observable_win_timeline = self.__generateTraceWinTimeline(timeline_item_id, WIN_TIMELINEappName[i],
				WIN_TIMELINEactivityType[i], WIN_TIMELINEtimeStamp[i])
			
			if observable_win_timeline is not None:
				self.__generateChainOfEvidence(WIN_TIMELINEsource[i], 
					WIN_TIMELINElocation[i], observable_win_timeline)

	def writeLocationDevice(self, LOCATIONid, LOCATIONtype, LOCATIONlatitude,  
		LOCATIONlongitude, LOCATIONcreated, LOCATIONsource, LOCATIONlocation):
		'''
		Prapare the generation of the uco-observable:Location.
		: param LOCATION...: The various Location data (string)
		: return: None.
		'''			
		for i, location_id in enumerate(LOCATIONid):
			observable_location= self.__generateTraceLocationDevice(location_id, LOCATIONlongitude[i], 
				LOCATIONlatitude[i], 'Significant Location')
			
			if observable_location is not None:
				self.__generateTraceRelation(self.observable_device, observable_location, 
					'Mapped_By', '', '', LOCATIONcreated[i], '')
				self.__generateChainOfEvidence(LOCATIONsource[i], 
					LOCATIONlocation[i], observable_location)		

	def writeSearched_Item(self, SEARCHED_ITEMid, SEARCHED_ITEMvalue, SEARCHED_ITEMtimeStamp, 
				SEARCHED_ITEMappSource, SEARCHED_ITEMsource, SEARCHED_ITEMlocation, 
                SEARCHED_ITEMrecoveryMethod):
		'''
		Prapare the generation of the drafting:SearchedItemFacet.
		: param SEARCHED_ITEM...: The various Searched Item data (string)
		: return: None.
		'''		
		for i, searched_item_id in enumerate(SEARCHED_ITEMid):			
			observable_searched = self.__generateTraceSearchedItem(searched_item_id, SEARCHED_ITEMvalue[i],
				SEARCHED_ITEMtimeStamp[i], SEARCHED_ITEMappSource[i])
			
			if observable_searched is not None:
				self.__generateChainOfEvidence(SEARCHED_ITEMsource[i], 
					SEARCHED_ITEMlocation[i], observable_searched)
		
	def writeSms(self, SMSid, SMSsender, SMSrecipient, SMSreceivedDateTime,
					SMSsentDateTime, SMSmessage, SMSdirection, SMSsource,
					SMSlocation, SMSrecoveryMethod):
		'''
		Prapare the generation of the uco-observable:SMSMessageFacet.
		: param SMS...: The various SMS data (string)
		: return: None.
		'''			
		for i, sms_id in enumerate(SMSid):
			phoneUuidTo = ''
			phoneUuidFrom = ''
			SMSsenderClean = SMSsender[i].strip()
			if SMSsenderClean.lower() == 'local user':
				SMSsenderClean = self.phoneOwnerNumber

#---	get rid of hex chars byte not accepted in JSON values
			if SMSsenderClean in self.phoneNumberList:						
				idx = self.phoneNumberList.index(SMSsenderClean)						
				#userId = self.phoneNumberList[idx]
				phoneParticipantUuid = self.phoneUuidList[idx]
			else:
				senderName = ''
				self.phoneNumberList.append(SMSsenderClean)
				self.phoneNameList.append(senderName)
				mobileOperator = ""		
				SMSsenderClean = self.__cleanJSONtext(SMSsenderClean)
				phoneParticipantUuid = self.generateTracePhoneAccount(mobileOperator, 
					senderName, SMSsenderClean)	
				self.phoneUuidList.append(phoneParticipantUuid)

			SMSrecipientClean = SMSrecipient[i].strip()
			if SMSrecipientClean.lower() == 'local user':
				SMSrecipientClean = self.phoneOwnerNumber

			if SMSrecipientClean in self.phoneNumberList:						
				idx = self.phoneNumberList.index(SMSrecipientClean)						
				#userId = self.phoneNumberList[idx]
				phoneRecipientUuid = self.phoneUuidList[idx]
			else:
				recipientName = ''
				self.phoneNumberList.append(SMSrecipientClean)
				self.phoneNameList.append(recipientName)
				mobileOperator = ""
				SMSrecipientClean = self.__cleanJSONtext(SMSrecipientClean)
				phoneRecipientUuid = self.generateTracePhoneAccount(mobileOperator, 
					recipientName, SMSrecipientClean)	
				self.phoneUuidList.append(phoneRecipientUuid)

			#body = self.__cleanJSONtext(SMSmessage[i])
						
			if SMSreceivedDateTime[i] == '':
				phoneUuidFrom = phoneParticipantUuid
				phoneUuidTo = phoneRecipientUuid
				SMSdate = SMSsentDateTime[i]
				direction = "Outgoing"
			else:
				phoneUuidFrom = phoneRecipientUuid
				phoneUuidTo = phoneParticipantUuid
				SMSdate = SMSreceivedDateTime[i]
				direction = "Incoming"
			
			SMSdate = self.__cleanDate(SMSdate)
			observable_app = self.__checkAppName("Native")
			SMSphoneListTo = []
			SMSphoneListTo.append(phoneUuidTo)
			observable_message = self.__generateTraceChat(SMSmessage[i], observable_app, 
				SMSdate, phoneUuidFrom, SMSphoneListTo, SMSrecoveryMethod[i], 
				"outcome not available", direction, "SMS/Native Message", "", "")

			if observable_message is not None:
				self.__generateChainOfEvidence(SMSsource[i], SMSlocation[i], 
					observable_message)

	def writeWireless_Net(self, WIRELESS_NETid, WIRELESS_NETmacAddress,
                WIRELESS_NETchannel, WIRELESS_NETlongitude, WIRELESS_NETlatitude,
                WIRELESS_NETtimeStamp,  WIRELESS_NETaccuracy, WIRELESS_NETsource, 
                WIRELESS_NETlocation, WIRELESS_NETrecoveryMethod):
		'''
		Prapare the generation of theuco-observable:WirelessNetworkConnectionFacet.
		: param WIRELESS_NET...: The various Wireless Network data (string)
		: return: None.
		'''			
		for i, wifi_id in enumerate(WIRELESS_NETid):			
			observable_wi_net = self.__generateTraceWirelessNet(wifi_id, WIRELESS_NETmacAddress[i],
				WIRELESS_NETchannel[i], WIRELESS_NETlongitude[i], WIRELESS_NETlatitude[i], 
				WIRELESS_NETtimeStamp[i], WIRELESS_NETaccuracy[i])
			
			if observable_wi_net is not None:
				self.__generateTraceRelation(self.observable_phone_owner, observable_wi_net, 
					'Connected_To', '', '', WIRELESS_NETtimeStamp[i], '')
				observable_location = self.__checkGeoCoordinates(WIRELESS_NETlatitude[i], 
				    WIRELESS_NETlongitude[i], '', 'Wireless Network')					
				if observable_location:
					self.__generateTraceRelation(observable_wi_net, observable_location,
							                     'Mapped_To', '', '', None, None)				
				self.__generateChainOfEvidence(WIRELESS_NETsource[i], 
					WIRELESS_NETlocation[i], observable_wi_net)
				

	def writeContextAxiom(self, axiomVersionText, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText,
		deviceBluetoothAddressText, deviceIdText, deviceModelText, 
		deviceOsTypeText, deviceOsVersionText, deviceVendorText, 
		deviceMacAddressText, deviceIccidText, deviceImsiText, 
		deviceImeiText, imagePath, imageSize, 
		imageMetadataHashSHA, imageMetadataHashMD5):

		self.___generateContextAxiom(axiomVersionText, deviceExtractionStartTime, 
			deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText, 
			deviceBluetoothAddressText, deviceIdText, deviceModelText, 
			deviceOsTypeText, deviceOsVersionText, deviceVendorText, 
			deviceMacAddressText, deviceIccidText, deviceImsiText, 
			deviceImeiText, imagePath, imageSize, 
			imageMetadataHashSHA, imageMetadataHashMD5)


