#---	class AXIOMtoJSON.py

import uuid
import os
import re
import json
import re
#import logging

class AXIOMtoJSON:
	'''
	Represents all attributes and methods to represent Traces in CASE ontology, starting from data
	extracted from XML reports generated by UFED-PA forensic tool
	'''
	TAB = '\t'
# default value for string value not provided
#
	NP = ''				

# default value for integer value not provided
#
	INT = '0'	

# default value for date value not provided
#
	DATE = '1900-01-01T08:00:00'

# default value for Hash Method value not provided
#
	HASH_M = 'MD5'

# default value for Hash Method value not provided
#
	HASH_V = '1' * 76

# default value for the property referrerUrl of the URLHistoryFacet class
#
	REF_URL = 'http:www.empty.com/referrer_url'

# default value for the location where a forensic action was carried out
#
	LOCATION = 'Unknown location'

	def __init__(self, fileOut, commaLine=True):
	# to be defined
		#logging.basicConfig(filename='_axiom_log.txt', level=logging.INFO,
		#	filemode='w', format='%(message)s')
		self.FileOut = fileOut
		self.commaLine = commaLine
		self.phoneNumberList = []
		self.phoneNameList = []
		self.phoneUuidList = []
		
		self.appNameList = []
		self.appAccountUsernameList = []
		self.appAccountNameList = []
		self.appIDList = []

		self.CHATparticipantsNameList = []
		self.CHATparticipantsIdList = []
		self.CHATaccountIdList = []
		self.CHATthread = []

		self.DEVICEuuid = ''

		self.EMAILaddressUuid = {}
		self.EMAILregex = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
		self.phoneOwnerNumber = ''
		self.phoneOwnerUuid = ''
		self.FILEuuid = {}
		self.FILEid = []

		self.EXTRA_INFOdictPath = {}
		self.EXTRA_INFOdictSize = {}
		self.EXTRA_INFOdictTableName = {}
		self.EXTRA_INFOdictOffset = {}
		self.EXTRA_INFOdictNodeInfoId = {}

		self.CHATids = []
		self.CHATsenders = []
		self.CHATreceivers = []
		self.CHATdateTimeSents = []
		self.CHATdateTimeReceiveds = []
		self.CHATmessages = []
		self.CHATmessageStatuses = []
		self.CHATsources = []
		self.CHATlocations = []
		self.CHATrecoveryMethods = []
		self.CHATapplications = []

		self.UrlList = {}

		self.LocationList = []
		self.LocationIDList = []

		self.LOCATION_lat_long_coordinate = {}
		self.CELL_TOWER_gsm ={}
		self.WIRELESS_NET_mac_address = {}
		self.SEARCHED_ITEMvalue_date = []


		
	# static methods do not receive class or instance arguments
	# and usually operate on data that is not instance or class-specific
	@staticmethod
	def __createUUID():
		'''	
		Traces in CASE have a unique identification number, based on Globally Unique Identifier.  
		Each time a Trace is generated this static method in invoked, it doen't depends on any object
		'''
		return str(uuid.uuid4())

	def __cleanJSONtext(self, originalText):
		new_text = originalText.strip()
		if new_text == '':
			return ''
		else:
			new_text = new_text.replace('"', "").replace('\n', '').replace('\r', '')
			new_text = new_text.replace('\t', " ").replace("\\'", "'").replace("\\", "")
			new_text = new_text.replace('ï¿½', '')
			return new_text

	def __checkGeoCoordinates(self, latitude, longitude, elevation, category):
		latitude = latitude.strip()
		longitude = longitude.strip()
		
		uuidLocation = ''
		if latitude != '' and longitude != '':
			id_geo_loc = latitude + '@' + longitude
			if id_geo_loc in self.LOCATION_lat_long_coordinate.keys():
				uuidLocation = self.LOCATION_lat_long_coordinate[id_geo_loc]
			else:
				uuidLocation = self.__generateTraceLocationCoordinate(latitude, 
					longitude, elevation, category)
				self.LOCATION_lat_long_coordinate[id_geo_loc] = uuidLocation

		return uuidLocation

	def __checkSearchedItems(self, value):
		
		itemFound = False
		if value not in self.SEARCHED_ITEMvalue_date:			
			self.SEARCHED_ITEMvalue_date.append(value)
			itemFound = True

		return itemFound


	def __generateTraceDeviceEvent(self, d_event_id, d_event_timeStamp, 
		d_event_eventType, d_event_value):

		d_event_timeStamp = self.__cleanDate(d_event_timeStamp)		
		d_event_value = self.__cleanJSONtext(d_event_value)
		
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id":uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:EventFacet",
					"uco-observable:observableCreatedTime":{
						"@type":"xsd:dateTime",
						"@value":d_event_timeStamp
					},
					"uco-observable:eventType":d_event_eventType,
					"uco-observable:eventText":d_event_value
				}
			]
		}
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceAppUsage(self, d_event_id, d_event_startTime, 
		d_event_endTime, d_event_eventType, d_event_value):
	
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id":uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:EventFacet",
					"uco-observable:observableCreatedTime":{
						"@type":"xsd:dateTime",
						"@value":d_event_startTime
					},
					"uco-observable:observableStartTime":{
						"@type":"xsd:dateTime",
						"@value":d_event_startTime
					},
					"uco-observable:observableEndTime":{
						"@type":"xsd:dateTime",
						"@value":d_event_endTime
					},
					"uco-observable:eventType":d_event_eventType,
					"uco-observable:eventText":d_event_value
				}
			]
		}
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __checkEmailAddress(self, address):
		if address in self.EMAILaddressUuid.keys():
			uuid = self.EMAILaddressUuid.get(address)
		else:
			uuid = self.__generateTraceEmailAccount(address)
			self.EMAILaddressUuid[address] = uuid
		
		return  uuid

	def fillArrayWithEmpty(self, aInput, max):
		if len(aInput) < max:
			for i in range(len(aInput), max):						
				aInput.append('')

	def fillChatThread(self, chatThread, CHATid, CHATsender, CHATreceiver,
		CHATdateTimeSent, CHATdateTimeReceived, CHATmessage, CHATmessageStatus,
		CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod, CALLphoneNumber):

		for i, chat_sender in enumerate(CHATsender):
			if chat_sender.lower().find('local user') > -1:
				chat_sender = CALLphoneNumber

			if CHATreceiver[i].lower().find('local user') > -1:
				CHATreceiver[i] = CALLphoneNumber
			
			chatFound = False
			idx = -1
			for j, chat_thread in enumerate(chatThread):
				if (chat_sender in chat_thread and
					  CHATreceiver[i] in chat_thread and 
					  CHATapplication[i] in chat_thread):
					idx = j
					chatFound = True
					break
			
			if chatFound:		
				self.CHATids[idx].append(CHATid[i])
				self.CHATsenders[idx].append(chat_sender)
				self.CHATreceivers[idx].append(CHATreceiver[i])
				self.CHATdateTimeSents[idx].append(CHATdateTimeSent[i])
				self.CHATdateTimeReceiveds[idx].append(CHATdateTimeReceived[i])
				self.CHATmessages[idx].append(CHATmessage[i])
				self.CHATmessageStatuses[idx].append(CHATmessageStatus[i])
				self.CHATsources[idx].append(CHATsource[i])
				self.CHATlocations[idx].append(CHATlocation[i])
				self.CHATrecoveryMethods[idx].append(CHATrecoveryMethod[i])
				self.CHATapplications[idx].append(CHATapplication[i])
			else:
				idx = len(chatThread) - 1
				self.CHATids.append([CHATid[i]])
				self.CHATsenders.append([chat_sender])
				self.CHATreceivers.append([CHATreceiver[i]])
				self.CHATdateTimeSents.append([CHATdateTimeSent[i]])
				self.CHATdateTimeReceiveds.append([CHATdateTimeReceived[i]])
				self.CHATmessages.append([CHATmessage[i]])
				self.CHATmessageStatuses.append([CHATmessageStatus[i]])
				self.CHATsources.append([CHATsource[i]])
				self.CHATlocations.append([CHATlocation[i]])
				self.CHATrecoveryMethods.append([CHATrecoveryMethod[i]])
				self.CHATapplications.append([CHATapplication[i]])
				chatThread.append(chat_sender + '#' + CHATreceiver[i] + '#' + CHATapplication[i])

	def __cleanDate(self, initialDate):
		aMonths = {
			'Jan': '01',
			'Feb': '02',
			'Mar': '03',
			'Apr': '04',
			'May': '05',
			'Jun': '06',
			'Jul': '07',
			'Aug': '08',
			'Sep': '09',
			'Oct': '10',
			'Nov': '11',
			'Dec': '12'
		}
		
		initialDate = initialDate.strip()

		if 	initialDate == '':
			return AXIOMtoJSON.DATE

#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx)
#		the character "/" is not allowed
#		
		initialDate = initialDate.replace("/", "-")
		initialDate = initialDate.replace(' ', 'T', 1)
		initialDate = initialDate.replace('UTC', '')						
		initialDate = initialDate.replace('AM', '')
		initialDate = initialDate.replace('PM', '')
		startTZ = initialDate.find("+")
		if startTZ > -1:
			initialDate = initialDate[:startTZ]		
		
		for k,v in aMonths.items():
			if initialDate.find(k) > -1:
				initialDate = initialDate.replace(k, v)
				break
		
		firstChars = initialDate[:10]
		firstChars = firstChars.replace(".", "-")
		initialDate = firstChars + initialDate[10:]

		yearPattern = '\-[0-9][0-9]T'	# year with two digits
		resPattern = re.search(yearPattern, initialDate)
		if resPattern:
			if re.search('^[0-9]{4}', initialDate):
				pass
			else:
				initialDate = re.sub('-([0-9][0-9])T', '-20\g<1>T', initialDate)
				initialDate = str(initialDate[6:10]) + initialDate[2:6] + initialDate[0:2] + \
					initialDate[10:] 

		yearPattern = '\-\d{4}T'	# year with 4 digits in Italian format
		resPattern = re.search(yearPattern, initialDate)
		if resPattern:
			initialDate = str(initialDate[6:10]) + initialDate[2:6] + initialDate[0:2] + \
				initialDate[10:] 		

		if re.search('(\d{2}:\d{2}:\d{2})$', initialDate):
			pass
		else:
			initialDate = re.sub('(\d{2}:\d{2})$', '\g<1>:00', initialDate)

		if re.search('T(\d):', initialDate):
			initialDate = re.sub('T(\d):', 'T0\g<1>:', initialDate)

		if re.search(':(\d):', initialDate):
			initialDate = re.sub(':(\d):', ':0\g<1>:', initialDate)

		if re.search(':(\d)$', initialDate):
			initialDate = re.sub(':(\d)$', ':0\g<1>', initialDate)

		if re.search('T\d{2}:\d{2}:\d{2}(.+)$', initialDate):
			initialDate = re.sub('(T\d{2}:\d{2}:\d{2})(.+)$', '\g<1>', initialDate)
			

		return initialDate.strip()


	def ___generateContextAxiom(self, ufedVersion, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerName, 
		deviceBluetoothAddress, deviceId, devicePhoneModel, 
		deviceOsType, deviceOsVersion, devicePhoneVendor, 
		deviceMacAddress, deviceIccid, deviceImsi, deviceImei, 
		imagePath, imageSize, imageMetadataHashSHA, imageMetadataHashMD5):

		# generate Trace/Tool for the Acquisition and Extraction Actions
		idTool = self.__generateTraceTool('AXIOM Process', 'Acquisition', 
			'MAGNET', ufedVersion, []);
		
		# generate Trace/Identity for the Performer, D.F. Expert, of the Actions
		idIdentity = self.__generateTraceIdentity(examinerName, '', '')
		
		# generate Trace/Role for the Performer, D.F. Expert, of the Actions
		idRole = self.__generateTraceRole('Digital Forensic Expert')
		
		# generate Trace/Relation between the above Role and the Identity traces
		self.__generateTraceRelation(idIdentity, idRole, 'has_role', '', '', '', '');
		
		# generate Trace/Provenance_Record for the  device
		idDeviceList = []
		idDeviceList.append(self.DEVICEuuid)
		idProvenanceDevice = self.__generateTraceProvencance(idDeviceList, 'Mobile device', 
			'', deviceAcquisitionStartTime) 
		
		# generate Trace/File for each file extracted by the Acuisition action
		# idFileList contains the uuid of these files and it is used for
		# creating the Provenance_Record of the Result/Output of the Acquisition 
		# action
		idFilesAcquisition = []
		for i, image_path in enumerate(imagePath):
			if imageMetadataHashSHA[i].strip() == '':
				idFileAcquisition = self.__generateTraceFile(image_path, 
				imageSize[i], 'MD5', imageMetadataHashMD5[i], '', 
				'', '', '', '', '', '', '', '', '', '', '', '')  				 				
			else:
				idFileAcquisition = self.__generateTraceFile(image_path, 
				imageSize[i], 'SHA256', imageMetadataHashSHA[i], '', 
				'', '', '', '', '', '', '', '', '', '', '', '') 				
			
			idFilesAcquisition.append(idFileAcquisition)  	
		

		idProvenanceAcquisitionFiles = \
			self.__generateTraceProvencance(idFilesAcquisition, 
				'Acquisition files', '', deviceAcquisitionStartTime)

		idProvenanceAcquisitionFilesList = []
		idProvenanceAcquisitionFilesList.append(idProvenanceAcquisitionFiles)

		idProvencanceAcquisitionAction = \
		self.__generateTraceInvestigativeAction('acquisition', 
			'Forensic mobile device acquisition', deviceAcquisitionStartTime, 
			deviceAcquisitionEndTime, idTool, '', 
			idIdentity, idProvenanceDevice, idProvenanceAcquisitionFilesList, ',');

		idFilesExtraction = []
		for uuidFile in self.FILEuuid.values(): 
			idFilesExtraction.append(uuidFile)

		idProvenanceExtractionFiles = \
		self.__generateTraceProvencance(idFilesExtraction, 'Extraction',
			'', deviceExtractionStartTime)

		idProvenanceExtractionFilesList = []
		idProvenanceExtractionFilesList.append(idProvenanceExtractionFiles)
		self.__generateTraceInvestigativeAction('extraction', 
			'Forensic mobile device extraction', deviceExtractionStartTime,
			'', idTool, '', idIdentity,
			idProvenanceAcquisitionFiles, idProvenanceExtractionFilesList, '');

	def __generateChainOfEvidence(self, source, location, uuidTrace, write_to_file=True):
		filePath = ''
		charSeparator = '/'
		separator = source.find(charSeparator)
		if separator > - 1:
			filePath = source[separator:]
		else:
			charSeparator = '\\'
			separator = source.find(charSeparator)
			if separator > - 1: 
				filePath = source[separator:]
			else:
				filePath = source
				fileName = source
				fileExt = ''			

		if separator > - 1:
			fileName = filePath.split(charSeparator)[-1]
			fileExt = fileName[fileName.rfind('.') + 1:]

		openPar = source.find('(')
		closePar = source.find(')')
		fileSysType = source[openPar + 1: closePar]
		
		filePath = filePath.replace('"', "").replace('\n', '').replace('\r', '')
		filePath = filePath.replace('\t', " ").replace("\\", "/")

		location = self.__cleanJSONtext(location)

		uuidFile = self.__generateTraceFileCoE(filePath, fileName, fileExt, fileSysType,
			location)

		self.FILEuuid[uuidTrace] = uuidFile
		
		if write_to_file:
			self.__generateTraceRelation(uuidTrace, uuidFile, 'Contained_Within', 
				location, '00001', '', '');
			return ''
		else:
			relation_string = self.__generateStringRelation(uuidTrace, uuidFile, 'Contained_Within', 
				location, '00001', '', '');
			return relation_string

	def __generateLastLine(self):
		line = AXIOMtoJSON.TAB + '] \n }'
		self.FileOut.write(line)

	def __generateTraceAppAccount(self, source, name, identifier, idApp, idIdentity):
		
		name = self.__cleanJSONtext(name)
		identifier = self.__cleanJSONtext(identifier)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject",
			"uco-observable:hasChanged":true,
			"uco-core:hasFacet":[ 
				{
					"@type":"uco-observable:AccountFacet", 
					"uco-observable:accountIdentifier":identifier,
					"uco-observable:isActive":true ,
				}, 
				{
					"@type":"uco-observable:ApplicationAccountFacet", 
					"uco-observable:application":
						{"@id":idApp}
			
				},
				{
					"@type":"uco-observable:DigitalAccountFacet",
					"uco-observable:displayName":name
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid
	
	def __generateTraceAppName(self, appName):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[ 
				{
					"@type":"uco-observable:ApplicationFacet", 
					"uco-core:name":appName
				}
			]
		}
				
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceAppIdentity(self, appName):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:IdentityFacet",
			"uco-core:hasFacet":[ 
				{
					"@type":"uco-observable:OrganizationFacet", 
					"uco-observable:orgName":appName
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid
		

	def __generateTraceChatAccount(self, issuer, partyId, partyName, idApp):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		
		partyId = self.__cleanJSONtext(partyId)
		partyName = self.__cleanJSONtext(partyName)

		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:AccountFacet",
					"uco-observable:accountIdentifier":partyId,
					"uco-observable:isActive":True
				},
				{
					"@type":"uco-observable:ApplicationAccountFacet",
					"uco-observable:application":
						{
							"@id":idApp
						}
				},
				{
					"@type":"uco-observable:DigitalAccountFacet",
					"uco-observable:displayName":partyName
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceChat(self, body, idApplication, timeStamp, idFrom,
		idToList, status, outcome, direction, attachmentNames, 
		attachmentUrls):
				
		TOlist = '[{"@id":"' + idToList + '"}]'.replace('\t', ' ')
		TOlist = json.loads(TOlist)

		body = self.__cleanJSONtext(body)
		timeStamp = self.__cleanDate(timeStamp)
		

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:MessageFacet", 
					"uco-observable:messageText":body,
					"uco-observable:application":{
						"@id":idApplication
					},
					"uco-observable:sentTime":{
						"@type":"xsd:dateTime",
						"@value":timeStamp
					},
					"uco-observable:from":{
						"@id":idFrom
					},
					"uco-observable:to":TOlist,
					"uco-observable:allocationStatus":status,
					"uco-observable:messageType":"CHAT Message"
				}			
			]
		}

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		
#---	each Message, within a specific Chat can have more than one attachment,
# 		both the Filenames and the Urls of the Attachment are separated by
# 		a triple hash tag # 
#		
		listFileNames = attachmentNames.split('###');
		listFileUrls = attachmentUrls.split('###');
		nName = len(listFileNames)
		nUrl = len(listFileUrls)
		if nName > nUrl:
			for i in range(nName - nUrl):
				listFileUrls.append('')
		if nName < nUrl:
			for i in range(nUrl - nName):
				listFileNames.append('')


		for i, list_file_name in enumerate(listFileNames):
			if (list_file_name.strip() != '') or \
			 	(listFileUrls[i].strip() != ''):
#---	listFileUrls[i] will be stored in the property path of the FILE trace
#			 	
				fileUuid = self.__generateTraceFile(list_file_name, 
				'', '', '', '', '', '', '', listFileUrls[i],
				'', '', '', '', '', '', '', '')
				
				self.__generateTraceRelation(fileUuid, uuid, 'Attached_To', 
				'', '', '', '')
		return uuid

	
	def __generateTraceDeviceDisk(self, size, partitions_ref):

		partitions = '['
		for i, partition in enumerate(partitions_ref):
			partitions += '{"@id":"' + partition + '"},'

		partitions = json.loads(partitions[0:-1] + ']')

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject",
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:DiskFacet",
					"uco-observable:diskType": "Fixed",
					"uco-observable:diskSize":size,
					"uco-observable:partition":partitions
				}
			]
		}


		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceDiskPartition(self, volume, partition_type, partition_space, 
		partition_space_left, partition_space_used, partition_offset):
		
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject",
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:DiskPartitionFacet",
					"uco-observable:serialNumber":volume,
					"uco-observable:diskPartitionType":partition_type,
					"uco-observable:totalSpace":partition_space,
					"uco-observable:spaceLeft":partition_space_left,
					"uco-observable:spaceUsed":partition_space_used,
					"uco-observable:partitionOffset":partition_offset
				}
			]
		}

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceDeviceMobile(self, deviceId, deviceIMSI, deviceBluetoothAddress, 
		deviceBluetoothName, deviceIMEI, deviceSN, deviceName, 
		deviceModel, deviceICCID, deviceOSVersion):

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject",
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:DeviceFacet",
					"uco-observable:model":deviceModel,
					"uco-observable:serialNumber":deviceSN,
				},
				{
					"@type":"uco-observable:MobileDeviceFacet",
					"uco-observable:IMSI":deviceIMSI,
					"uco-observable:ICCID":deviceICCID,
					"uco-observable:IMEI":deviceIMEI,
				},
				{
					"@type":"uco-observable:OperatingSystemFacet",
					"uco-observable:version":deviceOSVersion,
				},
				{
					"@type":"uco-observable:BluetoothAddressFacet",
					"uco-core:name":deviceBluetoothName,
					"uco-observable:addressValue":deviceBluetoothAddress,
				}
			]
		}

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	
	def __generateTraceEmail(self, EMAILid, EMAILstatus, EMAILsource, EMAILlocation,
		EMAILidentifierFROM, EMAILidentifiersTO, EMAILidentifiersCC, 
		EMAILidentifiersBCC, EMAILbody, EMAILsubject, EMAILtimeStamp, 
		EMAILattachmentsFilename):
		
		address_from = re.search(self.EMAILregex, EMAILidentifierFROM)
		if address_from:
			idFROM = self.__checkEmailAddress(address_from.group().strip())
		else:
			idFROM = self.__checkEmailAddress(EMAILidentifierFROM.strip())
				
		itemsTO = ''		
		EMAILtoList = re.findall(self.EMAILregex, EMAILidentifiersTO)
		email_distinct = set(EMAILtoList)
		for item in email_distinct:			
			if item.strip() != '':				
				uuidEmail = self.__checkEmailAddress(item.strip().lower())
				idTO = '{"@id":"' + uuidEmail + '"}'
				itemsTO += idTO + ','
		
		itemsTO = json.loads('[' + itemsTO[0:-1] + ']')

		itemsCC = ''
		EMAILtoList = re.findall(self.EMAILregex, EMAILidentifiersCC)
		email_distinct = set(EMAILtoList)
		for item in email_distinct:
			if item.strip() != '':
				uuidEmail = self.__checkEmailAddress(item.strip().lower())
				idCC = '{"@id":"' + uuidEmail + '"}'
				itemsCC += idCC + ','

		itemsCC = json.loads('[' + itemsCC[0:-1] + ']')
		
		itemsBCC = ''
		EMAILtoList = re.findall(self.EMAILregex, EMAILidentifiersBCC)
		email_distinct = set(EMAILtoList)
		for item in email_distinct:
			if item.strip() != '':
				uuidEmail = self.__checkEmailAddress(item.strip().lower())
				idBCC = '{"@id":"' + uuidEmail + '"}'
				itemsBCC += idBCC + ','

		itemsBCC = json.loads('[' + itemsBCC[0:-1] + ']')

		body = self.__cleanJSONtext(EMAILbody)
		subject = self.__cleanJSONtext(EMAILsubject)
#--- Replace all characters different from number, space or character with nothing
#		
		subject = re.sub('[^0-9A-Za-z ]','', subject)

#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx
#			the character "/" is not allowed
#		
		EMAILtimeStamp = self.__cleanDate(EMAILtimeStamp)	

		uuid = "kb:" + AXIOMtoJSON.__createUUID()

		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:EmailMessageFacet",
					"uco-observable:sentTime":{
						"@type":"xsd:dateTime",
						"@value":EMAILtimeStamp
					},
					"uco-observable:isMimeEncoded":False,
					"uco-observable:isMultipart":False,
					"uco-observable:from":{
						"@id":idFROM
					},
					"uco-observable:to":itemsTO,
					"uco-observable:cc":itemsCC,
					"uco-observable:bcc":itemsBCC,
					"uco-observable:body":body,
					"uco-observable:subject":subject,
					"uco-observable:allocationStatus":EMAILstatus
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')

		self.__generateChainOfEvidence(EMAILsource, EMAILlocation, uuid)		

		email_attachment_list = EMAILattachmentsFilename.split(',')
		for i, email_file in enumerate(email_attachment_list):
			if email_file.strip() != '':
				fileUuid = self.__generateTraceFile(email_file, 
				'', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '')
				self.__generateTraceRelation(fileUuid, uuid, 'Attached_To', 
				'', '', '', '')
		
		return uuid

	def __generateTraceEmailAccount(self, address):
		
		uuidAddress = self.__generateTraceEmailAddress(address)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,\
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:AccountFacet",
					"uco-observable:isActive":True,
					"uco-observable:accountIdentifier":""
				},
				{
				"@type":"uco-observable:EmailAccountFacet",
				"uco-observable:emailAddress":
					{"@id":uuidAddress }
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceEmailAddress(self, address):
		
		address = self.__cleanJSONtext(address)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:EmailAddressFacet", 
					"uco-observable:addressValue":address
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid


	def __generateTraceFile(self, FILEpath, FILEsize, FILEhashType, 
		FILEHashValue, FILETag, FILEtimeC, FILEtimeM, FILEtimeA, FILElocalPath, 
		FILEextension, FILEexifMake, FILEexifModel, FILEexifLatitudeRef, FILEexifLatitude, 
		FILEexifLongitudeRef, FILEexifLongitude, FILEexifAltitude):
		
		head, tail = os.path.split(FILEpath)
		tail = tail.replace("\\", "/")
		tail = tail.replace('"', "'")
		path = FILEpath.replace('\\', '/')
		path = path.replace('"', "'")
		dotPos = tail.find('.')
		sExt = ''
		if dotPos > -1:
			sExt = tail[dotPos:]
		
		if FILEHashValue.upper() == 'N/A':
			FILEHashValue = '0';

		if FILEhashType.upper() == '_NOT_PROVIDED_':
			FILEhashType = 'MD5';


		if FILEsize.strip() == '':
			FILEsize = '0'

		sizeFile = ''
		if FILEsize.strip() != '0':
			sizeFile = '{' +\
				'"@type":"uco-observable:ContentDataFacet",' +\
				'"uco-observable:hash":[' +\
				'{' +\
				'"@type":"uco-types:Hash",' +\
				'"uco-types:hashMethod":' +\
				'{' +\
				'"@type":"uco-vocabulary:HashNameVocab",' +\
				'"@value":"' + FILEhashType + '"' +\
				'},' +\
				'"uco-types:hashValue":' +\
				'{' +\
				'"@type":"xsd:hexBinary",' +\
				'"@value":"' + FILEHashValue  + '"' +\
				'}' +\
				'}' +\
				'] ' +\
				'}'
			
		if sizeFile != '':
			sizeFile = json.loads(sizeFile)

		localPath = FILEpath.replace('"', "").replace('\n', '').replace('\r', '')
		localPath = localPath.replace("\\", "/")
		
		FILEtimeC = self.__cleanDate(FILEtimeC)
		FILEtimeM = self.__cleanDate(FILEtimeM)
		FILEtimeA = self.__cleanDate(FILEtimeA)			
		
		line_exif = ''
		if FILEexifLatitude.strip() != '':
			FILEexifLatitude = FILEexifLatitude.strip('" ')			
			FILEexifLongitude = FILEexifLongitude.strip('" ')
			FILEexifLatitude = FILEexifLatitude.replace('Â°', ', ').replace("'", ', ')
			FILEexifLongitude = FILEexifLongitude.replace('Â°', ', ').replace("'", ', ')
			FILEexifAltitude = FILEexifAltitude.strip('" ')
			line_exif = '{' +\
				'"@type":"uco-observable:EXIFFacet",' +\
				'"uco-observable:exifData": {' +\
				'"@type":"uco-types:ControlledDictionary",' +\
				'"uco-types:entry": [' +\
				'{' +\
				'"@type":"uco-types:ControlledDictionaryEntry",' +\
				'"uco-types:key":"Make",' +\
				'"uco-types:value":"' + FILEexifMake + '"' +\
				'},' +\
				'{' +\
				'"@type":"uco-types:ControlledDictionaryEntry",' +\
				'"uco-types:key":"Model",' +\
				'"uco-types:value":"' + FILEexifModel + '"' +\
				'},' +\
				'{' +\
				'"@type":"uco-types:ControlledDictionaryEntry",' +\
				'"uco-types:key":"LatitudeRef",' +\
				'"uco-types:value":"' + FILEexifLatitudeRef + '"' +\
				'},' +\
				'{' +\
				'"@type":"uco-types:ControlledDictionaryEntry",' +\
				'"uco-types:key":"Latitude",' +\
				'"uco-types:value":"' + FILEexifLatitude + '"' +\
				'},' +\
				'{' +\
				'"@type":"uco-types:ControlledDictionaryEntry",' +\
				'"uco-types:key":"LongitudeRef",' +\
				'"uco-types:value":"' + FILEexifLongitudeRef + '"' +\
				'},' +\
				'{' +\
				'"@type":"uco-types:ControlledDictionaryEntry",' +\
				'"uco-types:key":"Longitude",' +\
				'"uco-types:value":"' + FILEexifLongitude + '"' +\
				'},' +\
				'{' +\
				'"@type":"uco-types:ControlledDictionaryEntry",' +\
				'"uco-types:key":"Altitude",' +\
				'"uco-types:value":"' + FILEexifAltitude + '"' +\
				'}' +\
				']' +\
				'}' +\
				'}'

		if line_exif != '':
			line_exif = json.loads(line_exif)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject",
			"uco-observable:hasChanged":True,
			"uco-core:tag":[
				FILETag

			],
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:FileFacet",
					"uco-observable:fileName":tail,
					"uco-observable:filePath":path,
					"uco-observable:fileLocalPath":localPath,
					"uco-observable:extension":sExt,
					"uco-observable:fileSystemType":"userdata (ExtX)",
					"uco-observable:isDirectory":False,
					"uco-observable:sizeInBytes": {
						"@type":"xsd:integer",
						"@value":FILEsize,
					},
					"uco-core:objectCreatedTime":{
						"@type":"xsd:dateTime",
						"@value":FILEtimeC
					},
					"uco-core:objectModifiedTime":{
						"@type":"xsd:dateTime",
						"@value":FILEtimeM
					},
					"uco-core:objectAccessedTime":{
						"@type":"xsd:dateTime",
						"@value":FILEtimeA
					}
				},
				sizeFile , 
				line_exif, \
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		
		return uuid

#---	FileFacet for the Chain of Evidence
#		the data are FileName, FilePath, FileExt, FileSystemType
#		
	def __generateTraceFileCoE(self, FILEpath, FILEname, FILEext, FILEsysType, 
		FILElocation):
		
		FILEsysType = self.__cleanJSONtext(FILEsysType)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()		

		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:tag":["Binary"],
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:FileFacet",
					"uco-observable:fileName":FILEname,
					"uco-observable:filePath":FILEpath,
					"uco-observable:extension":FILEext,
					"uco-observable:fileSystemType":FILEsysType,
					"uco-observable:isDirectory":False,
					"uco-observable:comment":FILElocation
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceIdentity(self, name, familyName, birthDate):
		
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		birthDate = self.__cleanDate(birthDate)

		object_dict = {
			"@id": uuid,
			"@type":"uco-identity:Identity", 
			"uco-core:hasFacet":[
				{
					"@type":"uco-identity:SimpleName",
					"uco-identity:givenName":name,
					"uco-identity:familyName":familyName
				},
				{
					"@type":"uco-identity:BirthInformation",
					"uco-identity:birthdate":{
						"@type":"xsd:dateTime",
						"@value":birthDate
					}
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceLocationDevice(self, loc_id, loc_longitude, loc_latitude, 
		loc_category):
		
		uuidLocation = self.__checkGeoCoordinates(loc_latitude, loc_longitude,
			'', loc_category)

		return uuidLocation

	def writePhoneAccountFromContacts(self, CONTACTname, CONTACTphoneNums):
		for i, contact_name in enumerate(CONTACTname):
			CONTACTphoneNums[i] = CONTACTphoneNums[i].replace(' ', '')
			if CONTACTphoneNums[i] not in self.phoneNumberList:					
				self.phoneNumberList.append(CONTACTphoneNums[i])
				self.phoneNameList.append(contact_name)
				mobileOperator = ""
				uuid = self.generateTracePhoneAccount(mobileOperator, contact_name, 
					CONTACTphoneNums[i])
				self.phoneUuidList.append(uuid)

	def generateTracePhoneAccount(self, source, name, phoneNum):
		
		name = self.__cleanJSONtext(name)
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[ 
				{
					"@type":"uco-observable:AccountFacet", 
					"uco-observable:accountIssuer":source,
					"uco-observable:isActive":True,
					"uco-observable:accountIdentifier":""
				}, 
				{
					"@type":"uco-observable:PhoneAccountFacet",
					"uco-observable:phoneNumber":phoneNum,
					"uco-core:name":name
				}
			]
		}
				
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceSearchedItem(self, search_id, search_value, search_timestamp, 
		search_source):

		search_value = self.__cleanJSONtext(search_value)
		if search_value.strip() == '':
			return ''
			
		search_timestamp = self.__cleanDate(search_timestamp)		

		if not self.__checkSearchedItems(search_value + search_timestamp):
			return ''

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"draft:SearchedItemFacet", 
					"draft:searchSource":search_source,
					"draft:searchLaunchedTime":{ 
						"@type":"xsd:dateTime",
						"@value":search_timestamp
					},
					"draft:searchValue":search_value
				}
			]
		}

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceInvestigativeAction(self, name, description, startTime, endTime, 
		idInstrument, location, idPerformer, idObject, listResult, endChar):
		
		n = len(listResult)
		lineResult = '['
		for i in range(n - 1):
			lineResult += '{"@id":"' + listResult[i] + '"},';

		if n > 0:
			lineResult += '{"@id":"' + listResult[n - 1]  + '"}'
			
		lineResult += ']';

		lineResult = json.loads(lineResult)

		idObject = '[' + \
					'{"@id":idObject}]'
		idObject = json.loads(idObject)
		
		startTime = self.__cleanDate(startTime)
		endTime = self.__cleanDate(endTime)
		
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-action:Action", 
			"uco-action:name":name,
			"uco-action:description":description,
			"uco-action:startTime":{
				"@type":"xsd:dateTime",
				"@value":startTime
			},
			"uco-action:endTime":{
				"@type":"xsd:dateTime",
				"@value":endTime
			},
			"uco-core:hasFacet":[
				{
					"@type":"uco-action:ActionReferences",
					"uco-action:instrument":{
						"@id":idInstrument
					},
					"uco-action:location":{
						"@id":location
					},
					"uco-action:performer":{
						"@id":idPerformer
					},
					"uco-action:object":idObject,
					"uco-action:result":lineResult			
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTracePhoneCall(self, direction, startTime, idFROM, idTO, 
								duration, status, outcome):
		nTime = 0
		if duration != '':
			aTime = duration.split(":")
			if len(aTime) == 3:
				nTime = aTime[0]*3600 + aTime[1]*60 + aTime[2] 
			if len(aTime) == 2:
				nTime = aTime[0]*60 + aTime[1] 
			if len(aTime) == 1:
				nTime = aTime[0] 
		duration = str(nTime)
		duration = duration.lstrip('0')
		if duration == "":
			duration = "0"

		if "Native" in self.appNameList: 
			idx = self.appNameList.index("Native")
			idAppName = self.appNameList[idx]
			idAppIdentity = self.appIDList[idx]
		else:
			idAppIdentity = self.__generateTraceAppName("Native")
			self.appNameList.append("Native")
			self.appIDList.append(idAppIdentity)
		
		startTime = self.__cleanDate(startTime)
		
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[ 
				{ 
					"@type":"uco-observable:PhoneCallFacet", 
					"uco-observable:callType":direction,
					"uco-observable:startTime":{
						"@type":"xsd:dateTime",
						"@value":startTime
					},
					"uco-observable:application":{ 
						"@id":idAppIdentity
					},
					"uco-observable:from":{
						"@id":idFROM
					},
					"uco-observable:to":{
						"@id":idTO
					},
					"uco-observable:duration":{
						"@type":"xsd:long",
						"@value":duration
					},
					"uco-observable:allocationStatus":status
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')

		return uuid
	

	def __generateTracePhoneOwner(self, Source, Name, PhoneNum):
		
		self.phoneOwnerUuid = "kb:" + AXIOMtoJSON.__createUUID()
		
		object_dict = {
			"@id": self.phoneOwnerUuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[ 
				{
					"@type":"uco-observable:AccountFacet", 
					"uco-observable:isActive":True,
					"uco-observable:accountIdentifier":" "
				}, 
				{
					"@type":"uco-observable:PhoneAccountFacet", 
					"uco-observable:phoneNumber":PhoneNum,
					"uco-core:name":Name,
					"uco-observable:accountIssuer":Source
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		
		self.phoneNumberList.append(PhoneNum)
		self.phoneUuidList.append(self.phoneOwnerUuid)

	def __generateTraceProvencance(self, idTracesList, description, 
		exhibitNumber, creationTime):
		
		n = len(idTracesList)
		lineTraces = '['		
		for idx in range(n - 1):
			lineTraces += '{"@id":"' + idTracesList[idx] + '"},'

		if n > 0:
			lineTraces += '{"@id":"' + idTracesList[n - 1] + '"}]'

		lineTraces = json.loads(lineTraces)
		creationTime = self.__cleanDate(creationTime)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"case-investigation:ProvenanceRecord", 
			"case-investigation:createdTime":{
				"@type":"xsd:dateTime",
				"@value":creationTime
			},
			"case-investigation:description":description,
			"case-investigation:exhibitNumber":exhibitNumber,			
			"case-investigation:object":lineTraces			
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')

		return uuid
	
	def __generateStringRelation(self, source, target, relation, table, offset,
		start_date, end_date):		
		
		start_date = self.__cleanDate(start_date)
		end_date = self.__cleanDate(end_date)
		lineTable = ''
		if not table == '':
			cleanOffset = offset.replace('@', '')
			lineTable = '{' + \
				'"@type":"uco-observable:DataRangeFacet",' + \
				'"uco-observable:rangeOffset": {' + \
					'"@type":"xsd:integer", ' + \
					'"@value":"' + cleanOffset + '"' + \
				'},' +\
				'"uco-observable:rangeSize": {' + \
					'"@type":"xsd:integer", ' + \
					'"@value":"0"' + \
				'}' + \
			'}'
						
		lineTable = json.loads(lineTable)
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableRelationship",
			"uco-observable:startTime":
				{
					"@type":"xsd:dateTime",
					"@value":start_date
				},
			"uco-observable:endTime":
				{
					"@type":"xsd:dateTime",
					"@value":end_date
				},
			"uco-core:source":
				{
					"@id":source
				},
			"uco-core:target":
				{
					"@id":target
				},
			"uco-core:kindOfRelationship":relation,
			"uco-core:isDirectional":True,
			"uco-core:facets": [
				lineTable
			]	
		}
		object_str = json.dumps(object_dict, indent = 4)
		return object_str + ',\n'

	def __generateTraceRelation(self, source, target, relation, table, offset,
		start_date, end_date):
		
		start_date = self.__cleanDate(start_date)
		end_date = self.__cleanDate(end_date)

		lineTable = ''
		if not table == '':
			cleanOffset = offset.replace('@', '')
			lineTable = '{' + \
				'"@type":"uco-observable:DataRangeFacet",' + \
				'"uco-observable:rangeOffset": {' + \
					'"@type":"xsd:integer", ' +\
					'"@value":"' + cleanOffset + '"' +\
				'},' +\
				'"uco-observable:rangeSize": {' + \
					'"@type":"xsd:integer", ' + \
					'"@value":"0"' + \
				'}' + \
			'}'
						
		if lineTable != '':
			lineTable = json.loads(lineTable)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableRelationship",
			"uco-observable:startTime":
				{
					"@type":"xsd:dateTime",
					"@value":start_date
				},
			"uco-observable:endTime":
				{
					"@type":"xsd:dateTime",
					"@value":end_date
				},
			"uco-core:source":
				{
					"@id":source
				},
			"uco-core:target":
				{
					"@id":target
				},
			"uco-core:kindOfRelationship":relation,
			"uco-core:isDirectional":True,
			"uco-core:facets": [
				lineTable
			]	
		}
		object_str = json.dumps(object_dict, indent = 4)
		
		self.FileOut.write(object_str + ',\n')

	def __generateTraceRole(self, role):
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-role:Role", 
			"uco-role:name":role
		}

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		
		return uuid


	def __generateThreadMessages(self, chatTraceId, chatThread, chatIdAccountList):
		
		nChatThread = len(chatThread)
		lineThread  = '['
		for i in range(nChatThread):
			lineThread += '{'
			lineThread += '"olo:index":"' + str(i + 1) + '",'
			lineThread += '"olo:item": {'
			lineThread += '"@id":"' + chatThread[i] + '"'
			lineThread += '}'
			lineThread += '},'

		lineThread = json.loads(lineThread[0:-1] + ']')

		nChatAccounts = len(chatIdAccountList)
		lineChatAccounts = '['		
		for i in range(nChatAccounts - 1):
			lineChatAccounts += '{"@id":"' + chatIdAccountList[i] + '"},'

		if nChatAccounts > 0:
			lineChatAccounts += '{"@id":"' + chatIdAccountList[nChatAccounts - 1] + '"}]\n' 
		else:
			lineChatAccounts += ']'

		lineChatAccounts = json.loads(lineChatAccounts)
		str_chatThread = str(len(chatThread))
		str_nChatThread = str(nChatThread)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:MessageThreadFacet",
					"uco-observable:displayName":"",
					"uco-observable:message":{
						"olo:length":str_chatThread,
						"olo:slot":lineThread
					},
					"uco-observable:participants":lineChatAccounts
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')

		return uuid

	def __generateTraceTool(self, name, type, vendor, version, confList):
		
		
		line = '['
		if len(confList) > 0:  
			line += '{'
			line += '"@type":"uco-tool:ConfigurationSettingType",'
			line += '"configurationSetting":['
			n = len(confList) - 1
			for i in range(n):
				listItems = []
				listItems = confList[i].split('@');
				line += '{' 
				line += '"@type":"uco-tool:ConfigurationSettingType",'
				line += '"uco-tool:itemName":"' + listItems[0] + '",'
				line += '"uco-tool:itemValue":"' + listItems[1] + '"'
				line += '},' 
 
			listItems.clear()
			listItems += confList[n].split('@')
			line += '{'
			line += '"@type":"uco-observable:ConfigurationSettingFacet",'
			line += '"uco-observable:itemName":"' + listItems[0] + '",' 
			line += '"uco-observable:itemValue":"' + listItems[1] + '"'
			line += '}'
			line += ']'
			line += '}'
			line += ']'
			line += '}]';
		else:
			line += ']';

		line = json.loads(line)

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-tool:Tool", 
			"uco-core:name":name,
			"uco-tool:toolType":type,
			"uco-tool:creator":vendor,
			"uco-tool:version":version
		}
		#"uco-core:hasFacet":line

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceURL (self, URL_Value):
		
		URL_Value = self.__cleanJSONtext(URL_Value)
		
		URL_Value = URL_Value.strip()

		if  URL_Value in self.UrlList.keys(): 
			uuid = self.UrlList.get(URL_Value)
		else:
			uuid = "kb:" + AXIOMtoJSON.__createUUID()	
			self.UrlList[URL_Value] = uuid						
		
			object_dict = {
				"@id": uuid,
				"@type":"uco-observable:ObservableObject", 
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[
					{
						"@type":"uco-observable:URLFacet", 
						"uco-observable:fullValue":URL_Value
					}
				]
			}

			object_str = json.dumps(object_dict, indent = 4)
			self.FileOut.write(object_str + ',\n')

		return uuid

	def __generateTraceWebPages(self, WEB_PAGEid, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGElastVisited,
				WEBsource, WEBlocation, WEBrecoveryMethod):

			if WEB_PAGEurl.strip() == '':				
				return ''

			WEB_PAGElastVisited = self.__cleanDate(WEB_PAGElastVisited)

			if WEB_PAGEsource.strip() in self.appNameList: 
				idx = self.appNameList.index(WEB_PAGEsource.strip())
				idAppName = self.appNameList[idx]
				idAppIdentity = self.appIDList[idx]
			else:
				idAppIdentity = self.__generateTraceAppName(WEB_PAGEsource.strip())
				self.appNameList.append(WEB_PAGEsource.strip())
				self.appIDList.append(idAppIdentity)

			uuidUrl = self.__generateTraceURL(WEB_PAGEurl)
			title = WEB_PAGEtitle.replace('"', '')
			
			visit_count = WEB_PAGEvisitCount.strip()
			if visit_count == '':
				visit_count= '0' 
			
			uuid = "kb:" + AXIOMtoJSON.__createUUID()
			object_dict = {
				"@id": uuid,
				"@type":"uco-observable:ObservableObject", 
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[
					{
						"@type":"uco-observable:URLHistoryFacet", 
						"uco-observable:browserInformation":{
							"@id":idAppIdentity
						},
						"uco-observable:urlHistoryEntry": [
							{
								#"@type":"uco-observable:URLHistoryEntry",
								"uco-observable:firstVisit":{
									"@type":"xsd:dateTime",
									"@value":"1900-01-01T08:00:00"
								},
								"uco-observable:lastVisit":{
									"@type":"xsd:dateTime",
									"@value":WEB_PAGElastVisited
								},
								"uco-observable:expirationTime":{
									"@type":"xsd:dateTime",\
									"@value":"1900-01-01T08:00:00"
								},
								"uco-observable:userProfile":"",			
								"uco-observable:url":{
									"@id":uuidUrl
								},
								"uco-observable:pageTitle":title, 
								"uco-observable:visitCount":visit_count, 			
								"uco-observable:manuallyEnteredCount":{
									"@type":"xsd:nonNegativeInteger",
									"@value":"0"
								},
								"uco-observable:keywordSearchTerm":"NULL"
							}
						]
					}
				]
			}
			
			object_str = json.dumps(object_dict, indent = 4)
			self.FileOut.write(object_str + ',\n')
			
			str_coe = self.__generateChainOfEvidence(WEBsource, WEBlocation, uuid, write_to_file=False)
			return str_coe			

	def __generateTraceCellTower(self, cell_id, cell_mcc, cell_mnc, cell_lac, 
		cell_cid, cell_longitude, cell_latitude, cell_timeStamp):

		cell_timeStamp = self.__cleanDate(cell_timeStamp)

		uuidLocation = self.__checkGeoCoordinates(cell_latitude, cell_longitude,
			 '', 'Cell Tower')
		
		uuid = ''
		if uuidLocation != '':
			cell_id = cell_mcc.strip() + '@' + cell_mnc.strip() +'@' + \
				cell_lac.strip() + '@' + cell_cid.strip()			
	#---	identifier of the Cell Tower cannot be empty
	#			
			if cell_id != '@@@':
				if cell_id in self.CELL_TOWER_gsm.keys():		
					uuid = self.CELL_TOWER_gsm.get(cell_id)
				else:
					uuid = "kb:" + AXIOMtoJSON.__createUUID()
					self.CELL_TOWER_gsm[cell_id] = uuid
					object_dict = {
						"@id": uuid,
						"@type":"uco-observable:ObservableObject", 
						"uco-observable:hasChanged":True,
						"uco-core:hasFacet":[
							{
								"@type":"draft:CellTowerFacet",
								"draft:mcc":cell_mcc,
								"draft:mnc":cell_mnc,
								"draft:lac":cell_lac,
								"draft:cid":cell_cid,
								"uco-observable:location":{
									"@id":uuidLocation
								}
							}
						]
					}

					object_str = json.dumps(object_dict, indent = 4)
					self.FileOut.write(object_str + ',\n')
			
		return uuid

	def __generateTraceCookie(self, cookie_item_id, cookie_source,
				cookie_name, cookie_value, cookie_domain, cookie_creationTime, 
				cookie_lastAccessedTime, cookie_expirationTime):

		cookie_creationTime = self.__cleanDate(cookie_creationTime)
		cookie_lastAccessedTime = self.__cleanDate(cookie_lastAccessedTime)
		
		cookie_expirationTime = self.__cleanDate(cookie_expirationTime)
		cookie_value = cookie_value.replace('"', '')

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:BrowserCookieFacet", 
					"draft:source":cookie_source,
					"uco-observable:cookieName":cookie_name,
					"uco-observable:cookiePath":cookie_value,
					"uco-observable:cookieDomain":cookie_domain,
					"uco-observable:observableCreatedTime":{ 
						"@type":"xsd:dateTime",
						"@value":cookie_creationTime
					},
					"uco-observable:lastAccessTime":{ 
						"@type":"xsd:dateTime",
						"@value":cookie_lastAccessedTime
					},
					"uco-observable:expirationTime":{ 
						"@type":"xsd:dateTime",
						"@value":cookie_expirationTime
					}
				}
			]
		}
				
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceLocationCoordinate(self, latitude, longitude, altitude, type):
		
		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		id = latitude + '@' + longitude
		self.LOCATION_lat_long_coordinate[id] = uuid
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-location:LatLongCoordinatesFacet",
					"uco-location:latitude":latitude,
					"uco-location:longitude":longitude,
					"uco-location:altitude":altitude,
					"draft:locationType":type
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceWinTimeline(self, timeline_id, timeline_app_name,
				timeline_activity_type, timeline_timeStamp):

		timeline_timeStamp = self.__cleanDate(timeline_timeStamp)
		if timeline_activity_type.strip() == '':
			return ''
		
		timeline_app_name = self.__cleanJSONtext(timeline_app_name)			

		uuid = "kb:" + AXIOMtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:EventFacet", 
					"uco-observable:observableCreatedTime":{ 
						"@type":"xsd:dateTime",
						"@value":timeline_timeStamp
					},
					"uco-observable:eventType":timeline_activity_type,
					"uco-observable:eventText":timeline_app_name
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid


	def __generateTraceWirelessNet(self, wifi_id, wifi_mac_address, wifi_channel,
		wifi_longitude, wifi_latitude, wifi_timeStamp, wifi_accuracy):
		
		wifi_timeStamp = self.__cleanDate(wifi_timeStamp)

		uuidLocation = self.__checkGeoCoordinates(wifi_latitude, wifi_longitude,
			 '', 'Wireless Network')

		wifi_mac_address = wifi_mac_address.strip()
		
		uuid = ''
		if wifi_mac_address != '':
			if wifi_mac_address in self.WIRELESS_NET_mac_address.keys():
				uuidWifi = self.WIRELESS_NET_mac_address[wifi_mac_address]

			else:
				uuid = "kb:" + AXIOMtoJSON.__createUUID()
				self.WIRELESS_NET_mac_address[wifi_mac_address] = uuid
				
				object_dict = {
					"@id": uuid,
					"@type":"uco-observable:ObservableObject", 
					"uco-observable:hasChanged":True,
					"uco-core:hasFacet":[
						{
							"@type":"uco-observable:WirelessNetworkConnectionFacet", 
							"uco-observable:macAddress":wifi_mac_address,
							"draft:timeConnection":{
								"@type":"xsd:dateTime",
								"@value":wifi_timeStamp
							},
							"uco-observable:accuracy":wifi_accuracy,
							"uco-observable:location":{
								"@id":uuidLocation
							}
						}
					]
				}
				object_str = json.dumps(object_dict, indent = 4)
				self.FileOut.write(object_str + ',\n')
			
		return uuid

	def writeCall(self, CALLid, CALLappName, CALLtimeStamp, CALLdirection, 
				CALLduration, CALLpartner, CALLpartnerName, CALLsource, CALLlocation, 
				CALLrecoveryMethod):
		
		callOutcome = ''
		
		for i, call_id in enumerate(CALLid):
			if CALLdirection[i].lower() == 'incoming':
					phoneTO = self.phoneOwnerNumber
					phoneFROM = CALLpartner[i]
			else:
				phoneTO = CALLpartner[i]
				phoneFROM = self.phoneOwnerNumber

			phonePattern = '\+?[0-9]+'	# phone number pattern
			resPattern = re.match(phonePattern, CALLpartner[i])
			
			if (resPattern):
				if CALLpartner[i] in self.phoneNumberList:
					idx = self.phoneNumberList.index(CALLpartner[i])
					uuidPartner = self.phoneUuidList[idx]
				else:	
					mobileOperator = ""
					self.phoneNumberList.append(CALLpartner[i])
					self.phoneNameList.append(CALLpartnerName[i])
					uuidPartner = self.generateTracePhoneAccount(mobileOperator, 
						CALLpartnerName[i], CALLpartner[i])
					self.phoneUuidList.append(uuidPartner)			
			else:
				if CALLappName[i].strip() in self.appNameList: 
					idx = self.appNameList.index(CALLappName[i].strip())
					idAppName = self.appNameList[idx]
					idAppIdentity = self.appIDList[idx]
				else:
					idAppIdentity = self.__generateTraceAppName(CALLappName[i].strip())
					self.appNameList.append(CALLappName[i].strip())
					self.appIDList.append(idAppIdentity)

				if CALLpartner[i].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(CALLpartner[i].strip())
					uuidPartner = self.CHATaccountIdList[idx]
				else:
					self.CHATparticipantsNameList.append(CALLpartner[i].strip())
					uuidPartner = self.__generateTraceChatAccount(CALLsource[i].strip(),
						CALLpartner[i].strip(), CALLpartner[i].strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(CALLpartner[i].strip())
					self.CHATaccountIdList.append(uuidPartner)						

			if CALLdirection[i].lower() == 'incoming':
				uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
					CALLtimeStamp[i], uuidPartner, self.phoneOwnerUuid, CALLduration[i],
					CALLrecoveryMethod[i], callOutcome)
			else:
				uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
					CALLtimeStamp[i], self.phoneOwnerUuid, uuidPartner, CALLduration[i],
					CALLrecoveryMethod[i], callOutcome)
			
			self.__generateChainOfEvidence(CALLsource[i], CALLlocation[i], uuid)

	def ObservableRelationship(self, CONTACTname, CONTACTphoneNum,
				CONTACTsource, CONTACTlocation, CONTACTrecoveryMethod):
		
		for i, contact_name in enumerate(CONTACTname):
			if CONTACTphoneNum[i] == '':
				continue
			else:
				#phoneNum = CONTACTphoneNum[i].replace('+', '00')
				phoneNum = CONTACTphoneNum[i].replace(' ', '')
				if phoneNum not in self.phoneNumberList:					
					self.phoneNumberList.append(phoneNum)
					self.phoneNameList.append(contact_name)
					mobileOperator = ""
					uuid = self.generateTracePhoneAccount(mobileOperator, contact_name, phoneNum)
					self.phoneUuidList.append(uuid)

	def writeHeader(self):
		uuid = AXIOMtoJSON.__createUUID()
		line = "".join(['{ \n', \
				AXIOMtoJSON.TAB + '"@context": { \n', \
				AXIOMtoJSON.TAB*2 + '"@vocab":"http://caseontology.org/core#", \n', \
				AXIOMtoJSON.TAB*2 + '"not-in-ontology":"https://not-in/ontology#", \n', \
				AXIOMtoJSON.TAB*2 + '"draft":"http://example.org/draft#", \n', \
				AXIOMtoJSON.TAB*2 + '"case-investigation":"https://caseontology.org/ontology/case/investigation#", \n', \
				AXIOMtoJSON.TAB*2 + '"rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#", \n', \
				AXIOMtoJSON.TAB*2 + '"rdfs":"http://www.w3.org/2000/01/rdf-schema#", \n', \
				AXIOMtoJSON.TAB*2 + '"uco-action":"https://unifiedcyberontology.org/ontology/uco/action#", \n', \
				AXIOMtoJSON.TAB*2 + '"uco-core":"https://unifiedcyberontology.org/ontology/uco/core#", \n', \
				AXIOMtoJSON.TAB*2 + '"uco-identity":"https://unifiedcyberontology.org/ontology/uco/identity#",\n', \
				AXIOMtoJSON.TAB*2 + '"uco-role":"https://unifiedcyberontology.org/ontology/uco/role#",\n', \
				AXIOMtoJSON.TAB*2 + '"uco-location":"https://unifiedcyberontology.org/ontology/uco/location#",\n', \
				AXIOMtoJSON.TAB*2 + '"uco-observable":"https://unifiedcyberontology.org/ontology/uco/observable#", \n', \
				AXIOMtoJSON.TAB*2 + '"uco-tool":"https://unifiedcyberontology.org/ontology/uco/tool#", \n', \
				AXIOMtoJSON.TAB*2 + '"uco-types":"https://unifiedcyberontology.org/ontology/uco/types#", \n', \
				AXIOMtoJSON.TAB*2 + '"uco-vocabulary":"https://unifiedcyberontology.org/ontology/uco/vocabulary#", \n', \
#---	OLO is a method for representing lists, CASE didn't really need to implement itself, 
#		implementing ordered lists in an OWL 2 DL compliant  syntax.				
#				
				AXIOMtoJSON.TAB*2 + '"olo":"http://purl.org/ontology/olo/core#", \n', \
				AXIOMtoJSON.TAB*2 + '"xsd":"http://www.w3.org/2001/XMLSchema#" \n', \
				AXIOMtoJSON.TAB*2 + '},\n', \
				'"@id":":bundle-' + uuid + '", \n', \
				'"@type":"uco-core:Bundle",\n', \
				'"uco-core:specVersion":"CASE 0.4 - UCO 0.6",\n', \
				'"uco-core:description":"Extraction from XML report generated by MAGNET AXIOM PROCESS",\n', \
				'"uco-core:object": [\n'])
		self.FileOut.write(line)

	def writeLastLine(self):
		self.__generateLastLine()

	def writePhoneOwner(self, phoneOwnerNumber, phoneOwnerName):
		self.phoneOwnerNumber = phoneOwnerNumber
		mobileOperator = ""
		self.__generateTracePhoneOwner(mobileOperator, phoneOwnerName, 
				phoneOwnerNumber)


	def writeFiles(self, FILEid, FILEtag, FILEname, FILElocalPath, FILEimage,
					FILEsize, FILEcreated, FILEmodified, FILEaccessed, FILEmd5,
					FILEexifMake, FILEexifModel, FILEexifLatitudeRef, FILEexifLatitude, 
					FILEexifLongitudeRef, FILEexifLongitude, FILEexifAltitude,
					FILEsource, FILElocation, FILErecoveryMethod):
			
			for i, file_id in enumerate(FILEid):
				if FILEname[i] == '':
					FILEname[i] = FILEimage[i]
				
				if FILEname[i].find('Binary data') > -1:
					pass
				else:
					fileExt = FILEname[i][FILEname[i].rfind('.') + 1:]

					uuid = self.__generateTraceFile(FILEname[i], FILEsize[i], 
						'MD5', FILEmd5[i],	FILEtag[i], FILEcreated[i], FILEmodified[i], 
						FILEaccessed[i], FILElocalPath[i], fileExt,
						FILEexifMake[i], FILEexifModel[i], FILEexifLatitudeRef[i], 
						FILEexifLatitude[i], FILEexifLongitudeRef[i], 
						FILEexifLongitude[i], FILEexifAltitude[i])

					self.FILEuuid[file_id] = uuid

	def writeChat(self, CHATid, CHATsender, CHATreceiver, CHATdateTimeSent, 
							CHATdateTimeReceived, CHATmessage, CHATmessageStatus, 
							CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod):		

		# print("len(CHATapplication)=" + str(len(CHATapplication)) )
		# print(CHATapplication[len(CHATapplication) - 1])
		# print("len(CHATid)=" + str(len(CHATid)) )
		# print(CHATid[len(CHATid) - 1])
		CHATthreadParticipants = []
		self.fillChatThread(CHATthreadParticipants, CHATid, CHATsender, CHATreceiver,
				CHATdateTimeSent, CHATdateTimeReceived, CHATmessage, CHATmessageStatus,
				CHATapplication, CHATsource, CHATlocation, CHATrecoveryMethod, 
				self.phoneOwnerNumber)			

		for i, chat_id in enumerate(self.CHATids):
#---	CHATidAccountList contains the list of the Mesages uuid of CHATs
#			CHATthread contains the values for the generation of the 
#			ChatThreadFacet Observable	
#								
			self.CHATthread = []	
			self.chatIdAccountList = []			
			for j, chat_id_item in enumerate(chat_id):
				if self.CHATapplications[i][j].strip().lower() in self.appNameList: 
					idx = self.appNameList.index(self.CHATapplications[i][j].strip().lower())
					idAppName = self.appNameList[idx]
					idAppIdentity = self.appIDList[idx]
				else:
					idAppIdentity = self.__generateTraceAppName(self.CHATapplications[i][j].strip().lower())
					self.appNameList.append(self.CHATapplications[i][j].strip().lower())
					self.appIDList.append(idAppIdentity)
				
				if self.CHATsenders[i][j].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(self.CHATsenders[i][j].strip())
					CHATmsgFrom = self.CHATaccountIdList[idx]
				else:
					CHATname = ''
					self.CHATparticipantsNameList.append(CHATname)
					CHATmsgFrom = self.__generateTraceChatAccount(self.CHATapplications[i][j].strip(),
						self.CHATsenders[i][j].strip(), CHATname, idAppIdentity)
					self.CHATparticipantsIdList.append(self.CHATsenders[i][j].strip())
					self.CHATaccountIdList.append(CHATmsgFrom)

				if self.CHATreceivers[i][j].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(self.CHATreceivers[i][j].strip())
					CHATmsgTo = self.CHATaccountIdList[idx]
				else:
					CHATname = ''
					self.CHATparticipantsNameList.append(CHATname)
					CHATmsgTo = self.__generateTraceChatAccount(self.CHATapplications[i][j].strip(),
						self.CHATreceivers[i][j].strip(), CHATname, idAppIdentity)
					self.CHATparticipantsIdList.append(self.CHATreceivers[i][j].strip())
					self.CHATaccountIdList.append(CHATmsgTo)
				

#---	if Identifiers TO is empty, the array CHATpartyIdentifiers must
#		be iterated to find the right Party
#								
				if self.CHATmessageStatuses[i][j].lower().find('received') > - 1:
					CHATdirection = 'Incoming'
					CHATdate = self.CHATdateTimeReceiveds[i][j] 
				else:			
					CHATdirection = 'Outgoing'
					CHATdate = self.CHATdateTimeSents[i][j]
								
				CHATattachmentFileNames = ''
				CHATattachmentUrls = ''
				#print('before __generateTraceChat, FROM: ' + CHATmsgFrom +
				#	', TO: ' + CHATmsgTo)

				chatUuid = self.__generateTraceChat(self.CHATmessages[i][j], idAppIdentity, 
					CHATdate, CHATmsgFrom, CHATmsgTo, self.CHATrecoveryMethods[i][j], 
					self.CHATmessageStatuses[i][j], CHATdirection, CHATattachmentFileNames,
					CHATattachmentUrls)
				self.CHATthread.append(chatUuid)

#---	if there are not messages for this Chat or no ChatAccount has been
# 		generated, the ThreadMessage is not generated. Moreover the Chain of
# 		evidence is built upon the ThreadUuid
#				
			if (len(self.CHATthread) != 0):
				uuidThread = self.__generateThreadMessages(self.CHATids[i][j], self.CHATthread, 
								[CHATmsgFrom, CHATmsgTo])
				self.__generateChainOfEvidence(CHATsource[i], CHATlocation[i], chatUuid)

	def writeDeviceEvent(self, EVENT_LOCKid, EVENT_LOCKstatus, 
                EVENT_LOCKdateTime, EVENT_LOCKsource, EVENT_LOCKlocation, 
                EVENT_LOCKrecoveryMethod):
		for i, device_event_id in enumerate(EVENT_LOCKid):
			uuid= self.__generateTraceDeviceEvent(device_event_id, 
				EVENT_LOCKdateTime[i], 'Device Lock Status', EVENT_LOCKstatus[i])
			if uuid != '':
				self.__generateChainOfEvidence(EVENT_LOCKsource[i], 
					EVENT_LOCKlocation[i], uuid)

	def writeAppUsage(self, EVENT_APP_USEid, EVENT_APP_USEapplication, 
                EVENT_APP_USEstartTime, EVENT_APP_USEendTime,
                EVENT_APP_USEsource, EVENT_APP_USElocation, 
                EVENT_APP_USErecoveryMethod):

		for i, application in enumerate(EVENT_APP_USEapplication):
			uuid= self.__generateTraceAppUsage(EVENT_APP_USEid[i], 
				EVENT_APP_USEstartTime[i], EVENT_APP_USEendTime[i],
				'Application Usage', application)
			if uuid != '':
				self.__generateChainOfEvidence(EVENT_APP_USEsource[i], 
					EVENT_APP_USElocation[i], uuid)


	def writeEmail(self, EMAILid, EMAILapp, EMAILidentifierFROM, 
				EMAILidentifiersTO, EMAILidentifiersCC, EMAILidentifiersBCC, 
				EMAILbody, EMAILsubject, EMAILtimeStamp, EMAILattachmentsFilename,
				EMAILsource, EMAILlocation, EMAILrecoveryMethod):
		
		for i, email_id in enumerate(EMAILid):
			self.__generateTraceEmail(email_id, EMAILrecoveryMethod[i], EMAILsource[i],
				EMAILlocation[i], EMAILidentifierFROM[i], EMAILidentifiersTO[i], 
				EMAILidentifiersCC[i], EMAILidentifiersBCC[i], EMAILbody[i], 
				EMAILsubject[i], EMAILtimeStamp[i], EMAILattachmentsFilename[i])


	def writeDeviceDisk(self,FILE_SYS_INFOvolumeSn, FILE_SYS_INFOfileSystem, 
		FILE_SYS_INFOcapacity, FILE_SYS_INFOunallocated, FILE_SYS_INFOallocated,
        FILE_SYS_INFOoffset):

		DEVICEcapacity = 0
		for i, capacity in enumerate(FILE_SYS_INFOcapacity):
			if capacity != '':
				DEVICEcapacity += int(capacity)

		partitions_ref = []
		for i, volume in enumerate(FILE_SYS_INFOvolumeSn):
			if FILE_SYS_INFOcapacity[i] != '':
				partition_uuid =  self.__generateTraceDiskPartition(volume, 
					FILE_SYS_INFOfileSystem[i], FILE_SYS_INFOcapacity[i],
					FILE_SYS_INFOunallocated[i], FILE_SYS_INFOallocated[i],
					FILE_SYS_INFOoffset[i])
				partitions_ref.append(partition_uuid)

		if partitions_ref:
			self.DEVICEuuid =  self.__generateTraceDeviceDisk(DEVICEcapacity, partitions_ref)

	def writeDeviceMobile(self, DEVICEid, DEVICEimsi, DEVICEbluetoothAddress, 
		DEVICEbluetoothName, DEVICEimei, DEVICEserialNumber, DEVICEname, 
		DEVICEmodel, DEVICEiccid, DEVICEosVersion):
	
		self.DEVICEuuid =  self.__generateTraceDeviceMobile(DEVICEid, DEVICEimsi, 
			DEVICEbluetoothAddress, DEVICEbluetoothName, DEVICEimei, DEVICEserialNumber, 
			DEVICEname, DEVICEmodel, DEVICEiccid, DEVICEosVersion)

	def writeWebPages(self, WEB_PAGEid, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited, 
				WEBsource, WEBlocation, WEBrecoveryMethod):

		str_coe = ''
		for i in range(len(WEB_PAGEid) - 1):
			str_coe += self.__generateTraceWebPages(WEB_PAGEid[i], WEB_PAGEsource[i], WEB_PAGEurl[i], 
					WEB_PAGEtitle[i], WEB_PAGEvisitCount[i],  WEB_PAGlastVisited[i],
					WEBsource[i], WEBlocation[i], WEBrecoveryMethod[i])		
		
#--- last char is space not comma when i == len(WEB_PAGEid)
#			
		if len(WEB_PAGEid) > 0:
			str_coe += self.__generateTraceWebPages(WEB_PAGEid[i], WEB_PAGEsource[i], WEB_PAGEurl[i], 
					WEB_PAGEtitle[i], WEB_PAGEvisitCount[i],  WEB_PAGlastVisited[i],
					WEBsource[i], WEBlocation[i], WEBrecoveryMethod[i])
			self.FileOut.write(str_coe[0:-2])

	
	def writeCell_Tower(self, CELL_TOWERid, CELL_TOWERmcc,
                CELL_TOWERmnc, CELL_TOWERlac, CELL_TOWERcid, 
                CELL_TOWERlongitude, CELL_TOWERlatitude,
                CELL_TOWERtimeStamp,  CELL_TOWERsource, 
                CELL_TOWERlocation, CELL_TOWERrecoveryMethod):

		for i, cell_tower_id in enumerate(CELL_TOWERid):			
			uuid = self.__generateTraceCellTower(cell_tower_id, CELL_TOWERmcc[i],
				CELL_TOWERmnc[i], CELL_TOWERlac[i],CELL_TOWERcid[i], 
                CELL_TOWERlongitude[i], CELL_TOWERlatitude[i], CELL_TOWERtimeStamp[i])
			
			if uuid != '':
				self.__generateTraceRelation(self.phoneOwnerUuid, uuid, 'Located_At', 
				'', '', CELL_TOWERtimeStamp[i], '')
				self.__generateChainOfEvidence(CELL_TOWERsource[i], 
					CELL_TOWERlocation[i], uuid)

	def writeCookie(self, COOKIEid, COOKIEappSource, COOKIEname, COOKIEpath, COOKIEdomain, 
				COOKIEcreatedDate, COOKIEaccessedDate, COOKIEexpirationDate, 
                COOKIEsource, COOKIElocation, COOKIErecoveryMethod):

		for i, cookie_item_id in enumerate(COOKIEid):			
			uuid = self.__generateTraceCookie(cookie_item_id, COOKIEappSource[i],
				COOKIEname[i], COOKIEpath[i], COOKIEdomain[i], COOKIEcreatedDate[i], 
				COOKIEaccessedDate[i], COOKIEexpirationDate[i])
			
			if uuid != '':
				self.__generateChainOfEvidence(COOKIEsource[i], COOKIElocation[i], uuid)

	def writeWinTimeline(self, WIN_TIMELINEid, WIN_TIMELINEappName, WIN_TIMELINEactivityType, 
				WIN_TIMELINEtimeStamp, WIN_TIMELINEsource, WIN_TIMELINElocation, 
                WIN_TIMELINErecoveryMethod):

		for i, timeline_item_id in enumerate(WIN_TIMELINEid):			
			uuid = self.__generateTraceWinTimeline(timeline_item_id, WIN_TIMELINEappName[i],
				WIN_TIMELINEactivityType[i], WIN_TIMELINEtimeStamp[i])
			
			if uuid != '':
				self.__generateChainOfEvidence(WIN_TIMELINEsource[i], WIN_TIMELINElocation[i], uuid)



#---	last Observables: they are not directly written into the file, but
#		put in a string to get rid of the last comma
#			
	def writeLocationDevice(self, LOCATIONid, LOCATIONtype, LOCATIONlatitude,  
		LOCATIONlongitude, LOCATIONcreated, LOCATIONsource, LOCATIONlocation):

		str_coe = ''
		for i, location_id in enumerate(LOCATIONid):
			uuid= self.__generateTraceLocationDevice(location_id, LOCATIONlongitude[i], 
				LOCATIONlatitude[i], 'Significant Location')
			
			if uuid != '':
				self.__generateTraceRelation(self.DEVICEuuid, uuid, 'Mapped_By', 
				'', '', LOCATIONcreated[i], '')
				str_coe += self.__generateChainOfEvidence(LOCATIONsource[i], 
					LOCATIONlocation[i], uuid)		

	def writeSearched_Item(self, SEARCHED_ITEMid, SEARCHED_ITEMvalue, SEARCHED_ITEMtimeStamp, 
				SEARCHED_ITEMappSource, SEARCHED_ITEMsource, SEARCHED_ITEMlocation, 
                SEARCHED_ITEMrecoveryMethod):

		for i, searched_item_id in enumerate(SEARCHED_ITEMid):			
			uuid = self.__generateTraceSearchedItem(searched_item_id, SEARCHED_ITEMvalue[i],
				SEARCHED_ITEMtimeStamp[i], SEARCHED_ITEMappSource[i])
			
			if uuid != '':
				self.__generateChainOfEvidence(SEARCHED_ITEMsource[i], SEARCHED_ITEMlocation[i], uuid)
		
	def writeSms(self, SMSid, SMSsender, SMSrecipient, SMSreceivedDateTime,
					SMSsentDateTime, SMSmessage, SMSdirection, SMSsource,
					SMSlocation, SMSrecoveryMethod):

		for i, sms_id in enumerate(SMSid):
			phoneUuidTo = ''
			phoneUuidFrom = ''
			SMSsenderClean = SMSsender[i].strip()
			if SMSsenderClean.lower() == 'local user':
				SMSsenderClean = self.phoneOwnerNumber


#---	get rid of hex chars byte not accepted in JSON values
#			
			if SMSsenderClean in self.phoneNumberList:						
				idx = self.phoneNumberList.index(SMSsenderClean)						
				userId = self.phoneNumberList[idx]
				phoneParticipantUuid = self.phoneUuidList[idx]
			else:
				senderName = ''
				self.phoneNumberList.append(SMSsenderClean)
				self.phoneNameList.append(senderName)
				mobileOperator = ""		
				SMSsenderClean = self.__cleanJSONtext(SMSsenderClean)
				phoneParticipantUuid = self.generateTracePhoneAccount(mobileOperator, 
					senderName, SMSsenderClean)	
				self.phoneUuidList.append(phoneParticipantUuid)

			SMSrecipientClean = SMSrecipient[i].strip()
			if SMSrecipientClean.lower() == 'local user':
				SMSrecipientClean = self.phoneOwnerNumber

			if SMSrecipientClean in self.phoneNumberList:						
				idx = self.phoneNumberList.index(SMSrecipientClean)						
				userId = self.phoneNumberList[idx]
				phoneRecipientUuid = self.phoneUuidList[idx]
			else:
				recipientName = ''
				self.phoneNumberList.append(SMSrecipientClean)
				self.phoneNameList.append(recipientName)
				mobileOperator = ""
				SMSrecipientClean = self.__cleanJSONtext(SMSrecipientClean)
				phoneRecipientUuid = self.generateTracePhoneAccount(mobileOperator, 
					recipientName, SMSrecipientClean)	
				self.phoneUuidList.append(phoneRecipientUuid)


			body = SMSmessage[i].replace('\n', ' ')
			body = body.replace('"', "'")
			body = body.replace('\t', ' ')
			body = body.replace("\\'", "'")
			body = body.replace("\\", "")
			#body = '?'.join(hex(ord(x))[2:] for x in body)

			if SMSreceivedDateTime[i] == '':
				phoneUuidFrom = phoneParticipantUuid
				phoneUuidTo = '{"@id":"' + phoneRecipientUuid + '"}'	
				SMSdate = SMSsentDateTime[i]
			else:
				phoneUuidFrom = phoneRecipientUuid
				phoneUuidTo = '{"@id":"' + phoneParticipantUuid + '"}'	
				SMSdate = SMSreceivedDateTime[i]

			phoneUuidTo = json.loads('[' + phoneUuidTo + ']')
			uuid = "kb:" + AXIOMtoJSON.__createUUID()
			SMSdate = self.__cleanDate(SMSdate)
			object_dict = {
				"@id": uuid,
				"@type":"uco-observable:ObservableObject", 
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[ 
					{
						"@type":"uco-observable:MessageFacet",
						"uco-observable:messageText":body,
						"uco-observable:messageType":"SMS/Native Message",
						"uco-observable:allocationStatus":SMSrecoveryMethod[i],
						"uco-observable:from":{
							"@id":phoneUuidFrom
						},
						"uco-observable:to":phoneUuidTo,
						"uco-observable:sentTime":{
							"@type":"xsd:dateTime", 
							"@value":SMSdate
						}
					}
				]
			}
						
			object_str = json.dumps(object_dict, indent = 4)
			self.FileOut.write(object_str + ',\n')
			self.__generateChainOfEvidence(SMSsource[i], SMSlocation[i], uuid)

	def writeWireless_Net(self, WIRELESS_NETid, WIRELESS_NETmacAddress,
                WIRELESS_NETchannel, WIRELESS_NETlongitude, WIRELESS_NETlatitude,
                WIRELESS_NETtimeStamp,  WIRELESS_NETaccuracy, WIRELESS_NETsource, 
                WIRELESS_NETlocation, WIRELESS_NETrecoveryMethod):

		for i, wifi_id in enumerate(WIRELESS_NETid):			
			uuid = self.__generateTraceWirelessNet(wifi_id, WIRELESS_NETmacAddress[i],
				WIRELESS_NETchannel[i], WIRELESS_NETlongitude[i], WIRELESS_NETlatitude[i], 
				WIRELESS_NETtimeStamp[i], WIRELESS_NETaccuracy[i])
			
			if uuid != '':
				self.__generateTraceRelation(self.phoneOwnerUuid, uuid, 'Connected_To', 
				'', '', WIRELESS_NETtimeStamp[i], '')
				self.__generateChainOfEvidence(WIRELESS_NETsource[i], 
					WIRELESS_NETlocation[i], uuid)

	def writeContextAxiom(self, axiomVersionText, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText,
		deviceBluetoothAddressText, deviceIdText, deviceModelText, 
		deviceOsTypeText, deviceOsVersionText, deviceVendorText, 
		deviceMacAddressText, deviceIccidText, deviceImsiText, 
		deviceImeiText, imagePath, imageSize, 
		imageMetadataHashSHA, imageMetadataHashMD5):

		self.___generateContextAxiom(ufedVersionText, deviceExtractionStartTime, 
			deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText, 
			deviceBluetoothAddressText, deviceIdText, devicePhoneModelText, 
			deviceOsTypeText, deviceOsVersionText, devicePhoneVendorText, 
			deviceMacAddressText, deviceIccidText, deviceImsiText, 
			deviceImeiText, imagePath, imageSize, 
			imageMetadataHashSHA, imageMetadataHashMD5)


